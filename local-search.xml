<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>艰难的Typecho2Hexo</title>
    <link href="/2022/02/06/%E8%89%B0%E9%9A%BE%E7%9A%84Typecho2Hexo/"/>
    <url>/2022/02/06/%E8%89%B0%E9%9A%BE%E7%9A%84Typecho2Hexo/</url>
    
    <content type="html"><![CDATA[<p>闲来无事，打算把以前在 typecho 的文章，迁移这个博客上面来。于是就有了以下痛苦<del>无聊</del>的过程，现将其记录于此。 <span id="more"></span></p><h2 id="install-typecho">Install Typecho</h2><p>由于之前备份了 typecho 的数据库，所以装一个上去还原就是了。<br />于是直接用 qemu 起了一个 ubuntu18.04 server。为了节省时间，lnmp用的是<a href="https://lnmp.org/">lnmp一键安装包</a>。之后直接进phpmyadmin还原就完事了。</p><blockquote><p>note: 因为是本地安装，所以 lnmp vhost add 随便写个域名，之后去 /usr/local/nginx 自行修改server，port地址就行了</p></blockquote><h2 id="export-posts">Export posts</h2><p>尝试了网上的很多脚本导出文章，要不就是过时了，要不就是我的环境有问题...都没能成功<br />最后发现了一个叫 Typecho-Plugin-Tp2MD 的插件。导出后 hexo g 全是报错...主要是 front 有问题。找猫画虎修改了一下便可以用了。hexo 可以看这个<a href="https://github.com/ricofx47/Typecho-Plugin-Tp2MD">版本</a>，<del>亲测可用（）</del></p><h2 id="番外">番外</h2><p>有几篇文章始终报错，提示 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">expected variable end<br></code></pre></td></tr></table></figure> 网上搜索了一下，才知道不能连用两个 {{  <img src="https://cdn.jsdelivr.net/gh/microlong666/tieba_mobile_emotions/image_emoticon27.png" />，解决方法可以看这个<a href="https://github.com/hexojs/hexo/issues/3224">issue</a></p><p>最后推荐一下我的这篇<a href="https://ricofx47.cc/2020/08/29/LOJ2958「COCI_2009.10」ALADIN/">文章</a>，希望你可以看看（（</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高考题面背后的故事</title>
    <link href="/2021/12/25/xgk2/"/>
    <url>/2021/12/25/xgk2/</url>
    
    <content type="html"><![CDATA[<p>做到过这样一道题 <span id="more"></span> <img src="/img/2021-12-25%7C21-32-07screenshot.png" /> 其实是2021年新高考Ⅱ卷数学 21题 好像高考考概率压轴题还是挺少见的，不过其实这更像导数题。 今天我要说的当然不是这道题的解法，而是第 <span class="math inline">\(2\)</span> 问中的已知条件的由来。</p><p>即<span class="math inline">\(p\)</span>为什么是方程<span class="math inline">\(p-0+p-1x+p-2x^2+p-3x^3=x\)</span>的根。 我们将该生物群体的每一个个体编号。首先如果以<span class="math inline">\(0\)</span>为祖先的群体灭绝，那么相当于所有<span class="math inline">\(0\)</span>的下一代为祖先的群体都灭绝。 <img src="/img/graph.png" /> 题设每一代繁殖独立且分布列相同。于是<span class="math inline">\(0\)</span>为祖先的群体灭绝的概率和每个孩子们(<span class="math inline">\(1\)</span>,<span class="math inline">\(2\)</span>,<span class="math inline">\(3\)</span>)为祖先的群体灭绝概率是相等的，因为后代无穷多，一代的差别可以忽略不计。 于是我们只用分类讨论<span class="math inline">\(0\)</span>的孩子个数，如以 <span class="math inline">\(3\)</span> 个孩子的情况为例：每一个后代所代表的子群体灭绝的概率都是<span class="math inline">\(P\)</span>，于是<span class="math inline">\(p=p-3*p^3\)</span>。 其他两种情况类似，于是结论是显然的。</p><p>本人学艺不精，语言难免不清晰，尽情谅解。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉格朗日插值入门</title>
    <link href="/2021/11/04/Lagrange/"/>
    <url>/2021/11/04/Lagrange/</url>
    
    <content type="html"><![CDATA[<p>其实是多年前写的一篇笔记了，做测试文章。</p><span id="more"></span><h2 id="拉格朗日插值">拉格朗日插值</h2><p>如果给一个度数为<span class="math inline">\(n\)</span>的多项式的<span class="math inline">\(n+1\)</span>个点<span class="math inline">\((x-i,y-i)\)</span>，那么我们可以用拉格朗日插值将求出这个多项式在所有点的取值。</p><p>假设<span class="math inline">\(x-i\)</span>互不相同，<span class="math inline">\(F(k)=\sum\limits-{i=0}^{deg} y-i \ell-i(k)\)</span></p><p>其中<span class="math inline">\(\ell-i\)</span>是拉格朗日基本多项式，<span class="math inline">\(\ell-i(k)=\prod\limits-{j=0,i\neq j}^{deg}\frac{k-x-j}{x-i-x-j}\)</span></p><p>这个<span class="math inline">\(\ell\)</span>有什么特点呢？<br />对于<span class="math inline">\(\forall j\neq i\)</span>，<span class="math inline">\(\ell-i(x-j)=0\)</span>，而<span class="math inline">\(\ell-i(x-i)=1\)</span>。<br />代值进去即可验证。</p><p>所以<span class="math inline">\(\forall x-i,F(x-i)=\sum\limits-{i=0}^{deg} y-i \ell-i(x-i)=y-i\)</span>，一共有<span class="math inline">\(deg+1\)</span>个点，所以能确定一个多项式。<br />时间复杂度<span class="math inline">\(\mathcal{O}(n^2)\)</span></p><h2 id="重心拉格朗日插值">重心拉格朗日插值</h2><p>每一次都算<span class="math inline">\(\ell\)</span>好像很慢。<br />令<span class="math inline">\(\ell(x)=(x-x-1)(x-x-2)...(x-x-n)\)</span><br /><span class="math inline">\(w-i=\frac{1}{\prod\limits-{j=0,i\neq j}^{deg}(x-i-x-j)}\)</span></p><p>则<span class="math inline">\(\ell-i(x)=\frac{\ell(x)}{x-x-i}w-i\)</span><br /><span class="math inline">\(F(x)=\sum\limits-{i=0}^{deg}y-i\ell-i(x)\)</span><br /><span class="math inline">\(F(x)=\ell(x)\sum\limits-{i=0}^{deg}y-i\frac{w-i}{x-x-i}\)</span></p><p><span class="math inline">\(w-i\)</span>称为<span class="math inline">\(i\)</span>的重心，每次加入新点时可以<span class="math inline">\(\mathcal{O} (n)\)</span>算新重心，计算<span class="math inline">\(F\)</span>也是<span class="math inline">\(\mathcal{O}(n)\)</span>的。</p><p><del>当然初始化重心是<span class="math inline">\(\mathcal{O}(n^2)\)</span></del></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/03/hello-world/"/>
    <url>/2021/11/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C、D题解解析</title>
    <link href="/2020/11/12/C%E3%80%81D%E9%A2%98%E8%A7%A3%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/11/12/C%E3%80%81D%E9%A2%98%E8%A7%A3%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>首先本人并不会做这两道题，以下只是对题解的理解</p></blockquote><span id="more"></span><h2 id="猪国杀">猪国杀</h2><h4 id="题目描述">题目描述</h4><p>《猪国杀》是一款热门的桌上游戏，该游戏以身份、势力或阵营等为线索，以卡牌为形式，合纵连横，经过一轮一轮的谋略和动作获得最终的胜利。《猪国杀》集合历史、文学、美术等元素于一身，在OI界广受欢迎。</p><p>在《猪国杀》游戏中，牌堆中牌的数量是无穷大的，并且每一张牌的点数都是在<span class="math inline">\([1,A]\)</span>内均匀随机的正整数。</p><p>游戏中有多种武将，每个武将有其独特的技能，其中一个技能描述如下：</p><blockquote><p><strong>称猪</strong>：每当你受到一次伤害后，你可以亮出牌堆顶的<span class="math inline">\(n\)</span>张牌。然后获得其中任意数量点数之和不大于<span class="math inline">\(m\)</span>的牌，将其余的牌置入弃牌堆。</p></blockquote><p>现在询问如果“称猪”时总是获得尽量多的牌，那么单次发动“称猪”期望能获得几张牌。</p><h4 id="输入格式">输入格式</h4><p>一行三个整数<span class="math inline">\(n,m,A\)</span>。</p><h4 id="输出格式">输出格式</h4><p>输出一行一个整数表示答案，<strong>对998244353取模。</strong></p><h4 id="样例一输入">样例一输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">12</span> <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h4 id="样例一输出">样例一输出</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">844808106</span><br></code></pre></td></tr></table></figure><h4 id="样例二输入">样例二输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">13</span> <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h4 id="样例二输出">样例二输出</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">76298711</span><br></code></pre></td></tr></table></figure><h4 id="样例三输入">样例三输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span><span class="hljs-number">47</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h4 id="样例三输出">样例三输出</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">127439024</span><br></code></pre></td></tr></table></figure><h4 id="数据范围与约定">数据范围与约定</h4><p>本题采用子任务捆绑测试。对于每个子任务，你只有通过了这个子任务的所有数据，才能获得这个子任务的分数。</p><p>对于所有的数据，满足<span class="math inline">\(1\leq n\leq 100\ \ 1\leq m,A\leq 1000\)</span>。</p><ul><li>子任务<span class="math inline">\(1\)</span>（$2<span class="math inline">\(0分）：\)</span>n,m,A$</li><li>子任务<span class="math inline">\(2\)</span>（<span class="math inline">\(20\)</span>分）：<span class="math inline">\(n,m,A\leq 50\)</span></li><li>子任务<span class="math inline">\(3\)</span>（<span class="math inline">\(20\)</span>分）：<span class="math inline">\(n\leq 5\)</span></li><li>子任务<span class="math inline">\(4\)</span>（<span class="math inline">\(20\)</span>分）：<span class="math inline">\(m,A\leq 5\)</span></li><li>子任务<span class="math inline">\(5\)</span>（<span class="math inline">\(20\)</span>分）：没有额外的限制</li></ul><h3 id="题解">题解</h3><p>最优策略肯定是取所有牌中点数最小的几张</p><p>考虑固定选了哪些牌，并求出有多少个方案使得选的牌中前几个恰好是这些，那么有</p><p><span class="math inline">\(ans \times A^n = \sum-{i=0}^{n}\sum-{j=1}^{A}\sum-{k=1}^{n-i}g-{i,j-1,m-j\times k}\times \binom{n}{i} \sum-{t \geq k}\binom{n-i}{t} \times (A-j)^{n-i-t}\)</span></p><p>其中<span class="math inline">\(g-{i,j,k}\)</span>表示有多少个长度为<span class="math inline">\(i\)</span>的正整数序列满足每一个数字不大于<span class="math inline">\(j\)</span>且所有数字总和不超过<span class="math inline">\(k\)</span></p><p>大概就是枚举选的牌中的最大值<span class="math inline">\(j\)</span>，最大值个数<span class="math inline">\(k\)</span>，以及选了<span class="math inline">\(i\)</span>个小于<span class="math inline">\(j\)</span>的牌。</p><p>可以用背包计算，也可以枚举有多少个数字大于<span class="math inline">\(j\)</span>容斥计算，那么有</p><p><span class="math inline">\(ans \times A^n = \sum-{i=0}^{n}\sum-{j=1}^{A}\sum-{k=1}^{n-i}\left(\sum-{t=0}^i (-1)^t\binom{i}{t}\binom{m-k\times j-t \times(j-1)}{i}\right)\times \binom{n}{i} \sum-{t \geq k}\binom{n-i}{t} \times (A-j)^{n-i-t}\)</span></p><p>组合数为<span class="math inline">\(0\)</span>的时候能直接跳过，那么直接按照上式计算大概是<span class="math inline">\(O(n^2m\log m)\)</span>的。</p><h3 id="个人理解">个人理解</h3><p>首先第一个方程不难理解，<span class="math inline">\(i+k\)</span>就是最后选的数。</p><blockquote><p>Q: 题目问的不是出牌数的期望吗，为什么算出方案后不<span class="math inline">\(\times (i+k)\)</span>？</p><p>A: 因为每个方案都会被算<span class="math inline">\(i+k\)</span>次，考虑<span class="math inline">\((3,3,3,5,5,8,6)\)</span>这样的序列，如果是最后选了前五个，你会发现选前四个的时也会分别枚举这个状态（注意状态不仅仅是序列有哪些数，还有最后选出的是哪些），也就是说每个状态会被选的数更少状态枚举到，恰好<span class="math inline">\(i+k\)</span>次</p></blockquote><p>解释下最后的容斥是什么意思。</p><p><span class="math display">\[g-{i,j,k}=\sum-{t=0}^i (-1)^t\binom{i}{t}\binom{k -t \times j}{i}\]</span></p><p>这东西并不是插板法，因为并不要求把<span class="math inline">\(k\)</span>选完。</p><p><img src="https://widsnoy.top/usr/uploads/2020/11/1790085055.png" /></p><p>只是往一个方向选，最后一边空出来。</p><p>这样就满足了和<span class="math inline">\(\leq k\)</span>的条件。</p><p>但是你发现不一定满足单个不大于<span class="math inline">\(j\)</span>的条件，所以把大于<span class="math inline">\(j\)</span>的拿出来减去，多减去的又加上......</p><h2 id="数树count">数树(count)</h2><h4 id="题目描述-1">题目描述</h4><p>给定两颗树<span class="math inline">\(T1,T2\)</span>，求<span class="math inline">\(T1\)</span>有多少个连通块与<span class="math inline">\(T2\)</span>同构。</p><p>树<span class="math inline">\(A\)</span>与树<span class="math inline">\(B\)</span>同构当且仅当存在一个<span class="math inline">\(A\)</span>的点集到<span class="math inline">\(B\)</span>的点集的双射<span class="math inline">\(f\)</span>，且存在一个<span class="math inline">\(A\)</span>的边集到<span class="math inline">\(B\)</span>的边集的双射<span class="math inline">\(g\)</span>将边<span class="math inline">\((x,y)\)</span>映射到边<span class="math inline">\((f(x),f(y))\)</span>。换一种说法，即存在一种将<span class="math inline">\(A\)</span>重标号的方案使得<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>完全相同。</p><h4 id="输入格式-1">输入格式</h4><p>第一行一个整数<span class="math inline">\(n\)</span>表示<span class="math inline">\(T1\)</span>的点数。</p><p>接下来<span class="math inline">\(n-1\)</span>行每行两个整数描述<span class="math inline">\(T1\)</span>中的一条边。</p><p>接下来一行一个整数<span class="math inline">\(m\)</span>表示<span class="math inline">\(T2\)</span>的点数。</p><p>之后<span class="math inline">\(m-1\)</span>行每行两个整数描述<span class="math inline">\(T2\)</span>中的一条边。</p><h4 id="输出格式-1">输出格式</h4><p>输出一行一个整数表示答案，<strong>对998244353取模。</strong></p><h4 id="样例一输入-1">样例一输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例一输出-1">样例一输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h4 id="样例二">样例二</h4><p>见下发文件中的<code>count/count2.in</code>和<code>count/count2.out</code></p><h4 id="数据范围与约定-1">数据范围与约定</h4><p>本题采用子任务捆绑测试。对于每个子任务，你只有通过了这个子任务的所有数据，才能获得这个子任务的分数。</p><p>对于所有的数据，满足<span class="math inline">\(n\leq 3000\ \ m\leq 10\)</span>。</p><ul><li>子任务<span class="math inline">\(1\)</span>（$2<span class="math inline">\(0分）：\)</span>n,m$</li><li>子任务<span class="math inline">\(2\)</span>（<span class="math inline">\(20\)</span>分）：<span class="math inline">\(n \leq 50\)</span></li><li>子任务<span class="math inline">\(3\)</span>（<span class="math inline">\(10\)</span>分）：<span class="math inline">\(T2\)</span>是一条链</li><li>子任务<span class="math inline">\(4\)</span>（<span class="math inline">\(10\)</span>分）：<span class="math inline">\(T2\)</span>中所有边都有一端是<span class="math inline">\(1\)</span>号点</li><li>子任务<span class="math inline">\(5\)</span>（<span class="math inline">\(40\)</span>分）：没有额外的限制</li></ul><h3 id="题解-1">题解</h3><p>可以考虑求出<span class="math inline">\(T1\)</span>的每个连通块有多少个双射<span class="math inline">\(f\)</span>是合法的之和，然后除去<span class="math inline">\(T2\)</span>的自同构方案数即可。</p><p>我们只要固定一个<span class="math inline">\(T1\)</span>的根即可，但是需要枚举<span class="math inline">\(T2\)</span>的根并每次进行dp。</p><p>令<span class="math inline">\(dp-{u,S}\)</span>表示<span class="math inline">\(u\)</span>的儿子已经向<span class="math inline">\(T2\)</span>的<span class="math inline">\(S\)</span>中的点建立双射的方案数，每次枚举当前儿子与哪个点建立双射进行转移。</p><p>然后将<span class="math inline">\(T1\)</span>每个点与<span class="math inline">\(T2\)</span>的根配对的方案数加起来。</p><p>时间复杂度<span class="math inline">\(O(nm^2 2^m)\)</span>。</p><h3 id="个人理解-1">个人理解</h3><p>首先题目要求算答案的不要求顺序，算<span class="math inline">\(T2\)</span>的自同构方案就相当于除掉顺序，如果你想一步到位还得判重就很麻烦...</p><p>其次，很难对某个联通块换根什么的，所以每次枚举<span class="math inline">\(2\)</span>的根是等效的。</p><p>转移的时候判断孩子<span class="math inline">\(v\)</span>能不能双射到<span class="math inline">\(T2\)</span>某个点<span class="math inline">\(p\)</span>上，其实取决于<span class="math inline">\(v\)</span>的孩子能不能双射到<span class="math inline">\(p\)</span>的孩子上。</p><p>根据<span class="math inline">\(dp\)</span>数组的定义，<span class="math inline">\(v\)</span>的子树双射的方案数也就是它孩子们的双射方案数。</p><p><span class="math inline">\(std\)</span>的代码很牛逼，忍不住抄了一份。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//copy and paste from std</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3005</span>, MOD = <span class="hljs-number">998244353</span>, M = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> dp[N][M], son[<span class="hljs-number">12</span>], S, lg[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % MOD;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span> &#123;</span><br><span class="hljs-keyword">int</span> n;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>e[u].push-<span class="hljs-built_in">back</span>(v);<br>e[v].push-<span class="hljs-built_in">back</span>(u);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>        son[u] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">init</span>(v, u);<br>            son[u] |= <span class="hljs-number">1</span> &lt;&lt; (v - <span class="hljs-number">1</span>);<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>dp[u][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = S; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-keyword">if</span> (dp[u][i]) &#123;<br>        <span class="hljs-keyword">int</span> t = dp[u][i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> tt = S ^ i; tt; tt -= (tt &amp; -tt)) &#123;<br>        <span class="hljs-keyword">int</span> p = lg[tt &amp; -tt];<br>        <span class="hljs-keyword">if</span> (dp[v][son[p + <span class="hljs-number">1</span>]]) dp[u][i | (<span class="hljs-number">1</span> &lt;&lt; p)] = (dp[u][i | (<span class="hljs-number">1</span> &lt;&lt; p)] + t * <span class="hljs-number">1ll</span> * dp[v][son[p + <span class="hljs-number">1</span>]]) % MOD;<br>        &#125;<br>        &#125;<br>        &#125;<br>&#125;<br>&#125; T1, T2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;count.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;count.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-keyword">int</span> ans1 = <span class="hljs-number">0</span>, ans2 = <span class="hljs-number">0</span>;<br>T1.<span class="hljs-built_in">input</span>();<br>T2.<span class="hljs-built_in">input</span>();<br>S = (<span class="hljs-number">1</span> &lt;&lt; T2.n) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T2.n; i++) lg[<span class="hljs-number">1</span> &lt;&lt; i] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T2.n; i++) &#123;<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>T2.<span class="hljs-built_in">init</span>(i, <span class="hljs-number">0</span>);<br>T1.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= T1.n; j++) ans1 = (ans1 + dp[j][son[i]]) % MOD;<br>&#125;<br>    T1 = T2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T2.n; i++) &#123;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    T2.<span class="hljs-built_in">init</span>(i, <span class="hljs-number">0</span>);<br>    T1.<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    ans2 = (ans2 + dp[<span class="hljs-number">1</span>][son[i]]) % MOD;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans1 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(ans2, MOD - <span class="hljs-number">2</span>) % MOD);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
      <tag>动态规划</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP2017」列队 数据结构</title>
    <link href="/2020/11/11/%E3%80%8CNOIP2017%E3%80%8D%E5%88%97%E9%98%9F_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/11/11/%E3%80%8CNOIP2017%E3%80%8D%E5%88%97%E9%98%9F_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2319">「NOIP2017」列队</a></p></blockquote><p>这题做法比较多，感觉平衡树的写法应该比较简单。</p><p>虽然常数会比较大。</p><p>我们分别维护每一行和最后一列的元素。</p><p>对于每次操作的二元组<span class="math inline">\((x,y)\)</span></p><ol type="1"><li><p>如果<span class="math inline">\(y=m\)</span>，就把元素移到列末尾。</p></li><li><p>否则，行内删除该元素，把最后一列第<span class="math inline">\(x\)</span>个元素移到行末尾并删除，之后把<span class="math inline">\((x,y)\)</span>移动到列末尾。</p></li></ol><p>查询很简单，查一下第<span class="math inline">\(k\)</span>大的编号就是了。</p><p>但是有一个问题，这样开的点会非常多，空间根本开不下。</p><p>所以要向<a href="https://loj.ac/problem/2212">方伯伯的OJ</a>那题那样，把连续的编号压缩一下，用到的时候再拆开。</p><p>和珂朵莉树思想应该是一样的。</p><p>具体实现的时候，因为会涉及拆开一个点的操作，所以把那个要用的点单独拿出来比较好。</p><p>所以分裂的时候按子树大小分裂(相当于按排名)分成三部分<span class="math inline">\(a,b,c\)</span>，其中<span class="math inline">\(b\)</span>恰好是第<span class="math inline">\(k\)</span>名。</p><p>具体实现看代码吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, Q, root[N], tot;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> v, cnt, siz, lc, rc, rnd;<br>&#125; t[N * <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!cnt) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    t[++tot].rnd = <span class="hljs-built_in">rand</span>();<br>    t[tot].v = v;<br>    t[tot].cnt = cnt;<br>    t[tot].siz = cnt;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>t[p].siz = t[t[p].lc].siz + t[t[p].rc].siz + t[p].cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y, <span class="hljs-keyword">int</span> &amp;z, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!p) &#123;<br>x = y = z = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (k &lt;= t[t[p].lc].siz) &#123;<br>z = p;<br><span class="hljs-built_in">split</span>(t[p].lc, x, y, t[p].lc, k);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>k -= t[t[p].lc].siz;<br><span class="hljs-keyword">if</span> (k &lt;= t[p].cnt) &#123;<br>y = p;<br>x = t[p].lc;<br>z = t[p].rc;<br>t[p].lc = t[p].rc = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>x = p;<br>k -= t[p].cnt;<br><span class="hljs-built_in">split</span>(t[p].rc, t[p].rc, y, z, k);<br>&#125;<br>&#125;<br><span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> x + y;<br>    <span class="hljs-keyword">if</span> (t[y].rnd &gt; t[x].rnd) &#123;<br>        t[x].rc = <span class="hljs-built_in">merge</span>(t[x].rc, y);<br>        <span class="hljs-built_in">pushup</span>(x);<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    t[y].lc = <span class="hljs-built_in">merge</span>(x, t[y].lc);<br>    <span class="hljs-built_in">pushup</span>(y);<br>    <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>(<span class="hljs-number">1919810</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;Q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    root[i] = <span class="hljs-built_in">newnode</span>((i - <span class="hljs-number">1</span>) * m + <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>    root[<span class="hljs-number">0</span>] = <span class="hljs-built_in">merge</span>(root[<span class="hljs-number">0</span>], <span class="hljs-built_in">newnode</span>(m * i, <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">while</span> (Q--) &#123;<br>    <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y);<br>    <span class="hljs-keyword">if</span> (y == m) &#123;<br>            <span class="hljs-keyword">int</span> a, b, c;<br>            <span class="hljs-built_in">split</span>(root[<span class="hljs-number">0</span>], a, b, c, x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, t[b].v);<br>            root[<span class="hljs-number">0</span>] = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(a, c), b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">int</span> a, b, c;<br>    <span class="hljs-built_in">split</span>(root[<span class="hljs-number">0</span>], a, b, c, x);<br>    root[x] = <span class="hljs-built_in">merge</span>(root[x], b);<br>    root[<span class="hljs-number">0</span>] = <span class="hljs-built_in">merge</span>(a, c);<br>    <span class="hljs-built_in">split</span>(root[x], a, b, c, y);<br>    y -= t[a].siz;<br>    root[<span class="hljs-number">0</span>] = <span class="hljs-built_in">merge</span>(root[<span class="hljs-number">0</span>], <span class="hljs-built_in">newnode</span>(t[b].v + y - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, t[b].v + y - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> l = y - <span class="hljs-number">1</span>, r = t[b].cnt - y;<br>            b = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">newnode</span>(t[b].v, l), <span class="hljs-built_in">newnode</span>(t[b].v + y, r));<br>            root[x] = <span class="hljs-built_in">merge</span>(a, <span class="hljs-built_in">merge</span>(b, c));<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>树状数组</tag>
      
      <tag>数据结构</tag>
      
      <tag>平衡树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选数 容斥原理</title>
    <link href="/2020/11/11/%E9%80%89%E6%95%B0_%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <url>/2020/11/11/%E9%80%89%E6%95%B0_%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>桌面上有<span class="math inline">\(N\)</span>个数字排成一排，小武要求小林从中选出<span class="math inline">\(3\)</span>个数字，使得这<span class="math inline">\(3\)</span>个数字的按位或的结果恰好等于<span class="math inline">\(x\)</span>，小林很快 就解决了这个问题，小武想了想，决定把问题加强一下，小武会问小林<span class="math inline">\(Q\)</span>次问题，每次选的<span class="math inline">\(3\)</span>个数字只能在从左往右 的第<span class="math inline">\(l\)</span>个数和第<span class="math inline">\(r\)</span>个数之间选择，并且要小林说出符合要求的方案数，小林顿时不会了，于是把问题交给了你。 第一行两个数<span class="math inline">\(N\)</span>和<span class="math inline">\(Q\)</span>, 第二行<span class="math inline">\(N\)</span>个数，按照从左到右的顺序给出桌面上的数字 接下来<span class="math inline">\(Q\)</span>行，每行<span class="math inline">\(3\)</span>个数字，分别为<span class="math inline">\(l,r,x\ Q\)</span>行，每行一个数表示方案数。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，$1lrn<sup>5,1Q</sup>5,1桌面上每个数字,x $</p><h2 id="分析">分析</h2><p>首先，如果<span class="math inline">\(x\)</span>某位等于<span class="math inline">\(0\)</span>。那么选出的数该为只能等于<span class="math inline">\(0\)</span>。</p><p>排除这种情况，选出的数一定是<span class="math inline">\(x\)</span>的子集，即<span class="math inline">\(i\and x=i\)</span></p><p>而没有顺序的选出三个数方案是<span class="math inline">\(\binom{n}{3}\)</span></p><p>选出的三个数一定属于某个集合，我们直接枚举这个集合<span class="math inline">\(S\)</span>，<span class="math inline">\(S\)</span>一定是<span class="math inline">\(x\)</span>的子集，不然没有意义。如果<span class="math inline">\(S\)</span>和<span class="math inline">\(x\)</span>一的个数不同，一定是<span class="math inline">\(S\)</span>为<span class="math inline">\(0\)</span>，<span class="math inline">\(x\)</span>是<span class="math inline">\(1\)</span>。所以要把<span class="math inline">\(S\)</span>的所有选择方案减去。但是某个三元组可能被反复减，如果<span class="math inline">\(1\)</span>的个数差偶数个时又要加上去。</p><p>为什么这样是对的？</p><p>假如当前有一个三元组或起来等于<span class="math inline">\(10001101\)</span>，而<span class="math inline">\(x=10111111\)</span></p><p>我们考虑这个三元组的贡献，也就是在哪些集合会枚举到它。</p><p>显然可以自由放<span class="math inline">\(1\)</span>的位置有<span class="math inline">\(3\)</span>个。</p><p>则贡献是<span class="math inline">\(\binom{3}{0}-\binom{3}{1}+\binom{3}{2}-\binom{3}{3}\)</span></p><p>一般的说<span class="math inline">\(\sum\limits-{i=0}^{n}(-1)^{i+1}\binom{n}{i}=-1\times \sum\limits-{i=0}^{n}(-1)^{i}\binom{n}{i}=0\)</span></p><p>如果有偶数个自由放的位置也是同理，所以说如果三个数或起来不等于<span class="math inline">\(x\)</span>，则贡献是<span class="math inline">\(0\)</span>。</p><p>如果恰好等于<span class="math inline">\(x\)</span>的，只会在<span class="math inline">\(S=x\)</span>时被算一次。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">256</span>;<br><span class="hljs-keyword">int</span> pop[N + <span class="hljs-number">2</span>], sum[<span class="hljs-number">100005</span>][N + <span class="hljs-number">2</span>], n, Q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;select.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;select.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) pop[i] = pop[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;Q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; j++) sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + ((x &amp; j) == x);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (Q--) &#123;<br>        <span class="hljs-keyword">int</span> l, r, x;<br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((x &amp; i) != i) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> now = pop[x] - pop[i];<br>        ll ans;<br>        <span class="hljs-keyword">if</span> (now &amp; <span class="hljs-number">1</span>) ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> ans = <span class="hljs-number">1</span>;<br>        ans *= (sum[r][i] - sum[l - <span class="hljs-number">1</span>][i]) * <span class="hljs-number">1ll</span> * (sum[r][i] - sum[l - <span class="hljs-number">1</span>][i] - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (sum[r][i] - sum[l - <span class="hljs-number">1</span>][i] - <span class="hljs-number">2</span>) / <span class="hljs-number">6ll</span>;<br>        res += ans;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP2017」宝藏</title>
    <link href="/2020/11/11/%E3%80%8CNOIP2017%E3%80%8D%E5%AE%9D%E8%97%8F/"/>
    <url>/2020/11/11/%E3%80%8CNOIP2017%E3%80%8D%E5%AE%9D%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2318">「NOIP2017」宝藏</a></p></blockquote><p>不知道为什么，最开始<span class="math inline">\(70\)</span>的暴力都没有想到。</p><p>因为当前在某个最新开发的点，不会再往以前已经开发的点连边。</p><p>所以开发顺序是一个排列，所以直接全排列枚举开发顺序。</p><p>每个新开发的点，都枚举是从哪个已开发的点过来的，这样做应该是<span class="math inline">\(\mathcal{O}(n^3n!)\)</span>的，可以拿<span class="math inline">\(70\)</span>分。</p><p>然后这题有一个根据定义的状压<span class="math inline">\(dp\)</span>，可以把开发顺序看成一棵<span class="math inline">\(bfs\)</span>树，是一层一层开发的。</p><p>设<span class="math inline">\(f[i][s1][s2]\)</span>表示已经开了前<span class="math inline">\(i\)</span>层，开发的点集是<span class="math inline">\(s1\)</span>，最后一层是<span class="math inline">\(s2\)</span>，枚举<span class="math inline">\(s1\)</span>补集的子集接上即可。</p><p>不知道为什么我写了这个<span class="math inline">\(\mathcal{O}(n^24^n)\)</span>的<span class="math inline">\(dp\)</span>没过样例。</p><p>可以优化下状态，可以发现不用管第三维，因为最优状态总会被考虑到，只用记录<span class="math inline">\(g[i][j]\)</span>表示两个集合连边的最小边权和。</p><p>转移的时候<span class="math inline">\(g[i][j]=g[i][j\and -j]+v\)</span></p><p>而<span class="math inline">\(f[i][s1]\)</span>表示已经开了前<span class="math inline">\(i\)</span>层，开发的点集是<span class="math inline">\(s1\)</span>，枚举一下<span class="math inline">\(s1\)</span>的子集作为最后一层即可转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">12</span>;<br><span class="hljs-keyword">int</span> f[M][M], g[N][M], n, m, nxt[M], w[N][N], lg[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> w);<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) lg[<span class="hljs-number">1</span> &lt;&lt; i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;val);<br>    u--, v--;<br>    <span class="hljs-keyword">if</span> (val &lt; w[u][v]) w[u][v] = w[v][u] = val;<br>    &#125;<br>    <span class="hljs-keyword">int</span> S = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= S; i++) &#123;<br>    <span class="hljs-keyword">int</span> bu = S ^ i, v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = bu; j; j = (j - <span class="hljs-number">1</span>) &amp; bu) nxt[j] = v, v = j;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v; j; j = nxt[j]) &#123;<br>    v = <span class="hljs-number">1e6</span>;<br>            <span class="hljs-keyword">int</span> x = lg[j &amp; -j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) <span class="hljs-keyword">if</span> (i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) v = <span class="hljs-built_in">min</span>(v, w[k][x]);<br>            f[i][j] = f[i][j ^ (j &amp; -j)] + v;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[<span class="hljs-number">0</span>][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt; n; l++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= S; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j; j = (j - <span class="hljs-number">1</span>) &amp; i) &#123;<br>    g[l][i] = <span class="hljs-built_in">min</span>(g[l][i], g[l - <span class="hljs-number">1</span>][i ^ j] + l * f[i ^ j][j]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) res = <span class="hljs-built_in">min</span>(res, g[i][S]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>状压dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YJYX Ak king !</title>
    <link href="/2020/11/10/YJYX_Ak_king_!/"/>
    <url>/2020/11/10/YJYX_Ak_king_!/</url>
    
    <content type="html"><![CDATA[<p>由于<a href="https://denerate.ink/">我的博客</a>被太多人膜拜变得极不稳定，因此写在这个菜鸡的博客上</p><span id="more"></span><h3 id="day-37">DAY-37</h3><p>橘子熟了。</p><h3 id="day-21">DAY-21</h3><p>在学长的目击下用了一天IOI的时间做了两年IOI的题，感觉比较稳，后面在群里面发了一遍题面，一群人直呼教练（他们居然觉得教练会管他们？），教练让我收敛点，于是我撤回了题面。</p><h3 id="day-17">DAY-17</h3><p>做完了IOI的题，开始刷CF,感觉良好，开始yy自己的做法碾标算</p><h3 id="day-15">DAY-15</h3><p>模拟赛要求自己稳定挂分200分，刚开始两次还在前面，于是忍辱负重要求稳定挂250分，但是数据太水了，还有一次阿卡了</p><h3 id="day-11">DAY-11</h3><p>教练让我展示一下水平，于是给我找了套题，好家伙，T1直接NOIP原题，T2直接sb题，后面懒得开了，30分钟交卷，据学长说他们历史最高只有150，感觉还是有点太狂妄了</p><h3 id="day-6">DAY-6</h3><p>绕教学楼散步10圈，被校警询问身份，据说全机房都在找我。</p><h3 id="day-3">DAY-3</h3><p>准备出发，还没上IGM,感觉有点慌，希望出题人没有我强</p><h3 id="day-1">DAY-1</h3><p>懒得去看考场，吃了很多砂糖橘，感觉有点辣，研读了一下考场规则，好像可以带甘蔗，买了两根但是太贪吃没了。</p><h3 id="day0">DAY0</h3><p>上午打了三套NOIP模拟，感觉这次阿克很稳，学军开小号去打，他们还说我爆零了，但凡他们愿意把我交的代码平移一个题目，排行榜都要变。</p><p>中午看他们装西洋人和印度人，我吃了三盘橘子（昨晚买多了），总算还剩到10斤，带入考场应该问题不大。</p><p>下午提着两袋橘子去考试，老师一直在看我，但看了我考号没说什么</p><p>T1 随便做了做，考虑了一下日期，直接推了通项公式，但是超过了 10^{73}1073 天后要炸精度，想了想出题人应该没想到这种做法，测了下1到 10^{9}109 天，问题不大</p><p>T2 这是什么题啊</p><p>T3 直接一个左偏树维护矩阵森林，发现他们都是倒着做，我大样例跑了 0.01s ,他们也差不多，但是我出考场想到矩阵的复杂度好像算错了，感觉没打过 O()<em>O</em>(<em>n</em>) 的矩阵乘法，但是证了下觉得没啥问题。</p><p>T4这是什么题啊，“足够聪明”明显ub了啊，到底是怎么定义的啊，我感觉我在哪边都可以赢啊，我要求出题人解释大样例，监考老师白了我一眼，不过半个小时后我终于会解释大样例了，然后打了过了大样例感觉很稳</p><h3 id="day-1-1">DAY 1</h3><p>想写游记，但是个人博客被膜爆了。</p><blockquote><p><span class="math inline">\({\color{red} {文章复制粘贴自}}\)</span>https://www.luogu.com.cn/blog/mzyc/si-chuan-tai-wang-e-ka-ji</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「HAOI2016」放棋子</title>
    <link href="/2020/11/10/%E3%80%8CHAOI2016%E3%80%8D%E6%94%BE%E6%A3%8B%E5%AD%90/"/>
    <url>/2020/11/10/%E3%80%8CHAOI2016%E3%80%8D%E6%94%BE%E6%A3%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2061">「HAOI2016」放棋子</a></p></blockquote><p>这题，一看就很状压<span class="math inline">\(dp\)</span> <span id="more"></span> 但是<span class="math inline">\(N\leq 200\)</span>，拿啥压啊...</p><p>不会做啊，忍不住去搜题解了。</p><p>题目有个很好的性质</p><blockquote><p>任意两个障碍不在同一行，任意两个障碍不在同一列......你放<span class="math inline">\(N\)</span>个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制</p></blockquote><p>首先，既然每行每列都只有一个障碍，那么显然障碍放哪里对棋子方案数没有影响。</p><p>你想在某行换一个障碍位置，那么必定会把另一个障碍换到这一列。这就相当于换了某两行。</p><p>因为棋子也满足这个限制，所以换两行是没有影响的。</p><p>所以我们直接钦定第<span class="math inline">\(i\)</span>行的障碍物就在第<span class="math inline">\(i\)</span>列，因为要放<span class="math inline">\(N\)</span>个棋子，每一行都要放一个，给放在<span class="math inline">\(i\)</span>行的棋子编号为<span class="math inline">\(i\)</span>。</p><p>所以编号为<span class="math inline">\(i\)</span>的棋子不能放在第<span class="math inline">\(i\)</span>列。</p><p>而每一列都有一个棋子，把每列的棋子依次拿出来，编号就对应了一个排列。</p><p>根据前面所述，这个排列被称为错排。</p><p>即第<span class="math inline">\(i\)</span>个元素不在第<span class="math inline">\(i\)</span>位的排列数。</p><p>令<span class="math inline">\(f[i]\)</span>表示<span class="math inline">\(i\)</span>个元素的错排方法，那么<span class="math inline">\(f[i]=(i-1)\times (f[i-1]+f[i-2])\)</span></p><p>而<span class="math inline">\(f[0]=1,f[1]=0\)</span></p><p>什么意思呢？</p><p>先假设现在有<span class="math inline">\(n\)</span>个元素，第<span class="math inline">\(n\)</span>个元素选择第<span class="math inline">\(k\)</span>个位置放置，有<span class="math inline">\(n-1\)</span>种方法。</p><p>讨论<span class="math inline">\(k\)</span>的放法</p><ol type="1"><li><span class="math inline">\(k\)</span>放在第<span class="math inline">\(n\)</span>位，即对其他元素没有影响，<span class="math inline">\(n-2\)</span>个元素错排即可</li><li><span class="math inline">\(k\)</span>不放在第<span class="math inline">\(n\)</span>位，相当于<span class="math inline">\(k\)</span>就是<span class="math inline">\(n\)</span>，相当于<span class="math inline">\(n-1\)</span>个元素错排</li></ol><p>所以说，写一个高精乘法和高精加法即可。</p><p>由于博主比较垃圾，不会高精乘低精，所以把低精转成了高精来算的......</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">205</span>;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> power = <span class="hljs-number">4</span>, base = <span class="hljs-number">10000</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">num</span> &#123;</span><br>    <span class="hljs-keyword">int</span> len, a[<span class="hljs-number">520</span>];<br>    <span class="hljs-built_in">num</span>() &#123;<br>    len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[len]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0*d&quot;</span>, power, a[i]);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125; f[N];<br>num <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> num &amp;p, <span class="hljs-keyword">const</span> num &amp;q) &#123;<br>num c;<br>c.len = <span class="hljs-built_in">max</span>(p.len, q.len);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= c.len; i++) &#123;<br>c.a[i] += p.a[i] + q.a[i];<br>c.a[i + <span class="hljs-number">1</span>] += c.a[i] / base;<br>c.a[i] %= base;<br>&#125;<br><span class="hljs-keyword">while</span> (c.a[c.len + <span class="hljs-number">1</span>]) c.len++;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function">num <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    num t;<br>    t.a[<span class="hljs-number">1</span>] = x;<br>    t.len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br>num <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> num &amp;p, <span class="hljs-keyword">const</span> num &amp;q) &#123;<br>num c;<br>c.len = p.len + q.len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p.len; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= q.len; j++) &#123;<br>    c.a[i + j - <span class="hljs-number">1</span>] += p.a[i] * q.a[j];<br>    c.a[i + j] += c.a[i + j - <span class="hljs-number">1</span>] / base;<br>    c.a[i + j - <span class="hljs-number">1</span>] %= base;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (c.a[c.len + <span class="hljs-number">1</span>]) c.len++;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    f[<span class="hljs-number">0</span>].a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">0</span>].len = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>].len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) f[i] = <span class="hljs-built_in">rev</span>(i - <span class="hljs-number">1</span>) * (f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>]);<br>    f[n].<span class="hljs-built_in">write</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
      <tag>错排</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 6274  数字</title>
    <link href="/2020/11/10/LOJ_6274__%E6%95%B0%E5%AD%97/"/>
    <url>/2020/11/10/LOJ_6274__%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>首先，把所有数二进制拆分一下，然后数位<span class="math inline">\(dp\)</span>爆搜当前位分别填什么，然后这题就做完了。</p><span id="more"></span><p>做完个锤子。</p><p>如果填<span class="math inline">\(0/1\)</span>，<span class="math inline">\(1/0\)</span>，<span class="math inline">\(0/0\)</span>，最后并起来都是一个数，但是<span class="math inline">\(x,y\)</span>却不相同了。</p><p>据可靠消息，发现这三种填法的方案数是包含关系，也就是说你在这一位填什么，最后都不会让某个方案不同于其中一个能最大化答案的那个方案。</p><p>因为当前填什么对后面的影响就是会不会碰到上下界，调整一下可以证。</p><p>具体可以看看其他大佬的博客。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">99</span>;<br>ll f[N][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> t[N], a[N], b[N], c[N], d[N], mx;<br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>    w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>    ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, ll x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x) a[++cnt] = x % <span class="hljs-number">2</span>, x /= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (cnt &gt; mx) mx = cnt;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">bool</span> lx, <span class="hljs-keyword">bool</span> rx, <span class="hljs-keyword">bool</span> ly, <span class="hljs-keyword">bool</span> ry)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (f[x][lx][rx][ly][ry] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][lx][rx][ly][ry];<br>    ll &amp;res = f[x][lx][rx][ly][ry], ans;<br>    res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    <span class="hljs-keyword">int</span> nx = dx[i], ny = dy[i];<br>    <span class="hljs-keyword">if</span> ((nx | ny) != t[x]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (lx &amp;&amp; nx &lt; a[x]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (rx &amp;&amp; nx &gt; b[x]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (ly &amp;&amp; ny &lt; c[x]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (ry &amp;&amp; ny &gt; d[x]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (nx &amp; ny) res += <span class="hljs-built_in">dfs</span>(x - <span class="hljs-number">1</span>, lx &amp;&amp; a[x] == nx, rx &amp;&amp; b[x] == nx, ly &amp;&amp; c[x] == ny, ry &amp;&amp; d[x] == ny);<br>    <span class="hljs-keyword">else</span> res = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(x - <span class="hljs-number">1</span>, lx &amp;&amp; a[x] == nx, rx &amp;&amp; b[x] == nx, ly &amp;&amp; c[x] == ny, ry &amp;&amp; d[x] == ny));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">work</span>(t, <span class="hljs-built_in">read</span>());<br>    <span class="hljs-built_in">work</span>(a, <span class="hljs-built_in">read</span>());<br>    <span class="hljs-built_in">work</span>(b, <span class="hljs-built_in">read</span>());<br>    <span class="hljs-built_in">work</span>(c, <span class="hljs-built_in">read</span>());<br>    <span class="hljs-built_in">work</span>(d, <span class="hljs-built_in">read</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dfs</span>(mx, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数位dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「NOIP2017」 逛公园</title>
    <link href="/2020/11/10/%E3%80%8CNOIP2017%E3%80%8D_%E9%80%9B%E5%85%AC%E5%9B%AD/"/>
    <url>/2020/11/10/%E3%80%8CNOIP2017%E3%80%8D_%E9%80%9B%E5%85%AC%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2316">「NOIP2017」 逛公园</a></p></blockquote><h2 id="题目">题目</h2><p>策策同学特别喜欢逛公园。公园可以看成一张<span class="math inline">\(N\)</span>个点<span class="math inline">\(M\)</span>条边构成的有向图，且没有自环和重边。其中1号点是公园的入口，<span class="math inline">\(N\)</span>号点是公园的出口，每条边有一个非负权值，代表策策经过这条边所要花的时间。 策策每天都会去逛公园，他总是从1号点进去，从<span class="math inline">\(N\)</span>号点出来。</p><p>策策喜欢新鲜的事物，他不希望有两天逛公园的路线完全一样，同时策策还是一个特别热爱学习的好孩子，他不希望每天在逛公园这件事上花费太多的时间。如果1号点到<span class="math inline">\(N\)</span>号点的最短路长为<span class="math inline">\(d\)</span>，那么策策只会喜欢长度不超过<span class="math inline">\(d+k\)</span>的路线。策策同学想知道总共有多少条满足条件的路线，你能帮帮他吗？为避免输出过大，答案对<span class="math inline">\(P\)</span>取模。如果有无穷多条合法的路线，请输出-1。</p><h2 id="分析">分析</h2><p>首先需要最短路处理出<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>作为起点到每个点的最短路。</p><p>有无数解的情况是有零环并且走零环能满足长度不大于<span class="math inline">\(d+k\)</span>的条件。</p><p><span class="math inline">\(k\)</span>的范围应该很<span class="math inline">\(dp\)</span>，就是<span class="math inline">\(f[i][k]\)</span>表示走到<span class="math inline">\(i\)</span>点，相对最短路多走了<span class="math inline">\(k\)</span>的方案数。</p><p>而零环和最短路图上的边转移时成环的，需要按照拓扑序来转移。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100004</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><span class="hljs-keyword">int</span> nxt, v, w;&#125; e1[N &lt;&lt; <span class="hljs-number">1</span>], e2[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> n, m, head1[N], dis1[N], head2[N], dis2[N], ecnt1, ecnt2, k, MOD, qp[N], tot, d[N], f[<span class="hljs-number">55</span>][N];<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">bool</span> book[N];<br><br><span class="hljs-keyword">void</span> add-<span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w) &#123;<br>    e1[++ecnt1] = &#123;head1[u], v, w&#125;; head1[u] = ecnt1;<br>    e2[++ecnt2] = &#123;head2[v], u, w&#125;; head2[v] = ecnt2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    x = x + y;<br>    <span class="hljs-keyword">if</span> (x &gt;= MOD) x -= MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    ecnt1 = ecnt2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dis1, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis1);<br>    <span class="hljs-built_in">memset</span>(dis2, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis2);<br>    <span class="hljs-built_in">memset</span>(head1, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head1);<br>    <span class="hljs-built_in">memset</span>(head2, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head2);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;MOD);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>        add-<span class="hljs-built_in">edge</span>(u, v, w);<br>    &#125;<br>    <span class="hljs-comment">// dij</span><br>    priority-queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; q;<br>    dis1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(book, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> book);<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">top</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (book[u]) <span class="hljs-keyword">continue</span>;<br>        book[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head1[u]; i; i = e1[i].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e1[i].v, w = e1[i].w;<br>            <span class="hljs-keyword">if</span> (dis1[u] + w &lt; dis1[v]) &#123;<br>                dis1[v] = dis1[u] + w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-dis1[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    dis2[n] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(book, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> book);<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, n&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">top</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (book[u]) <span class="hljs-keyword">continue</span>;<br>        book[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head2[u]; i; i = e2[i].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e2[i].v, w = e2[i].w;<br>            <span class="hljs-keyword">if</span> (dis2[u] + w &lt; dis2[v]) &#123;<br>                dis2[v] = dis2[u] + w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-dis2[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> d);<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = head1[i]; j; j = e1[j].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e1[j].v, w = e1[j].w;<br>            <span class="hljs-keyword">if</span> (dis1[i] + w == dis1[v]) d[v]++;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>) qp[++tot] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = qp[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = head1[u]; j; j = e1[j].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e1[j].v, w = e1[j].w;<br>            <span class="hljs-keyword">if</span> (dis1[v] == dis1[u] + w) &#123;<br>                d[v]--;<br>                <span class="hljs-keyword">if</span> (d[v] == <span class="hljs-number">0</span>) qp[++tot] = v;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (d[i] &amp;&amp; dis1[i] + dis2[i] &lt;= dis1[n] + k) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;= k; l++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) &#123;<br>            <span class="hljs-keyword">int</span> u = qp[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = head1[u]; j; j = e1[j].nxt) &#123;<br>                <span class="hljs-keyword">int</span> v = e1[j].v, w = e1[j].w;<br>                <span class="hljs-keyword">if</span> (dis1[v] == dis1[u] + w) <span class="hljs-built_in">upd</span>(f[l][v], f[l][u]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = head1[u]; j; j = e1[j].nxt) &#123;<br>                <span class="hljs-keyword">int</span> v = e1[j].v, w = e1[j].w;<br>                <span class="hljs-keyword">if</span> (dis1[v] != dis1[u] + w &amp;&amp; l + dis1[u] + w - dis1[v] &lt;= k) &#123;<br>                    <span class="hljs-built_in">upd</span>(f[l + dis1[u] + w - dis1[v]][v], f[l][u]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) <span class="hljs-built_in">upd</span>(res, f[i][n]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> -;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;-); -; ---) <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>最短路</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2015 运输计划</title>
    <link href="/2020/11/09/NOIP2015_%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92/"/>
    <url>/2020/11/09/NOIP2015_%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>退役选手114514分钟没写博客了</p></blockquote><h2 id="题目">题目</h2><p>L 国有 <span class="math inline">\(n\)</span> 个星球，有 <span class="math inline">\(n-1\)</span> 条双向航道连通了 L 国的所有星球，每条航道连通两个星球，第 <span class="math inline">\(i\)</span> 条航道通过的时间为 <span class="math inline">\(t-i\)</span>。</p><p>小 P 掌管的物流公司有 <span class="math inline">\(m\)</span> 个运输计划，每个运输计划形如：有一艘物流飞船需要从 <span class="math inline">\(u-i\)</span> 号星球沿最快的路径到 <span class="math inline">\(v-i\)</span> 号星球去。注意：任意两艘飞船之间不会产生任何干扰。</p><p>在运输计划开始前，小 P 可以自由选择一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞建设完成后，这 <span class="math inline">\(m\)</span> 个运输计划会同时开始，所有飞船一起出发。当这 <span class="math inline">\(m\)</span> 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。求出小 P 的物流公司完成阶段性工作所需要的最短时间。</p><p>数据范围：<span class="math inline">\(n,m\le 3\times 10^5\)</span>，<span class="math inline">\(0\le t-i\le 1000\)</span></p><h2 id="分析">分析</h2><p>一开始没注意到是一棵树，感觉很不可做。</p><p>看了下别人题解，才发现这个性质。</p><p>所以可以先预处理出每个任务的长度。</p><p>之后二分答案，把所有长度<span class="math inline">\(\geq mid\)</span>的计划数量（记为<span class="math inline">\(cnt\)</span>）以及该计划经过的边记录一下。</p><p>怎么判断是否可以把某条边变成虫洞以满足要求呢？</p><p>这个比较简单，如果某条边被每个大于<span class="math inline">\(mid\)</span>的计划经过，并且删除这个边后，满足<span class="math inline">\(max\-len-w\leq mid\)</span>，即符合条件。</p><p>对于打标记，容易想到树剖。</p><p>但是我看了Siyuan大佬博客后，学到了一个比较妙的差分方法。</p><p>树上差分后可以按<span class="math inline">\(dfn\)</span>序算前缀和，这样保证每个点的子树都已经更新到了它上面。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300005</span>, M = <span class="hljs-number">22</span>;<br><span class="hljs-keyword">int</span> head[N], ecnt, n, m, k, dis[N], dep[N], s[N], t[N], L[N], fa[N][M], rnk[N], dfs-clock, len[N], d[N], fr[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><span class="hljs-keyword">int</span> nxt, v, w;&#125; e[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">void</span> add-<span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w) &#123;<br>    e[++ecnt] = &#123;head[u], v, w&#125;; head[u] = ecnt;<br>    e[++ecnt] = &#123;head[v], u, w&#125;; head[v] = ecnt;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    fa[u][<span class="hljs-number">0</span>] = f;<br>    rnk[++dfs-clock] = u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; M; i++) &#123;<br>        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>    <span class="hljs-keyword">int</span> v = e[i].v, w = e[i].w;<br>    <span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>    dis[v] = dis[u] + w;<br>    fr[v] = w;<br>    dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(v, u); <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = M - <span class="hljs-number">1</span>; i + <span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i];<br>&#125;<br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> v;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = M - <span class="hljs-number">1</span>; i + <span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];<br>&#125;<br><span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> d);<br><span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (len[i] &lt;= x) <span class="hljs-keyword">continue</span>;<br>cnt++;<br>mx = <span class="hljs-built_in">max</span>(len[i], mx);<br>d[s[i]]++;<br>d[t[i]]++;<br>d[L[i]] -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; i--) &#123;<br><span class="hljs-keyword">int</span> now = rnk[i];<br>        d[fa[now][<span class="hljs-number">0</span>]] += d[now];<br>        <span class="hljs-keyword">if</span> (d[now] == cnt &amp;&amp; mx - fr[now] &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v, w;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>    add-<span class="hljs-built_in">edge</span>(u, v, w);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;s[i], &amp;t[i]);<br>        L[i] = <span class="hljs-built_in">LCA</span>(s[i], t[i]);<br>        len[i] = dis[s[i]] + dis[t[i]] - <span class="hljs-number">2</span> * dis[L[i]];<br>        r = <span class="hljs-built_in">max</span>(len[i], r);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid - <span class="hljs-number">1</span>, ans = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfn序</tag>
      
      <tag>trick</tag>
      
      <tag>树</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>或许是反思吧</title>
    <link href="/2020/11/09/%E6%88%96%E8%AE%B8%E6%98%AF%E5%8F%8D%E6%80%9D%E5%90%A7/"/>
    <url>/2020/11/09/%E6%88%96%E8%AE%B8%E6%98%AF%E5%8F%8D%E6%80%9D%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>或许是这个博客最后一篇文章了</p><p>其实我并不知道该说什么，但总想写点什么</p><p>停了两个月的学科课，以这样垃圾的初赛成绩结束我的OI生涯，我自己都觉得很滑稽</p><p>我不知道为什么我还坐在机房里，在我心里已经成为了逃避现实的地方吧</p><p>没错，其实我已经很想回去上文化课了，因为看不到一点希望，但是却又不能面对缺了两个月的课程</p><p>我的学科一直都很差，至少进高中以来一直是这样。我甚至有点怀疑是什么让我能坚持学oi到现在。</p><p>悲伤也好，难过也好，我问自己后不后悔，也不知道想的是什么。</p><p>不过，我真的已经尽力了。可能是我第一次，也是最后一次了，考一场试如此认真，这么紧张过。</p><p>很难忘记，当初看到第一题时，心里有多慌张。无数次在脑海里出现的画面，终于发生在我身上了。</p><p>我强迫自己读题，读了三四遍以后，才懂它要干什么。但是我根本不知道该怎么做，滑稽吧，一个模拟题没有一点思路。终于在90分钟以后，写出了20分的暴力。然后做后面的题，写完第二题后，我突然就安静下来了。我想到了许多，也许这场比赛完，我的OI生涯也就结束了。但是我不甘啊，还是硬着头皮写了后面的题，当时时间真的很紧迫，我有点思路就直接开始写了，什么实现方法根本没想。</p><blockquote><p>如果来生太远寄不到诺言</p><p>不如学着放下许多执念</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20普转提day2 题解</title>
    <link href="/2020/10/29/20%E6%99%AE%E8%BD%AC%E6%8F%90day2_%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/10/29/20%E6%99%AE%E8%BD%AC%E6%8F%90day2_%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>马上联赛了，把陈年老题改一下，<del>试图找点自信?</del></p></blockquote><p>感觉沈睿出的题还是很有技术含量的，只是我不会做就是了。</p><p><a href="http://zhengruioi.com/contest/562">比赛地址</a></p><span id="more"></span><h2 id="a-串">A 串</h2><p>感觉直接大力讨论就可以了，因为情况不是很多。</p><p>可能是太懒了，这题都不会。</p><h2 id="b-数">B 数</h2><p>好像洛谷月赛有一道类似的题。</p><p>把数重小到大排序，然后<span class="math inline">\(f[i]\)</span>表示前<span class="math inline">\(i\)</span>个数能凑出的最大的数。</p><p>即<span class="math inline">\(f[i]+1\)</span>不能被凑出。</p><p>如果<span class="math inline">\(f[i-1]+1&lt;a[i]\)</span>，<span class="math inline">\(f[i-1]+1\)</span>即不能被凑出，因为后面的数已经不可能被选。</p><p>否则，<span class="math inline">\(f[i-1]+a[i]\)</span>都可以被凑出，则<span class="math inline">\(1+a[i],2+a[i],\dots f[i-1]+a[i]\)</span>可以被凑出。</p><h2 id="c-图">C 图</h2><p>基础状压都不会...</p><p><span class="math inline">\(f[i]\)</span>表示子图最小去几条边变成DAG，因为DAG一定有一个度数为<span class="math inline">\(0\)</span>的点，所以枚举这个点。</p><p>从<span class="math inline">\(f[i\oplus 2^j]\)</span>去掉子图中连向它的边转移过来。</p><h2 id="d-睿爸三角">D 睿爸三角</h2><p>杨辉三角第<span class="math inline">\(i\)</span> 行，第<span class="math inline">\(j\)</span>列的值等于<span class="math inline">\(\binom{i-1}{j-1}\)</span></p><p>即求每一行多少个<span class="math inline">\(m\)</span>满足<span class="math inline">\(\binom{n}{m}\bmod 7\neq 0\)</span></p><p>根据Lucas定理<span class="math inline">\(\binom{n}{m}\%7=\binom{n/7}{m/7}\binom{n\% 7}{m\% 7}\%7\)</span></p><p>即相当于七进制下每一位的组合数的乘积</p><p>因为<span class="math inline">\(7\)</span>是质数，所以只需要没有<span class="math inline">\(\binom{n}{m}=0\)</span>即可满足条件</p><p>即<span class="math inline">\(m\leq n\)</span></p><p>每一位都有<span class="math inline">\(bit(n)+1\)</span>种填法。</p><p>问题转化为，<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>所有数在七进制下每一位加一的乘积和。</p><p>因为乘法有分配律，就是<span class="math inline">\(a\times b+a\times c=a\times(b+c)\)</span></p><p>可以数位<span class="math inline">\(dp\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">40</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> f[N][<span class="hljs-number">2</span>], a[N], cnt;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> less)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (f[x][less] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x][less];<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    f[x][less] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mx = less ? <span class="hljs-number">6</span> : a[x];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= mx; i++) f[x][less] = (f[x][less] + (i + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">dfs</span>(x - <span class="hljs-number">1</span>, less || (i &lt; a[x])) % MOD) % MOD;<br>    <span class="hljs-keyword">return</span> f[x][less];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    cin &gt;&gt; n;<br>    n--;<br>    <span class="hljs-keyword">while</span> (n) a[++cnt] = n % <span class="hljs-number">7</span>, n /= <span class="hljs-number">7</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">dfs</span>(cnt, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SCOI2012 滑雪与时间胶囊</title>
    <link href="/2020/10/23/SCOI2012_%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A/"/>
    <url>/2020/10/23/SCOI2012_%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2373">「SCOI2012」滑雪与时间胶囊</a></p></blockquote><p>因为只能从更高的点到不高于它的点。</p><p>我们给边定向后(虽然有些边还是无向的)，看一下从<span class="math inline">\(1\)</span>能到哪些点就。</p><span id="more"></span><p>第二问，因为有些边是有向的，为了走完所有点，一点要从更高的点开始走。</p><p>如果形成了树的结构，显然是可以走完所有点的。</p><p>但是为了保证从高点走到低点，我们需要指向更高点的边被优先选出。</p><p>不然有可能没有走向它的边，肯定是不对的。</p><p>话说这图好像可以叉掉<span class="math inline">\(prime\)</span>。</p><p><img src="https://widsnoy.top/usr/uploads/2020/10/1237093525.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">6</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br><span class="hljs-keyword">int</span> u, v, w;<br>&#125; E[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> n, m, h[N], head[N], ecnt, cnt, tot, fa[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> fa[x] ? fa[x] = <span class="hljs-built_in">find</span>(fa[x]) : x;&#125;<br><span class="hljs-keyword">void</span> add-<span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w) &#123;<br>    e[++ecnt] = &#123;head[u], v, w&#125;; head[u] = ecnt;<br>    e[++ecnt] = &#123;head[v], u, w&#125;; head[v] = ecnt;<br>&#125;<br><br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>tot++;<br>vis[u] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v, w = e[i].w;<br><span class="hljs-keyword">if</span> (h[u] &lt; h[v]) <span class="hljs-keyword">continue</span>;<br>        E[++cnt] = &#123;u, v, w&#125;;<br><span class="hljs-built_in">dfs</span>(v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v , w;<br>    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>    add-<span class="hljs-built_in">edge</span>(u, v, w);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">sort</span>(E + <span class="hljs-number">1</span>, E + cnt + <span class="hljs-number">1</span>, [&amp;](Edge a, Edge b) &#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (h[a.v] == h[b.v]) ? a.w &lt; b.w : h[a.v] &gt; h[b.v];&#125;);<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(E[i].u), v = <span class="hljs-built_in">find</span>(E[i].v);<br>        <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">continue</span>;<br>        c++;<br>        w += E[i].w;<br>        fa[u] = v;<br>        <span class="hljs-keyword">if</span> (c == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; w &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树上差分</title>
    <link href="/2020/10/23/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2020/10/23/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="dfs-序-3树上差分-1"><a href="https://loj.ac/problem/146">DFS 序 3，树上差分 1</a></h2><blockquote><p>给一棵有根树，这棵树由编号为<span class="math inline">\(1...N\)</span>的 <span class="math inline">\(N\)</span>个结点组成。根结点的编号为<span class="math inline">\(R\)</span> 。每个结点都有一个权值，结点<span class="math inline">\(i\)</span> 的权值为<span class="math inline">\(V-i\)</span> 。 接下来有<span class="math inline">\(M\)</span>组操作，操作分为三类：</p><ul><li><code>1 a b x</code>，表示将「结点<span class="math inline">\(a\)</span>到结点<span class="math inline">\(b\)</span>的简单路径」上所有结点的权值都增加<span class="math inline">\(x\)</span> ；</li><li><code>2 a</code>，表示求结点<span class="math inline">\(a\)</span> 的权值。</li><li><code>3 a</code>，表示求 <span class="math inline">\(a\)</span>的子树上所有结点的权值之和。</li></ul></blockquote><p>上来就写了树剖，交上去<span class="math inline">\(TLE\)</span>了一个点。</p><p>诶，我被卡常数了？</p><span id="more"></span><p>卡常数卡到怀疑人生，点开最优解，树上差分啊，那没事了。</p><h3 id="分析">分析</h3><p>先说前两个操作，考虑更改的链两个端点<span class="math inline">\(u,v\)</span>祖先关系的情况。</p><p>把<span class="math inline">\(v\)</span>增加<span class="math inline">\(x\)</span>，<span class="math inline">\(fa[u]\)</span>减去<span class="math inline">\(x\)</span>即可。单点查询时查询该点的子树差分数组和。</p><p>更一般的情况是，<span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span>增加<span class="math inline">\(x\)</span>，<span class="math inline">\(lca\)</span>和<span class="math inline">\(fa[lca]\)</span>减去<span class="math inline">\(x\)</span>。</p><p>意会一下这样修改显然是对的。</p><p>对于三操作我们想一下<span class="math inline">\(u\)</span>子树被修改的<span class="math inline">\(v\)</span>的贡献。</p><p>每个点的贡献是<span class="math inline">\((dep[v]-dep[u]+1)\times val[v]\)</span></p><p>也就是<span class="math inline">\(dep[v]\times val[v]-(dep[u]-1)\times val[v]\)</span></p><p>所以开一个树状数组记一下<span class="math inline">\(dep[v]\times val[v]\)</span>，而<span class="math inline">\(\sum val[v]\)</span>直接查一下所有子树修改的和就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n, m, r, v[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bit</span> &#123;</span><br>    ll t1[N], t2[N];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, ll k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) t1[i] += k, t2[i] += k * <span class="hljs-number">1ll</span> * (x - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, ll k)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(l, k);<br>        <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -k);<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        ll ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) ans += x * <span class="hljs-number">1ll</span> * t1[i] - t2[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>); &#125;<br>&#125; b1, b2;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-keyword">int</span> siz[N], son[N], top[N], fa[N], dfn[N], rnk[N], dep[N], dfs-clock;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    dep[u] = dep[f] + <span class="hljs-number">1</span>;<br>    siz[u] = <span class="hljs-number">1</span>;<br>    fa[u] = f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v, u);<br>        siz[u] += siz[v];<br>        <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">0</span> || siz[son[u]] &lt; siz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> tp)</span> </span>&#123;<br>    dfn[u] = ++dfs-clock, rnk[dfs-clock] = u, top[u] = tp;<br>    <span class="hljs-keyword">if</span> (son[u]) <span class="hljs-built_in">dfs2</span>(son[u], tp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v, v);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="hljs-built_in">swap</span>(u, v);<br>        u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w * f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) v[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e[u].push-<span class="hljs-built_in">back</span>(v);<br>        e[v].push-<span class="hljs-built_in">back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">dfs1</span>(r, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs2</span>(r, r);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        b1.<span class="hljs-built_in">upd</span>(dfn[i], dfn[i], v[i]); <br>        b2.<span class="hljs-built_in">upd</span>(dfn[i], dfn[i], v[i] * <span class="hljs-number">1ll</span> * dep[i]);<br>        <span class="hljs-keyword">if</span> (i != r) b1.<span class="hljs-built_in">upd</span>(dfn[fa[i]], dfn[fa[i]], -v[i]), b2.<span class="hljs-built_in">upd</span>(dfn[fa[i]], dfn[fa[i]], -dep[fa[i]] * <span class="hljs-number">1ll</span> * v[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">int</span> op, a, b, x;<br>        op = <span class="hljs-built_in">read</span>(), a =<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            b = <span class="hljs-built_in">read</span>(), x = <span class="hljs-built_in">read</span>();<br>            <span class="hljs-keyword">int</span> LCA = <span class="hljs-built_in">lca</span>(a, b);<br>            b1.<span class="hljs-built_in">upd</span>(dfn[b], dfn[b], x);<br>            b1.<span class="hljs-built_in">upd</span>(dfn[a], dfn[a], x);<br>            b1.<span class="hljs-built_in">upd</span>(dfn[LCA], dfn[LCA], -x);<br>            b2.<span class="hljs-built_in">upd</span>(dfn[b], dfn[b], dep[b] * <span class="hljs-number">1ll</span> * x);<br>            b2.<span class="hljs-built_in">upd</span>(dfn[a], dfn[a], dep[a] * <span class="hljs-number">1ll</span> * x);<br>            b2.<span class="hljs-built_in">upd</span>(dfn[LCA], dfn[LCA], -dep[LCA] * <span class="hljs-number">1ll</span> * x);<br>            <span class="hljs-keyword">if</span> (LCA != r) b1.<span class="hljs-built_in">upd</span>(dfn[fa[LCA]], dfn[fa[LCA]], -x), b2.<span class="hljs-built_in">upd</span>(dfn[fa[LCA]], dfn[fa[LCA]], -dep[fa[LCA]] * <span class="hljs-number">1ll</span> * x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, b1.<span class="hljs-built_in">qry</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            ll res = -b1.<span class="hljs-built_in">qry</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (dep[a] - <span class="hljs-number">1</span>);<br>            res += b2.<span class="hljs-built_in">qry</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dfs-序-4"><a href="https://loj.ac/problem/147">DFS 序 4</a></h2><blockquote><p>给一棵有根树，这棵树由编号为<span class="math inline">\(1...N\)</span>的 <span class="math inline">\(N\)</span>个结点组成。根结点的编号为<span class="math inline">\(R\)</span> 。每个结点都有一个权值，结点<span class="math inline">\(i\)</span> 的权值为<span class="math inline">\(V-i\)</span> 。 接下来有<span class="math inline">\(M\)</span>组操作，操作分为三类：</p><ul><li><code>1 a x</code>，表示将结点<span class="math inline">\(a\)</span> 的权值增加 ；</li><li><code>2 a x</code>，表示将<span class="math inline">\(a\)</span> 的子树上所有结点的权值增加<span class="math inline">\(x\)</span> ；</li><li><code>3 a b</code>，表示求「结点<span class="math inline">\(a\)</span> 到结点 <span class="math inline">\(b\)</span>的简单路径」上所有结点的权值之和。</li></ul></blockquote><p>一个重要的转化是<span class="math inline">\(val(u,v)=val(u)+val(v)-val(lca)-val(fa[lca])\)</span></p><p>考虑<span class="math inline">\(1,3\)</span>问题，每个单点修改会贡献到子树上，单点修改直接修改，查询时分别查<span class="math inline">\(a,b\)</span>到根的权值，减去<span class="math inline">\(lca\)</span>和<span class="math inline">\(fa[lca]\)</span>的值即可。</p><p>对于<span class="math inline">\(2,3\)</span>问题，<span class="math inline">\(u\)</span>对子树节点<span class="math inline">\(v\)</span>的贡献是<span class="math inline">\((dep[v]-dep[u]+1)\times val=dep[v]\times val+(1-dep[u])\times val\)</span></p><p>先把固定的<span class="math inline">\((1-dep[u])\times val\)</span>给子树每个节点，另外子树的点记一下被加了多少次，查询的时候就乘上一个<span class="math inline">\(dep\)</span>，于是就知道了节点<span class="math inline">\(v\)</span>到根的权值和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n, m, r;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bit</span> &#123;</span><br>    ll t1[N], t2[N];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, ll k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) t1[i] += k, t2[i] += k * <span class="hljs-number">1ll</span> * (x - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, ll k)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(l, k);<br>        <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -k);<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        ll ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) ans += x * <span class="hljs-number">1ll</span> * t1[i] - t2[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>); &#125;<br>&#125; b1, b2;<br><br>ll v[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-keyword">int</span> siz[N], son[N], top[N], fa[N], dfn[N], rnk[N], dep[N], dfs-clock;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    dep[u] = dep[f] + <span class="hljs-number">1</span>;<br>    siz[u] = <span class="hljs-number">1</span>;<br>    fa[u] = f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v, u);<br>        siz[u] += siz[v];<br>        <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">0</span> || siz[son[u]] &lt; siz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> tp)</span> </span>&#123;<br>    dfn[u] = ++dfs-clock, rnk[dfs-clock] = u, top[u] = tp;<br>    <span class="hljs-keyword">if</span> (son[u]) <span class="hljs-built_in">dfs2</span>(son[u], tp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v, v);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="hljs-built_in">swap</span>(u, v);<br>        u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> b1.<span class="hljs-built_in">qry</span>(dfn[x], dfn[x]) + b2.<span class="hljs-built_in">qry</span>(dfn[x], dfn[x]) * <span class="hljs-number">1ll</span> * dep[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;r);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;v[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        e[u].push-<span class="hljs-built_in">back</span>(v);<br>        e[v].push-<span class="hljs-built_in">back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">dfs1</span>(r, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs2</span>(r, r);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) b1.<span class="hljs-built_in">upd</span>(dfn[i], dfn[i] + siz[i] - <span class="hljs-number">1</span>, v[i]);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-keyword">int</span> op, a, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;a, &amp;x);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            b1.<span class="hljs-built_in">upd</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>, x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            b1.<span class="hljs-built_in">upd</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> - dep[a]) * <span class="hljs-number">1ll</span> * x);<br>            b2.<span class="hljs-built_in">upd</span>(dfn[a], dfn[a] + siz[a] - <span class="hljs-number">1</span>, x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">int</span> LCA = <span class="hljs-built_in">lca</span>(a, x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">calc</span>(a) + <span class="hljs-built_in">calc</span>(x) - <span class="hljs-built_in">calc</span>(LCA) - <span class="hljs-built_in">calc</span>(fa[LCA]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树上差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对拍脚本</title>
    <link href="/2020/10/23/%E5%AF%B9%E6%8B%8D%E8%84%9A%E6%9C%AC/"/>
    <url>/2020/10/23/%E5%AF%B9%E6%8B%8D%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>贴一下对拍的脚本</p></blockquote><span id="more"></span><h2 id="bash">bash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs BASH"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>    ./make &gt; data.in<br>    ./a &lt; data.in &gt; a.out<br>    ./b &lt; data.in &gt; b.out<br>    <span class="hljs-keyword">if</span> diff a.out b.out; <span class="hljs-keyword">then</span> <br>        <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;Accept\n&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;Wrong answer\n&quot;</span><br>        <span class="hljs-built_in">exit</span> 0<br>    <span class="hljs-keyword">fi</span> <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="bat">bat</h2><blockquote><p>参考自<a href="https://blog.csdn.net/weixin-41162823/article/details/87382479">这里</a></p></blockquote><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">@echo off  <br>:loop  <br>    make.exe %random% &gt; <span class="hljs-keyword">data</span>.<span class="hljs-keyword">in</span><br>    a.exe &lt; <span class="hljs-keyword">data</span>.<span class="hljs-keyword">in</span> &gt; a.<span class="hljs-keyword">out</span><br>    b.exe &lt; <span class="hljs-keyword">data</span>.<span class="hljs-keyword">in</span> &gt; b.<span class="hljs-keyword">out</span><br>    fc a.<span class="hljs-keyword">out</span> b.<span class="hljs-keyword">out</span> <br><span class="hljs-keyword">if</span> not errorlevel <span class="hljs-number">1</span> <span class="hljs-keyword">goto</span> loop  <br><span class="hljs-keyword">pause</span><br><span class="hljs-keyword">goto</span> loop<br></code></pre></td></tr></table></figure><p>首先@echo off 是关掉输入显示，不然你的所有命令都会显示出来的，防止刷屏。 ：loop是定位标记点，和c语言里的goto很像。 中间是主体程序。 if not errorlevel 1 goto loop ，errorlevel 是上一个命令的返回值，fc在文件不同时返回1，相同时返回<span class="math inline">\(0\)</span>，这一行的意思就是，如果fc返回的不是<span class="math inline">\(1\)</span>，就跳到:loop，使劲循环。 pause，暂停，一旦fc返回<span class="math inline">\(1\)</span>，就会执行到这一行，停住程序，给你时间看数据。 goto loop，看完数据，按下任意键结束暂停，继续循环。</p><p><span class="math inline">\(\text{windows}\)</span>下可以用系统的随机数种子，这样生成数据更快些，不知道<span class="math inline">\(\text{linux}\)</span>上有没有类似的东西。</p><p>写数据生成程序时这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stringstream ss;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> seed;<br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        ss.<span class="hljs-built_in">clear</span>();<br>        ss &lt;&lt; argv[<span class="hljs-number">1</span>];<br>        ss &gt;&gt; seed;<br>    &#125;<br>    <span class="hljs-built_in">srand</span>(seed);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ZJOI2016 小星星</title>
    <link href="/2020/10/21/ZJOI2016_%E5%B0%8F%E6%98%9F%E6%98%9F/"/>
    <url>/2020/10/21/ZJOI2016_%E5%B0%8F%E6%98%9F%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2091">题目链接</a></p></blockquote><p>感觉是第一次入手容斥原理 (?)</p><span id="more"></span><p>小Y是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有<span class="math inline">\(n\)</span>颗小星星，用<span class="math inline">\(m\)</span>条彩色的细线串了起来，每条细线连着两颗小星星。有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了<span class="math inline">\(n−1\)</span>条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小Y找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小Y想知道有多少种可能的对应方式。只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。</p><p>抽象化的题意：用<span class="math inline">\(1\sim n\)</span>的排列给树上节点编号，有树边<span class="math inline">\((u,v)\)</span>的两个端点编号<span class="math inline">\(p-u,p-v\)</span>在原图上也要有一条边。</p><p>最暴力的方法是枚举全排列，然后去验证合不合法。</p><p>可以把全排列变成枚举子集，树形<span class="math inline">\(dp\)</span>暴力合并。</p><p>状态设置为<span class="math inline">\(dp[i][j][s]\)</span>，数值表示编号的方案数。</p><ol type="1"><li>第二维是为了满足转移的时候<span class="math inline">\(u,v\)</span>直接有边。</li><li>第三维是子树中用了的点的编号，目的是保证最后选出的是一个排列</li></ol><p>可以用容斥原理去掉第三维。</p><p>钦定可以用的点，然后计算方案数，容斥原理得出全集的答案。</p><p>具体来说<span class="math inline">\(dp[i][j]\)</span>表示<span class="math inline">\(i\)</span>点编号为<span class="math inline">\(j\)</span>时子树的编号方案数。</p><p>转移方程<span class="math inline">\(dp[u][i]=\prod-{v\in son-u}\sum dp[v][j]*[\text{some limit}]\)</span></p><p>比如这里条件限制是<span class="math inline">\(i,j\)</span>可用并且<span class="math inline">\((i,j)\)</span>这条边存在。</p><p>没有删点时，可能把有一些点没用的方案数算进去。</p><p>比如一个点没用，所以枚举缺一个点的情况，减去它的方案数。</p><p>但是你会发现缺两个点的情况又被减去两次，所以又要加回来，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">18</span>;<br>ll dp[N][N];<br><span class="hljs-keyword">int</span> n, m;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><span class="hljs-keyword">bool</span> mp[N][N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dp[u][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br><span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v, u);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                sum += dp[v][j] * (mp[i][j] &amp; b[i] &amp; b[j]);<br>&#125;<br>dp[u][i] *= sum;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        mp[u][v] = mp[v][u] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>    e[u].push-<span class="hljs-built_in">back</span>(v);<br>    e[v].push-<span class="hljs-built_in">back</span>(u);<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> b);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) b[j] = ((i &gt;&gt; (j - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>), size += !b[j];<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = (size &amp; <span class="hljs-number">1</span>) ? res - dp[<span class="hljs-number">1</span>][i] : res + dp[<span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LibreOJ β Round</title>
    <link href="/2020/10/20/%E3%80%8CLibreOJ-%CE%B2-Round-#2%E3%80%8DDP-%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B/"/>
    <url>/2020/10/20/%E3%80%8CLibreOJ-%CE%B2-Round-#2%E3%80%8DDP-%E4%B8%80%E8%88%AC%E7%9C%8B%E8%A7%84%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/516">「LibreOJ β Round #2」DP 一般看规律</a></p></blockquote><p>感觉题目不是很难，不过代码技巧学习了。</p><span id="more"></span><p>把所有数按颜色插入到<span class="math inline">\(\text{set}\)</span>里面，每次合并的时候对于每个数只有前驱或者后缀会产生答案。</p><p>所以合并的时候更新下答案就可以了。</p><p>这个<span class="math inline">\(\text{map&lt;int,set&lt;int&gt;&gt;}\)</span>学到了啊，相当于每个下标都对应了一个<span class="math inline">\(\text{set}\)</span>，也就是开了多个<span class="math inline">\(\text{set}\)</span>，并且是动态申请的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;<span class="hljs-keyword">int</span>, set&lt;<span class="hljs-keyword">int</span>&gt; &gt; m;<br><span class="hljs-keyword">int</span> n, q, ans = <span class="hljs-number">2147483647</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> it = m[s].lower-<span class="hljs-built_in">bound</span>(x);<br>    <span class="hljs-keyword">if</span> (it != m[s].<span class="hljs-built_in">end</span>()) ans = <span class="hljs-built_in">min</span>(ans, *it - x);<br>    <span class="hljs-keyword">if</span> (it != m[s].<span class="hljs-built_in">begin</span>()) ans = <span class="hljs-built_in">min</span>(ans, x - *--it);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    m[x].<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; q--; ) &#123;<br>    <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = m[x].<span class="hljs-built_in">begin</span>(); it != m[x].<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            <span class="hljs-built_in">find</span>(y, *it);<br>            m[y].<span class="hljs-built_in">insert</span>(*it);<br>            &#125;<br>            m[x].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SUMCUBE 立方和</title>
    <link href="/2020/10/20/SUMCUBE_%E7%AB%8B%E6%96%B9%E5%92%8C/"/>
    <url>/2020/10/20/SUMCUBE_%E7%AB%8B%E6%96%B9%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://s3.amazonaws.com/codechef-shared/download/translated/SEPT17/mandarin/SUMCUBE.pdf">题目链接</a></p></blockquote><p><span class="math inline">\(k\)</span>次方的组合意义是有顺序的选出<span class="math inline">\(k\)</span>条边，统计在多少个子图中出现。</p><span id="more"></span><h2 id="k1">k=1</h2><p>考虑每条边的贡献。</p><p>答案显然是<span class="math inline">\(m*2^{n-2}\)</span></p><h2 id="k2">k=2</h2><p>可能选出相同的边，对应<span class="math inline">\(k=1\)</span></p><p>有可能不同，考虑三种情况。</p><ol type="1"><li><p>上</p></li><li><p>两条边三个点，<span class="math inline">\(A\rightarrow B\rightarrow C\)</span>，枚举一条边<span class="math inline">\((s,t)\)</span>，<span class="math inline">\((deg-s-1)+(deg-t-1)\)</span><br /></p></li><li><p>两条边四个点，<span class="math inline">\(A\rightarrow B,C\rightarrow D\)</span>，总方案数减去上面的，<span class="math inline">\(m^2-①-②\)</span></p></li></ol><h2 id="k3">k=3</h2><p>这个比较麻烦，标程是斯特林数去掉指数，很是不懂。</p><p>其实也可以大力讨论</p><ol type="1"><li>三条边重合，即<span class="math inline">\(k=1\)</span></li><li>有两条边重合，对应<span class="math inline">\(k=2\)</span></li><li>三元环，直接<a href="https://widsnoy.top/archives/76/">三元环计数</a></li><li>三边四点，<span class="math inline">\(A\rightarrow B\rightarrow C \rightarrow D\)</span>或者<span class="math inline">\(A\rightarrow B, A\rightarrow C, A\rightarrow D\)</span>。对于第一种枚举边<span class="math inline">\((B,C)\)</span>，<span class="math inline">\((deg-B-1)\times (deg-C-1)\)</span>，<span class="math inline">\(A,D\)</span>可能是一个点，要减去三元环的情况。第二种枚举<span class="math inline">\(A\)</span>，<span class="math inline">\(deg-A\times (deg-A-1)\times (deg-A-2)\)</span>。</li><li>三边五点， 可能有一种情况<span class="math inline">\(A\rightarrow B\rightarrow C,D\rightarrow E\)</span>。枚举<span class="math inline">\(B\)</span>点，有<span class="math inline">\(deg-B\times(deg-B-1)\times (m-2)\)</span>种方法。但是有可能算到三元环和三边四点的情况。这里注意对于三边四点的第一种情况会算两次，第二种情况算三次。</li><li>三边两点，<span class="math inline">\(m\times (m-1)\times (m-2)\)</span>是有序选不重边的所有方案，减去③④⑤就是这个。</li></ol><p>上面的所有选出的情况都是不考虑顺序的，选不重的边最后应该乘上<span class="math inline">\(6\)</span>表示选取顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, m, k, deg[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % MOD;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> baoli &#123;<br>    <span class="hljs-keyword">bool</span> b[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; e[<span class="hljs-number">20</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> b);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)) &amp; s) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : e[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (!b[i][j] &amp;&amp; (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>) &amp; s)) res = (res + <span class="hljs-number">1</span>) % MOD, b[i][j] = b[j][i] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) e[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">int</span> u, v;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>            e[u].push-<span class="hljs-built_in">back</span>(v);<br>            e[v].push-<span class="hljs-built_in">back</span>(u);<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; i++) res = (res + <span class="hljs-built_in">fpow</span>(<span class="hljs-built_in">F</span>(i), k)) % MOD;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> kk &#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br>    <span class="hljs-keyword">int</span> vis[N];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> u, v;<br>    &#125;;<br>    node v[N];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (deg[v[i].u] &gt; deg[v[i].v] || (deg[v[i].u] == deg[v[i].v] &amp;&amp; v[i].u &lt; v[i].v)) e[v[i].u].push-<span class="hljs-built_in">back</span>(v[i].v);<br>            <span class="hljs-keyword">else</span> e[v[i].v].push-<span class="hljs-built_in">back</span>(v[i].u);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[i]) vis[v] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[i])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : e[v]) <span class="hljs-keyword">if</span> (vis[j] == i) res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;v[i].u, &amp;v[i].v);<br>            deg[v[i].u]++;<br>            deg[v[i].v]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> y3 = <span class="hljs-built_in">calc</span>();<br>       <span class="hljs-comment">// printf(&quot;y3 = %d\n&quot;, y3);</span><br>        <span class="hljs-keyword">int</span> res1 = m * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>) % MOD;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">1ll</span> * m * (m - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> w = deg[i];<br>            <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">3</span>) res = (res + <span class="hljs-number">1ll</span> * w * (w - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % MOD * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">3</span>)) % MOD;<br>            tmp -= <span class="hljs-number">1ll</span> * w * (w - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">4</span>) res = (res + tmp % MOD * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">4</span>)) % MOD;<br>        res= res * <span class="hljs-number">2ll</span> % MOD;<br>        res = (res + m * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>) % MOD) % MOD;<br>        <span class="hljs-keyword">int</span> ans = (res + MOD - res1) % MOD;<br>        ans = ans * <span class="hljs-number">3ll</span> % MOD;<br>        ans = ans + res1 % MOD;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i6 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">6</span>, MOD - <span class="hljs-number">2</span>), i2 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, MOD - <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">int</span> cnt4 = MOD - <span class="hljs-number">3</span> * <span class="hljs-number">1ll</span> * y3 % MOD, cnt5 = <span class="hljs-number">0</span>, cnt6 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cnt4 = (cnt4 + deg[i] * <span class="hljs-number">1ll</span> * (deg[i] - <span class="hljs-number">1</span>) % MOD * (deg[i] - <span class="hljs-number">2</span>) % MOD * <span class="hljs-number">1ll</span> * i6 % MOD) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            cnt4 = (cnt4 + (deg[v[i].u] - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (deg[v[i].v] - <span class="hljs-number">1</span>) % MOD);<br>        &#125;<br>        cnt5 = MOD - cnt4 * <span class="hljs-number">2ll</span> % MOD;<br>        cnt5 = (cnt5 + MOD - y3 * <span class="hljs-number">1ll</span> * <span class="hljs-number">3</span> % MOD) % MOD;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cnt5 = (cnt5 + MOD - deg[i] * <span class="hljs-number">1ll</span> * (deg[i] - <span class="hljs-number">1</span>) % MOD * (deg[i] - <span class="hljs-number">2</span>) % MOD * <span class="hljs-number">1ll</span> * i6 % MOD) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cnt5 = (cnt5 + (deg[i] - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * deg[i] % MOD * <span class="hljs-number">1ll</span> * (m - <span class="hljs-number">2</span>) % MOD * i2 % MOD) % MOD;<br>        &#125;<br>        cnt6 = (m * <span class="hljs-number">1ll</span> * (m - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (m - <span class="hljs-number">2</span>) / <span class="hljs-number">6</span> - y3 - cnt4 - cnt5) % MOD;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (ans + <span class="hljs-number">6ll</span> * ((y3 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">3</span>) % MOD + cnt4 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">4</span>) % MOD + cnt5 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">5</span>) % MOD + cnt6 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">6</span>) % MOD) % MOD) % MOD) % MOD);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">15</span>) baoli::<span class="hljs-built_in">main</span>();<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) kk::<span class="hljs-built_in">main</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        deg[u]++, deg[v]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, m * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>) % MOD);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">1ll</span> * m * (m - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> w = deg[i];<br>            <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">3</span>) res = (res + <span class="hljs-number">1ll</span> * w * (w - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % MOD * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">3</span>)) % MOD;<br>            tmp -= <span class="hljs-number">1ll</span> * w * (w - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">4</span>) res = (res + tmp % MOD * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">4</span>)) % MOD;<br>        res= res * <span class="hljs-number">2ll</span> % MOD;<br>        res = (res + m * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>) % MOD) % MOD;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
      <tag>组合数</tag>
      
      <tag>图论</tag>
      
      <tag>三元环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20联赛集训day7</title>
    <link href="/2020/10/20/20%E8%81%94%E8%B5%9B%E9%9B%86%E8%AE%ADday7/"/>
    <url>/2020/10/20/20%E8%81%94%E8%B5%9B%E9%9B%86%E8%AE%ADday7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>rdx是真的牛逼</p></blockquote><p><a href="https://widsnoy.top/usr/uploads/2020/10/2489209902.pdf">题面</a></p><span id="more"></span><h2 id="a.-20联赛集训day7稻草富翁">A. [20联赛集训day7]稻草富翁</h2><p>看一下转一轮后会不会增加数。</p><p>注意一下等于<span class="math inline">\(0\)</span>的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> a, b, c, d, e, f;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> b * <span class="hljs-number">1ll</span> * d * <span class="hljs-number">1ll</span> * f &gt; a * <span class="hljs-number">1ll</span> * c * <span class="hljs-number">1ll</span> * e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> -;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;-); -; ---) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f);<br>        <span class="hljs-keyword">bool</span> pd = <span class="hljs-built_in">check</span>();<br>        <span class="hljs-keyword">if</span> (pd) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;MEI&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FON&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b.-20联赛集训day7序列">B. [20联赛集训day7]序列</h2><p>区间加就差分，对操作也差分。</p><p>无非就是要知道某个操作做了多少次，倒着差分就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">4</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, q, a[N], b[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br><span class="hljs-keyword">int</span> op, l, r;<br>&#125; now[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;now[i].op, &amp;now[i].l, &amp;now[i].r);<br>    b[q + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = q; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>    b[i] = (b[i + <span class="hljs-number">1</span>] + b[i]) % MOD;<br>        <span class="hljs-keyword">if</span> (now[i].op == <span class="hljs-number">1</span>) &#123;<br>        a[now[i].l] = (a[now[i].l] + b[i]) % MOD;<br>        a[now[i].r + <span class="hljs-number">1</span>] = ((a[now[i].r + <span class="hljs-number">1</span>] - b[i]) % MOD + MOD) % MOD;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        b[now[i].r] = (b[now[i].r] + b[i]) % MOD;<br>        b[now[i].l - <span class="hljs-number">1</span>] = ((b[now[i].l - <span class="hljs-number">1</span>] - b[i]) % MOD + MOD) % MOD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    a[i] = (a[i - <span class="hljs-number">1</span>] + a[i]) % MOD;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>), <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c.-20联赛集训day7求和">C. [20联赛集训day7]求和</h2><p>反正都是原题，下一篇吧。</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20联赛集训day6</title>
    <link href="/2020/10/19/20%E8%81%94%E8%B5%9B%E9%9B%86%E8%AE%ADday6/"/>
    <url>/2020/10/19/20%E8%81%94%E8%B5%9B%E9%9B%86%E8%AE%ADday6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>莫名其妙的混了一个上午</p></blockquote><span id="more"></span><h2 id="卷">卷</h2><p>众所周知，集训队作业一下发，队员们立刻开始了卷卷卷的日子。</p><p>qjd 作为国家队的候选人之一，当然要争当卷王。于是他把这一堆集训队作业摆成了一个树状结构，第一天他就打算做一大批集训队作业题。</p><p>然而如果做的两个集训队作业题在树上有直接连边（即在树上相邻），那么 qjd 就会感觉非常不爽从而出 <span class="math inline">\(114514\)</span> 个多项式毒瘤题扔给大家做。</p><p>小 w 非常不希望这样的事情发生，<del>为了拯救世界</del>，他主动要求帮助 qjd 选择一些集训队作业题做。可是 qjd 是有要求的，他给每个题目定义了一个难度 <span class="math inline">\(w-i\)</span>，小 w 要让选出题的难度之<strong>积</strong>尽量大。</p><p>简要地说，给定一棵树，你需要求出最大乘积独立集。</p><p>由于答案很大，你只需要输出答案 <span class="math inline">\(\bmod 10^9+7\)</span> 的结果即可。</p><p><strong>此外，你可以认为 <span class="math inline">\(w-i\)</span> 是在给定范围内随机生成的</strong>.</p><p>最开始抄了个高精度，好像不怎么行...</p><p><span class="math inline">\(w-i\)</span>随机生成，取对数直接冲了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br>ll f[N][<span class="hljs-number">2</span>], w[N];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> g[N][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> <span class="hljs-title">chkmax</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    f[u][<span class="hljs-number">1</span>] = w[u];<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    g[u][<span class="hljs-number">1</span>] = <span class="hljs-built_in">log</span>(<span class="hljs-number">1.0</span> * w[u]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        g[u][<span class="hljs-number">1</span>] = g[v][<span class="hljs-number">0</span>] + g[u][<span class="hljs-number">1</span>];<br>        g[u][<span class="hljs-number">0</span>] = <span class="hljs-built_in">chkmax</span>(g[v][<span class="hljs-number">1</span>], g[v][<span class="hljs-number">0</span>]) + g[u][<span class="hljs-number">0</span>];<br>        f[u][<span class="hljs-number">1</span>] = f[v][<span class="hljs-number">0</span>] * f[u][<span class="hljs-number">1</span>] % MOD;<br>        <span class="hljs-keyword">if</span> (g[v][<span class="hljs-number">1</span>] &gt; g[v][<span class="hljs-number">0</span>]) f[u][<span class="hljs-number">0</span>] = f[v][<span class="hljs-number">1</span>] * f[u][<span class="hljs-number">0</span>] % MOD;<br>        <span class="hljs-keyword">else</span> f[u][<span class="hljs-number">0</span>] = f[u][<span class="hljs-number">0</span>] * f[v][<span class="hljs-number">0</span>] % MOD;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;w[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        e[u].push-<span class="hljs-built_in">back</span>(v);<br>        e[v].push-<span class="hljs-built_in">back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    ll ans = (g[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) ? f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] : f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单题">简单题</h2><p>小 w 居然过了数学预赛，和 qjd 一起来到了数竞班上课qjd 看了一眼讲义上的题，发现谁的不行，于是自己又随口说了一道题，给定一个包含 <span class="math inline">\(n\)</span> 个元素的集合 <span class="math inline">\(P=\{1,2,3,...,n\}\)</span>，求有多少个集合 <span class="math inline">\(A\subseteq P\)</span>，满足任意 <span class="math inline">\(x\in A\)</span> 有 <span class="math inline">\(2x\notin A\)</span>，且对于 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(P\)</span> 中的补集 <span class="math inline">\(B\)</span>，也满足任意 <span class="math inline">\(x\in B\)</span> 有 <span class="math inline">\(2x\notin B\)</span>。 小 w 花费了 <span class="math inline">\(10^{100}\)</span> 天终于算出来了这个答案，但是 qjd 居然又加了一个条件！他要求 <span class="math inline">\(A\)</span> 的大小恰好为 <span class="math inline">\(m\)</span>，这样又有多少个 <span class="math inline">\(A\)</span> 呢？ 这回 小 w 真的不会了，他找到了你，希望能够得到帮助。由于答案太大，你只需要输出答案 <span class="math inline">\(\bmod\ 10000019\)</span> 即可。</p><p>把每个<span class="math inline">\(p,p*2,p*2^2,p*2^3,\cdots,p*2^k\)</span>分为一组。</p><p>其中<span class="math inline">\(p\)</span>时素数 ，可以发现不同组别直接是不影响的，而同组的可以分成两类，<span class="math inline">\(A\)</span>必须选其中一类。</p><p>如果有偶数个，那么直接乘一个<span class="math inline">\(2\)</span>的贡献。</p><p>如果是奇数个，多出来的一个可以给<span class="math inline">\(A\)</span>也可以给<span class="math inline">\(B\)</span>。</p><p>最后对于每个询问，减去至少要选的，剩下的从奇数组里面选<span class="math inline">\(\binom{n}{m}\)</span>个，乘上一个<span class="math inline">\(2\)</span>的幂次的系数就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000020</span>, p = N - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> a[N], q;<br>ll n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % p) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % p;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a[n] * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(a[n - m], p - <span class="hljs-number">2</span>) % p * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(a[m], p - <span class="hljs-number">2</span>) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll n, ll m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">solve</span>(n / p, m / p) * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(n % p, m % p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %d&quot;</span>, &amp;n, &amp;q);<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) a[i] = a[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % p;<br>ll len = <span class="hljs-number">0</span>, two = <span class="hljs-number">1</span>, pp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span> &lt;= (n &gt;&gt; i); i++) &#123;<br>    ll l = n &gt;&gt; (i + <span class="hljs-number">1</span>), r = n &gt;&gt; i, cnt = ((r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) - ((l + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) len += ((i + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) * cnt, two = two * <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, cnt % (p - <span class="hljs-number">1</span>)) % p;<br>    <span class="hljs-keyword">else</span> len += (i &gt;&gt; <span class="hljs-number">1</span>) * cnt, pp += cnt;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>    ll x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>    <span class="hljs-keyword">if</span> (x &lt; len || x &gt; len + pp) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">solve</span>(pp, x - len) * two % p);<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="粉丝">粉丝</h2><p>众所周知，qjd 有很多很多的粉丝，小 w 便是 qjd 的脑残粉之一。</p><p>又到了一年粉丝见面会的日子，qjd 委托小 w 帮他准备一下粉丝见面会的相关事宜，其中有一项便是座位的编排 总共有 <span class="math inline">\(n\)</span> 位粉丝会来参加见面会，为了便于大家观赏英俊潇洒、风流倜傥、一表人才、玉树临风、气宇轩昂、温文尔雅、风度翩翩的 qjd，qjd 希望把这总共 <span class="math inline">\(n\)</span> 个座位分成 <span class="math inline">\(k\)</span> 组（<span class="math inline">\(k\)</span> 是任意正整数），设第 <span class="math inline">\(i\)</span> 组有 <span class="math inline">\(s-i\)</span> 个座位，那么他需要满足: <span class="math inline">\(\forall 1 \le i ; k,s-i \le s-{i+1}\)</span> <span class="math inline">\(x \le s-1 \le y\)</span> 其中，<span class="math inline">\(x,y\)</span> 是给定正整数。 由于小 w 已经帮忙安排过很多次 qjd 的粉丝见面会了，所以他很快就给出了一个不错的方案。然而 qjd 对此却不屑一顾，便又问：那你能算出总共有多少种合法的方案吗？小 w 懵逼了，因为他连怎么从 <span class="math inline">\(1\)</span> 数到 <span class="math inline">\(100\)</span> 都不会！ 于是他来寻求你的帮助，为了方便，qjd 会给定一个正整数 <span class="math inline">\(P\)</span>，你只要输出答案对 <span class="math inline">\(P\)</span> 取模的结果即可。</p><p>考虑可以拆成只有 <span class="math inline">\(≥x\)</span>的限制,用<span class="math inline">\(≥x\)</span>的答案减去<span class="math inline">\(≥y+1\)</span>的答案。</p><p>直接<span class="math inline">\(dp\)</span>的话，用<span class="math inline">\(f[i][j]\)</span>表示枚举到<span class="math inline">\(i\)</span>，总和为<span class="math inline">\(j\)</span>的方案数，类似于背包，复杂度为<span class="math inline">\(O(n^2)\)</span></p><p>分别用 <span class="math inline">\(≤\sqrt n\)</span> 的数和 <span class="math inline">\(&gt;\sqrt n\)</span> 的数进行划分<span class="math inline">\(n\)</span>的<span class="math inline">\(dp\)</span>，最后枚举其中一个的和，把两部分的方案数合并。</p><p>两种划分数的<span class="math inline">\(dp\)</span>：</p><p>一种<span class="math inline">\(f(i,j)\)</span>表示当前 <span class="math inline">\(dp\)</span> 到数字 <span class="math inline">\(i\)</span>，总和为 <span class="math inline">\(j\)</span>。 每次枚举选了多少个<span class="math inline">\(i\)</span>,转移方程为<span class="math inline">\(f[i][j]=f[i-1][j]+f[i][j-i]\)</span></p><p>一种<span class="math inline">\(g(i,j)\)</span>表示当前总共分成了<span class="math inline">\(i\)</span>个数字，总和为<span class="math inline">\(j\)</span>，转移方程为<span class="math inline">\(g[i][j]=g[i-1][j]+g[i][j-i]\)</span> 。</p><p>可以看出，两部分转移方程都是一样的，但理解的方式有些差异。</p><p>第一种类似于完全背包，不记录选了多少个数。</p><p>第二种因为要把每个数加 <span class="math inline">\(\sqrt n +1\)</span>，总和最后要发生变化，所以要记录选出多少个数，以便统计总和的增加值。</p><p>把每个数减去<span class="math inline">\(\sqrt n +1\)</span>后 , <span class="math inline">\(g(i,j)\)</span>可以理解为把<span class="math inline">\(j\)</span>个相同的球，放入<span class="math inline">\(i\)</span>个相同的箱子，允许空箱的方案数。</p><p>有两种选择，一个是把所有箱子都放一个球，这样的话就和 <span class="math inline">\(g[i][j-i]\)</span>相同。另一种是新开一个空箱子，也就是<span class="math inline">\(g[i][j]=g[i-1][j]\)</span>。</p><p>因为每一种放球的情况和每次放球的操作一一对应，所以可以用<span class="math inline">\(g[i][j]=g[i-1][j]+g[i][j-i]\)</span> 来转移方案数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, x, y, p, sqr, f[N], h[N], g[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> limit = <span class="hljs-built_in">max</span>(x, sqr);<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> h);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt;= limit; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= n; j++) f[j] = (f[j] + f[j - i]) % p;<br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; h[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / limit; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>    <span class="hljs-keyword">if</span> (j &gt;= i) g[j] = (g[j] + g[j - i]) % p;<br>    <span class="hljs-keyword">if</span> (j + i * (limit + <span class="hljs-number">1</span>) &lt;= n) h[j + i * (limit + <span class="hljs-number">1</span>)] = (h[j + i * (limit + <span class="hljs-number">1</span>)] + g[j]) % p;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) res = (res + f[i] * <span class="hljs-number">1ll</span> * h[n - i] % p) % p;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;x, &amp;y, &amp;n, &amp;p);<br>    sqr = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n + <span class="hljs-number">0.5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ((<span class="hljs-built_in">solve</span>(x) - <span class="hljs-built_in">solve</span>(y + <span class="hljs-number">1</span>) % p + p) % p)), <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><p>qjd 拿到了一个长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(S\)</span>！ 因为这个字符串长得很菜，所以 qjd 决定把这个字符串五马分尸。即，他要把这个 <span class="math inline">\(S\)</span> 分成五段，也就是找到五个字符串 <span class="math inline">\(A,B,C,D,E\)</span>，使得 <span class="math inline">\(A+B+C+D+E=S\)</span>，其中 <span class="math inline">\(+\)</span> 表示把两个字符串连接起来。 注意 qjd 不一定恰好要把它分成五段，即 <span class="math inline">\(A,B,C,D,E\)</span> 中可以有空串。 接下来，qjd 会把 <span class="math inline">\(A+C+E\)</span> 作为一个新的字符串 <span class="math inline">\(T\)</span>，他希望这个字符串是回文的，并且他希望 <span class="math inline">\(T\)</span> 越长越好。由于 qjd 是个大鸽子，你能来帮帮他完成这个任务吗？形式化的，你需要最大化 <span class="math inline">\(|A|+|C|+|E|\)</span>，使得 <span class="math inline">\(A+C+E\)</span> 是个回文串。</p><p>感觉很难的一道题。</p><p>首先把两边能选的先选调。</p><p>剩下部分再选一个回文串出来。</p><p>先马拉车预处理一下每个中心点的最长回文串。</p><p>因为还可以和一端的前缀接上一些字符，反串跑一下<span class="math inline">\(kmp\)</span>，反串的某个前缀和正串前缀的<span class="math inline">\(\text{boder}\)</span>相当于正串某个后缀的前缀和前缀的最长回文串长度。</p><p>考虑一下回文串是前缀的情况再单独延伸一段，和回文串后面接一段两种情况。</p><p>一开始去两端时也有两种情况，要看哪一段不能继续延伸，正反串交换跑一下就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">1e6</span> +<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> mid, rad, r[N * <span class="hljs-number">2</span>], f[N], g[N], mx[N], n;<br><span class="hljs-keyword">char</span> ms[N * <span class="hljs-number">2</span>], s[N], sr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sr)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    ms[i * <span class="hljs-number">2</span>] = s[i];<br>    ms[i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>    ms[n + n + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>, ms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;&amp;&#x27;</span>;<br>    mid = <span class="hljs-number">0</span>, rad = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + n + <span class="hljs-number">1</span>; i++) &#123;<br>    r[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i &lt;= mid + rad) r[i] = <span class="hljs-built_in">min</span>(r[mid + mid - i], mid + rad - i);<br>    <span class="hljs-keyword">for</span> (; ms[i - r[i] - <span class="hljs-number">1</span>] == ms[i + r[i] + <span class="hljs-number">1</span>]; r[i]++);<br>    <span class="hljs-keyword">if</span> (i + r[i] &gt; mid + rad) mid = i, rad = r[i];<br>    &#125;<br>   <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>       <span class="hljs-keyword">while</span> (j &amp;&amp; s[j + <span class="hljs-number">1</span>] != s[i]) j = f[j];<br>       j += s[j + <span class="hljs-number">1</span>] == s[i];<br>       f[i] = j;<br>   &#125;<br>   <span class="hljs-built_in">memset</span>(mx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mx);<br>   j = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">while</span> (j &amp;&amp; s[j + <span class="hljs-number">1</span>] != sr[i]) j = f[j];<br>      j += s[j + <span class="hljs-number">1</span>] == sr[i];<br>      g[i] = j; mx[i] = <span class="hljs-built_in">max</span>(mx[i - <span class="hljs-number">1</span>], g[i]);<br>   &#125;<br>   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">int</span> len = (r[i + i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>), k = g[n - i - len];<br>       res = <span class="hljs-built_in">max</span>(res, r[i + i + <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> * <span class="hljs-built_in">min</span>(k, i - len));<br>       <span class="hljs-keyword">if</span> (mx[n - i - len] &gt;= i - len) res = <span class="hljs-built_in">max</span>(res, r[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] + i + i - len - len);<br>   &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>       <span class="hljs-keyword">int</span> len = (r[i + i] / <span class="hljs-number">2</span>), k = g[n - i - len];<br>       res = <span class="hljs-built_in">max</span>(res, r[i + i] + <span class="hljs-number">2</span> * <span class="hljs-built_in">min</span>(k, i - len - <span class="hljs-number">1</span>));<br>       <span class="hljs-keyword">if</span> (mx[n - i - len] &gt;= i - len - <span class="hljs-number">1</span>) res = <span class="hljs-built_in">max</span>(res, r[<span class="hljs-number">2</span> * i] + i + i - len - len - <span class="hljs-number">2</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r &amp;&amp; s[l] == s[r]) l++, r--, p++, p++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) s[i + <span class="hljs-number">1</span> - l] = s[i];<br>    n -= p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) sr[i] = s[n - i + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">solve</span>(s, sr), <span class="hljs-built_in">solve</span>(sr, s)) + p), <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
      <tag>kmp</tag>
      
      <tag>马拉车算法</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020.10.17 T3 pig</title>
    <link href="/2020/10/18/2020.10.17_T3_pig/"/>
    <url>/2020/10/18/2020.10.17_T3_pig/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>小七养了很多头猪，它们分布在 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列中，其中第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列的猪圈养的是第 <span class="math inline">\(w-{i,j}\)</span> 种猪。 <span id="more"></span> 小七有时会选择一个子矩形范围内的猪圈进行巡视，如果该子矩形包含 $i $行 $j $列 <span class="math inline">\((1 ≤ i ≤ n, 1 ≤ j ≤ m)\)</span>，且子矩形内含有的猪种类编号最大值减去编号最小值恰好为 <span class="math inline">\(i × j-1\)</span> ，则小七会获得 <span class="math inline">\(i × j\)</span> 的愉悦值。</p><p>小七想知道，如果他将每个可能的子矩形都巡视一次，总共能获得多少愉悦 值呢？你只需要输出答案对 <span class="math inline">\(998244353\)</span> 取模的结果。</p><h2 id="分析">分析</h2><p>考虑判定权值在区间 <span class="math inline">\([l,r]\)</span> 内的所有数所在的格子是否形成了一个矩形，记这些格子的颜色为黑色，其它的格子颜色为白色。</p><p>考虑所有的 <span class="math inline">\((n + 1) × (m + 1)\)</span> 个 <span class="math inline">\(2 × 2\)</span> 的小正方形 (部分超出边界也算)，则所有黑色格子形成一个矩形，当且仅当恰好有 <span class="math inline">\(4\)</span> 个小正方形内部有 <span class="math inline">\(1\)</span> 个黑色格子，并且没有任何一个小正方形内部有 <span class="math inline">\(3\)</span> 个黑色格子。</p><p>从小到大枚举 <span class="math inline">\(r\)</span> ，对每个 <span class="math inline">\(l ≤ r\)</span> ，记 <span class="math inline">\(f(l)\)</span> 表示染黑权值在 <span class="math inline">\([l,r]\)</span> 内的格子后，有多少小正方形内部有 <span class="math inline">\(1\)</span> 个或 <span class="math inline">\(3\)</span> 个黑色格子。</p><p>可以发现有 $f(l) ≥ 4, f(r) = 4 $，于是只需要对每个 <span class="math inline">\(l\)</span> 维护 <span class="math inline">\(f(l)\)</span> 最小值，最小值的数目和取得最小值的所有 <span class="math inline">\(l\)</span> 之和。</p><p>每次 <span class="math inline">\(r\)</span> 增加 <span class="math inline">\(1\)</span> 时，会影响到周边的 $4 $个 <span class="math inline">\(2×2\)</span> 的小正方形，在线段树上修改即可。</p><p>时间复杂度 <span class="math inline">\(O(nm log nm)\)</span> ，期望得分 <span class="math inline">\(100\)</span> 分。</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>奇技淫巧</tag>
      
      <tag>线段树</tag>
      
      <tag>shu&#39;ju&#39;jie&#39;g</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020.10.17 T2 fight</title>
    <link href="/2020/10/18/2020.10.17_T2_fight/"/>
    <url>/2020/10/18/2020.10.17_T2_fight/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>小七擅长泰拳，某天他打算与小枣切磋拳技，一共需要进行 <span class="math inline">\(n\)</span> 次比赛。</p><p>由于双方拳技难分上下，每场比赛小七获胜或落败的概率都是 <span class="math inline">\(\dfrac{1}{p+2}\)</span> ，平局 的概率是 <span class="math inline">\(\dfrac{p}{p+2}\)</span> 。 <span id="more"></span> 若最后小七获胜场数大于落败场次，且平局次数为$ k$ ，则能获得 <span class="math inline">\(k + 1\)</span> 奖励分。</p><p>小七想知道，他能获得的奖励分的期望是多少呢？为了避免精度误差，你需 要输出答案在模 <span class="math inline">\(998244353\)</span> 意义下的结果。</p><h2 id="分析">分析</h2><p>为了方便，可以假定胜，负各有 <span class="math inline">\(1\)</span> 种方案，平局有 <span class="math inline">\(p\)</span> 种方案，最后将答案乘上$(p + 2)^{-n} $即可。</p><p>枚举有 <span class="math inline">\(i\)</span> 次胜或负，有 <span class="math inline">\(n-i\)</span> 场平局，此时胜场大于负场的方案数是 <span class="math inline">\((x + x^{-1})^i\)</span>展开后次数 <span class="math inline">\(&gt; 0\)</span> 的项系数之和，即 <span class="math inline">\((x^2 + 1)^i\)</span> 展开后次数$ &gt; i$ 的项系数之和。</p><p>将 <span class="math inline">\((x^2 + 1)^i\)</span> 用二项式定理直接展开并计算答案，时间复杂度 <span class="math inline">\(O(n^2)\)</span> ，期望得分<span class="math inline">\(40\)</span> 分。</p><hr /><p>考虑优化计算 <span class="math inline">\((x^2 + 1)^i\)</span> 展开后次数 <span class="math inline">\(&gt; i\)</span> 的项系数之和，记其为 <span class="math inline">\(t(i)\)</span>。</p><p>用二项式定理可以得到 $t(i) = ∑^{i}-{j=0}[2j &gt; i] x^{2j} $。当 <span class="math inline">\(i\)</span> 为奇数时，每个 $2j &gt; i $的一定对应了一个 $2(i-j) &lt; i $，</p><p>所以 <span class="math inline">\(t(i)\)</span> 一定是所有系数之和的一半，即 <span class="math inline">\(t(i) = 2^{i-1}\)</span> 。当 <span class="math inline">\(i\)</span> 为偶数时，只需要减掉 $j =  <span class="math inline">\(这一项系数，剩下的同样一一对 应，\)</span>t(i) =  $。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span> ，期望得分 <span class="math inline">\(100\)</span> 分。</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
      <tag>二项式定理</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HAOI2018 奇怪的背包</title>
    <link href="/2020/10/18/HAOI2018_%E5%A5%87%E6%80%AA%E7%9A%84%E8%83%8C%E5%8C%85/"/>
    <url>/2020/10/18/HAOI2018_%E5%A5%87%E6%80%AA%E7%9A%84%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2524">「HAOI2018」奇怪的背包</a></p></blockquote><p>其实这题和背包一点关系都没有。</p><span id="more"></span><p>题目要求解方程的解数，</p><p><span class="math display">\[\sum x-ia-i\equiv w\pmod p\]</span></p><p>根据裴蜀定理，方程有解当且仅当<span class="math inline">\(\gcd(a-1,a-2,\cdots,a-n,p)\mid w\)</span></p><p>于是设<span class="math inline">\(f[i][j]\)</span>表示前<span class="math inline">\(i\)</span>个数的与<span class="math inline">\(p\)</span>的最大公约数是<span class="math inline">\(j\)</span>时的方案数，转移只需要枚举当前这个选不选，不需要考虑具体选了多少个。</p><p>因为<span class="math inline">\(p\)</span>的约数个数不多，我们应该开一个数组映射一下<span class="math inline">\(p\)</span>的约数作为转移状态的第二维。</p><p>如果两个物体和<span class="math inline">\(p\)</span>的<span class="math inline">\(\gcd\)</span>相等的话，我们可以把它们一起转移，只需要乘上一个非空子集个数的系数就可以了。</p><p>最后统计答案，其实我们要统计的是<span class="math inline">\(\sum-{i\mid w}f[m][i]\)</span>，<span class="math inline">\(m\)</span>是<span class="math inline">\(p\)</span>约数个数</p><p>即<span class="math inline">\(i\mid p \wedge i\mid w\)</span>，相当于<span class="math inline">\(i\mid \gcd(p,w)\)</span></p><p>于是可以先预处理出<span class="math inline">\(w\mid p\)</span>时的答案，即可以<span class="math inline">\(\mathcal{O}((m^2 + n + q) \log p)-\mathcal{O}(1)\)</span>的时间复杂度完成此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2000</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> d[N], n, m, p, q, bit[<span class="hljs-number">1000005</span>], f[N][N], cnt[N], ans[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> lower-<span class="hljs-built_in">bound</span>(d + <span class="hljs-number">1</span>, d + m + <span class="hljs-number">1</span>, x) - d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;q, &amp;p);<br>    bit[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) bit[i] = bit[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2ll</span> % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p / i; i++) <span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>) &#123;<br>        d[++m] = i;<br>        <span class="hljs-keyword">if</span> (i * i != p) d[++m] = p / i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(d + <span class="hljs-number">1</span>, d + m + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    cnt[<span class="hljs-built_in">pos</span>(<span class="hljs-built_in">gcd</span>(x, p))]++;<br>    &#125;<br>    f[<span class="hljs-number">0</span>][m] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>    <span class="hljs-keyword">int</span> g = <span class="hljs-built_in">pos</span>(<span class="hljs-built_in">gcd</span>(d[i], d[j]));<br>    f[i][g] = (f[i][g] + f[i - <span class="hljs-number">1</span>][j] * <span class="hljs-number">1ll</span> * (bit[cnt[i]] - <span class="hljs-number">1</span>) % MOD) % MOD;<br>    f[i][j] = (f[i][j] + f[i - <span class="hljs-number">1</span>][j]) % MOD;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) <span class="hljs-keyword">if</span> (d[i] % d[j] == <span class="hljs-number">0</span>) &#123;<br>    ans[i] = (ans[i] + f[m][j]) % MOD;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= q; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[<span class="hljs-built_in">pos</span>(<span class="hljs-built_in">gcd</span>(p, x))]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>gcd</tag>
      
      <tag>同余方程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数分解为2的幂</title>
    <link href="/2020/10/18/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA2%E7%9A%84%E5%B9%82/"/>
    <url>/2020/10/18/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA2%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>好久就没更博了，发个题解证明我还活着。</p></blockquote><p>题号是<span class="math inline">\(\text{51nod}\)</span> <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1383">1383</a>和<a href="https://www.51nod.com/Challenge/Problem.html#problemId=1048">1048</a></p><span id="more"></span><h2 id="nle-106"><span class="math inline">\(n\le 10^6\)</span></h2><p>这档分<span class="math inline">\(\mathcal{O}(n\log n)\)</span>或者<span class="math inline">\(\mathcal{O}(n)\)</span>都可以。</p><p><span class="math inline">\(\log\)</span>的是用<span class="math inline">\(2\)</span>的幂跑一次完全背包</p><p>线性的考虑每个数从为空的序列开始是通过<span class="math inline">\(+1\)</span>或者集体<span class="math inline">\(\times 2\)</span>得到的。</p><p><span class="math inline">\(f[i]=(i\&amp;1)?0:f[i/2]+f[i-1]\)</span></p><h2 id="nle-1030"><span class="math inline">\(n\le 10^{30}\)</span></h2><p>我们先考虑每个二的整数幂有多少种方法凑出来。</p><p><span class="math inline">\(f[i][j]\)</span>表示最大数是<span class="math inline">\(2^j\)</span>的数凑出<span class="math inline">\(2^i\)</span>的方案数。</p><p>如果<span class="math inline">\(f[i][j]=\sum-{k=0}^jf[i-1][k]\times f[i-1][j]\)</span></p><p>显然在会算重</p><p>我们强行让后面方案用的数都大于前面的</p><p>也就是去掉小于<span class="math inline">\(2^k\)</span>产生的贡献，<span class="math inline">\(f[i-k-1][j-k]\)</span>也就是所有数除了<span class="math inline">\(2^k\)</span></p><p><span class="math inline">\(f[i][j]=\sum-{k=0}^jf[i-1][k]\times f[i-k-1][j-k]\)</span></p><p>我们要利用<span class="math inline">\(f\)</span>来计算答案</p><p>我们考虑<span class="math inline">\(2\)</span>进制下，<span class="math inline">\(g[i][j]\)</span>表示用最大数是<span class="math inline">\(2^j\)</span>的数凑前<span class="math inline">\(i\)</span>位的方案数</p><p><span class="math inline">\(g[i][j]=\sum-{k=0}^jg[i-1][k]\times f[i-k][j-k]\)</span></p><p>注意某一位是<span class="math inline">\(1\)</span>的时候才需要更新<span class="math inline">\(g\)</span>数组，应该记录一下<span class="math inline">\(g\)</span>的第一维更新了多少次。</p><p>其实还没有做完...</p><p>因为出题人<del>十(sang)分(xin)友(bing)好(kuang)</del>不给模数，所以你还得写个压位高精。</p><p>说实话这东西我找了好久的板子，因为我不会写高精度...</p><p><span class="math inline">\(\text{oi-wiki}\)</span>上面那个封装好的高精度有点问题，高精度乘法模板都过不了</p><p>高精度模板放在代码里面了</p><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Wint</span>:</span>vector&lt;ll&gt;<br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> ll BIT=<span class="hljs-number">1e8</span>;<br>    <span class="hljs-built_in">Wint</span>(ll n=<span class="hljs-number">0</span>) &#123;push-<span class="hljs-built_in">back</span>(n);<span class="hljs-built_in">check</span>();&#125;<br>    Wint&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* num)<br>    &#123;<br>        <span class="hljs-keyword">int</span> Len=<span class="hljs-built_in">strlen</span>(num)<span class="hljs-number">-1</span>; <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Len;i&gt;=<span class="hljs-number">0</span>;i-=<span class="hljs-number">9</span>)<br>        &#123;<br>            push-<span class="hljs-built_in">back</span>(<span class="hljs-number">0</span>); ll w=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;i<span class="hljs-number">-9</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>;--j)<br>                <span class="hljs-built_in">back</span>()+=(num[j]^<span class="hljs-number">48</span>)*w,w*=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function">Wint&amp; <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;!<span class="hljs-built_in">back</span>()) pop-<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">size</span>();++i)<br>            (*<span class="hljs-keyword">this</span>)[i]+=(*<span class="hljs-keyword">this</span>)[i<span class="hljs-number">-1</span>]/BIT,<br>            (*<span class="hljs-keyword">this</span>)[i<span class="hljs-number">-1</span>]%=BIT;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">back</span>()&gt;=BIT)<br>        &#123;<br>            push-<span class="hljs-built_in">back</span>(<span class="hljs-built_in">back</span>()/BIT);<br>            (*<span class="hljs-keyword">this</span>)[<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>]%=BIT;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Wint a,Wint b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i]) <span class="hljs-keyword">return</span> a[i]&lt;b[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> b&lt;a;&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> !(a&gt;b);&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> !(a&lt;b);&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> a&lt;b||b&lt;a;&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> !(a&lt;b)&amp;&amp;!(b&lt;a);&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>+=(Wint &amp;a,Wint b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>()) a.<span class="hljs-built_in">resize</span>(b.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;b.<span class="hljs-built_in">size</span>();++i) a[i]+=b[i];<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>+(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> a+=b;&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>-=(Wint &amp;a,Wint b)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;b.<span class="hljs-built_in">size</span>();a[i]-=b[i],++i)<br>        <span class="hljs-keyword">if</span>(a[i]&lt;b[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(!a[j]) ++j;<br>            <span class="hljs-keyword">while</span>(j&gt;i) --a[j],a[--j]+=Wint::BIT;<br>        &#125;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>-(Wint a,Wint b) &#123;<span class="hljs-keyword">return</span> a-=b;&#125;<br>Wint <span class="hljs-keyword">operator</span>*(Wint a,Wint b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">empty</span>()&amp;&amp;b.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> a;<br>    Wint n; n.<span class="hljs-built_in">assign</span>(a.<span class="hljs-built_in">size</span>()+b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;b.<span class="hljs-built_in">size</span>();++j)<br>            n[i+j]+=a[i]*b[j];<br>    <span class="hljs-keyword">return</span> n.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>*=(Wint &amp;a,Wint b) &#123;<span class="hljs-keyword">return</span> a=a*b;&#125;<br>Wint <span class="hljs-keyword">operator</span>/(Wint a,<span class="hljs-keyword">int</span> b)<br>&#123;<br>    Wint n; <span class="hljs-keyword">bool</span> wp=<span class="hljs-number">0</span>; ll t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>    &#123;<br>        t=t*Wint::BIT+a[i];<br>        <span class="hljs-keyword">if</span>(wp||t/b) wp=<span class="hljs-number">1</span>,n.push-<span class="hljs-built_in">back</span>(t/b);<br>        t%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(n.<span class="hljs-built_in">begin</span>(),n.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>/=(Wint &amp;a,<span class="hljs-keyword">int</span> b) &#123;<span class="hljs-keyword">return</span> a=a/b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readX</span><span class="hljs-params">(Wint &amp;n)</span> </span>&#123;<span class="hljs-keyword">char</span> s[<span class="hljs-number">1000</span>]; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s); n=s;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeX</span><span class="hljs-params">(Wint n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">int</span> Len=n.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,n[Len]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08lld&quot;</span>,n[i]);<br>&#125;<br><br><span class="hljs-keyword">typedef</span> --int128 i128;<br>i128 n;<br>Wint f[<span class="hljs-number">142</span>][<span class="hljs-number">142</span>], g[<span class="hljs-number">142</span>][<span class="hljs-number">142</span>];<br><br><span class="hljs-function">i128 <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>i128 w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::sync-with-<span class="hljs-built_in">stdio</span>(<span class="hljs-literal">false</span>);<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">int</span> limit = <span class="hljs-number">100</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= limit; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>    <span class="hljs-keyword">if</span> (j == i) f[i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= j; k++) f[i][j] = f[i][j] + f[i - <span class="hljs-number">1</span>][k] * f[i - <span class="hljs-number">1</span> - k][j - k];<br>    &#125;<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= limit; i++) &#123;<br>    <span class="hljs-keyword">if</span> ((n &gt;&gt; (i128)(i)) &amp; <span class="hljs-number">1</span>) &#123;<br>            ++cnt;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= j; k++) g[cnt][j] = g[cnt][j] + g[cnt - <span class="hljs-number">1</span>][k] * f[i - k][j - k];<br>            &#125;<br>    &#125;<br>    &#125;<br>    Wint res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= limit; i++) res = res + g[cnt][i];<br>    <span class="hljs-built_in">writeX</span>(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Amount of Degrees</title>
    <link href="/2020/10/14/Amount_of_Degrees/"/>
    <url>/2020/10/14/Amount_of_Degrees/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10163">Amount of Degrees</a><br /><span id="more"></span> 这篇博客是来贴代码的，真正的题解看<a href="https://wenku.baidu.com/view/d2414ffe04a1b0717fd5dda8.html">这里</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">int</span> f[N][N], k, b, l, r, a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i; i--) &#123;<br><span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>            tot++;<br>            <span class="hljs-keyword">if</span> (tot &gt; k) <span class="hljs-keyword">break</span>;<br>            x ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>&#125;<br><span class="hljs-keyword">if</span> (x &gt;= (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))) ans += f[i - <span class="hljs-number">1</span>][k - tot];<br>&#125;<br><span class="hljs-keyword">if</span> (tot + x == k) ans++;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x) &#123;<br>a[cnt++] = x % b;<br>x /= b;<br>&#125;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cnt - <span class="hljs-number">1</span>; i + <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j + <span class="hljs-number">1</span>; j--) res |= (<span class="hljs-number">1</span> &lt;&lt; j);<br>        &#125; <span class="hljs-keyword">else</span> res |= (a[i] &lt;&lt; i);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k, &amp;b);<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>    f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">solve</span>(<span class="hljs-built_in">calc</span>(r, b)) - <span class="hljs-built_in">solve</span>(<span class="hljs-built_in">calc</span>(l - <span class="hljs-number">1</span>, b)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数位dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ivan Pesic and His World Tour</title>
    <link href="/2020/10/14/Ivan_Pesic_and_His_World_Tour/"/>
    <url>/2020/10/14/Ivan_Pesic_and_His_World_Tour/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.codechef.com/LTIME73A/problems/QRYLAND">题目链接</a></p></blockquote><h2 id="题目">题目</h2><p>给定一颗 <span class="math inline">\(n\)</span> 个点的树。每个点都一个正整数点权 <span class="math inline">\(Ai\)</span> ，你需要支持以下两种操作： <span id="more"></span> 1、询问点 <span class="math inline">\(x\)</span> 和点 <span class="math inline">\(y\)</span> 之间的路径上的所有点（包括点 <span class="math inline">\(x\)</span> 和点 <span class="math inline">\(y\)</span> ）的点权是否构成一个从 <span class="math inline">\(1\)</span> 开始的排列（即若这条链长度为 <span class="math inline">\(len\)</span> ，那么问点权集合是否为 <span class="math inline">\({1,2,⋯,len}\)</span> ）。</p><p>2、将 <span class="math inline">\(Ax\)</span> 修改为 <span class="math inline">\(y\)</span> 。</p><h2 id="题解">题解</h2><p>这道题就是把<a href="https://darkbzoj.tk/problem/4373">BZOJ4373</a>上树的版本。<br />判一个排列直接用自然数幂之和或者是异或和 + hash</p><p>有个坑点，当然是对我来说。。。 我用的自然溢出，所以不能随便除数的，所以不应该这么算自然数幂之和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ull <span class="hljs-title">su1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> (x + <span class="hljs-number">1ull</span>) * <span class="hljs-number">1ull</span> * x / <span class="hljs-number">2ull</span>;&#125;<br><span class="hljs-function">ull <span class="hljs-title">su2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x * <span class="hljs-number">1ull</span> * (ull)(x + <span class="hljs-number">1</span>) * <span class="hljs-number">1ull</span> * (ull)(x + x + <span class="hljs-number">1</span>) / <span class="hljs-number">6</span>;&#125;<br><span class="hljs-function">ull <span class="hljs-title">su3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x * <span class="hljs-number">1ull</span> * (ull)(x + <span class="hljs-number">1</span>) * <span class="hljs-number">1ull</span> * x * <span class="hljs-number">1ull</span> * (ull)(x + <span class="hljs-number">1</span>) / <span class="hljs-number">4ull</span>;&#125;<br></code></pre></td></tr></table></figure> 自然溢出相当于<span class="math inline">\(\%2^{64}\)</span>，显然溢出了不能随便除</p><p>直接预处理自然数幂之和不就完了。。。。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ull i = <span class="hljs-number">1</span>; i &lt; N; i++) su1[i] = su1[i - <span class="hljs-number">1</span>] + i, su2[i] = su2[i - <span class="hljs-number">1</span>] + i * i, su3[i] = su3[i - <span class="hljs-number">1</span>] + i * i * i;<br>```  <br><br>## 代码<br>```cpp<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, q, head[N], cnt, a[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v;<br>&#125; e[N &lt;&lt; <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v&#125;; head[u] = cnt;<br>e[++cnt] = &#123;head[v], u&#125;; head[v] = cnt;<br>&#125;<br><br>ull sum2[N &lt;&lt; <span class="hljs-number">2</span>], sum3[N &lt;&lt; <span class="hljs-number">2</span>], su1[N], su2[N], su3[N];<br>ll sum[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> dep[N], rnk[N], dfn[N], fa[N], top[N], son[N], dfs-clock, siz[N];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson (p &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson ((p &lt;&lt; 1) | 1)</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>sum[p] = a[rnk[l]];<br>sum2[p] = a[rnk[l]] * <span class="hljs-number">1ull</span> * a[rnk[l]];<br>sum3[p] = a[rnk[l]] * <span class="hljs-number">1ull</span> * a[rnk[l]] * <span class="hljs-number">1ull</span> * a[rnk[l]];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">build</span>(lson, l, mid);<br><span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>sum[p] = sum[lson] + sum[rson];<br>sum2[p] = sum2[lson] + sum2[rson];<br>sum3[p] = sum3[lson] + sum3[rson];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>sum[p] = v;<br>sum2[p] = v * <span class="hljs-number">1ull</span> * v;<br>sum3[p] = v * <span class="hljs-number">1ull</span> * v * <span class="hljs-number">1ull</span> * v;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (pos &lt;= mid) <span class="hljs-built_in">modify</span>(lson, l, mid, pos, v);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(rson, mid + <span class="hljs-number">1</span>, r, pos, v);<br>sum[p] = sum[lson] + sum[rson];<br>sum2[p] = sum2[lson] + sum2[rson];<br>sum3[p] = sum3[lson] + sum3[rson];<br>&#125;<br>ll qry-<span class="hljs-built_in">sum</span>(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> sum[p];<br><span class="hljs-keyword">return</span> qry-<span class="hljs-built_in">sum</span>(lson, l, mid, L, R) + qry-<span class="hljs-built_in">sum</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R);<br>&#125;<br>ull qry-<span class="hljs-built_in">sum2</span>(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> sum2[p];<br><span class="hljs-keyword">return</span> qry-<span class="hljs-built_in">sum2</span>(lson, l, mid, L, R) + qry-<span class="hljs-built_in">sum2</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R);<br>&#125;<br>ull qry-<span class="hljs-built_in">sum3</span>(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> sum3[p];<br><span class="hljs-keyword">return</span> qry-<span class="hljs-built_in">sum3</span>(lson, l, mid, L, R) + qry-<span class="hljs-built_in">sum3</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    fa[u] = f; siz[u] = <span class="hljs-number">1</span>; son[u] = <span class="hljs-number">-1</span>; dep[u] = dep[f] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v, u);<br>        siz[u] += siz[v];<br>        <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">-1</span> || siz[v] &gt; siz[son[u]]) son[u] = v;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    top[u] = t; dfn[u] = ++dfs-clock; rnk[dfs-clock] = u;<br>    <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u], t);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v, v);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">int</span> len = dep[u] + dep[v];<br>    ull res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>, res3 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br><span class="hljs-keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) <span class="hljs-built_in">swap</span>(u, v);<br>res1 = res1 + qry-<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]);<br>res2 = res2 + qry-<span class="hljs-built_in">sum2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]);<br>res3 = res3 + qry-<span class="hljs-built_in">sum3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]);<br>u = fa[top[u]];<br>&#125;<br><span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>res1 = res1 + qry-<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[v], dfn[u]);<br>res2 = res2 + qry-<span class="hljs-built_in">sum2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[v], dfn[u]);<br>res3 = res3 + qry-<span class="hljs-built_in">sum3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[v], dfn[u]);<br>len -= <span class="hljs-number">2</span> * dep[v] - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> ((res1 == su1[len]) &amp;&amp; (res2 == su2[len]) &amp;&amp; (res3 == su3[len]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> -;<br><span class="hljs-keyword">for</span> (ull i = <span class="hljs-number">1</span>; i &lt; N; i++) su1[i] = su1[i - <span class="hljs-number">1</span>] + i, su2[i] = su2[i - <span class="hljs-number">1</span>] + i * i, su3[i] = su3[i - <span class="hljs-number">1</span>] + i * i * i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;-); -; ---) &#123;<br>    cnt = <span class="hljs-number">0</span>; dfs-clock = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        <span class="hljs-built_in">add</span>(u, v);<br>        &#125;<br>        <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>        <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-keyword">int</span> op, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;x, &amp;y);<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <span class="hljs-built_in">qry</span>(x, y) ? <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>) : <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
      <tag>树链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1820 长城之旅</title>
    <link href="/2020/10/13/51nod_1820_%E9%95%BF%E5%9F%8E%E4%B9%8B%E6%97%85/"/>
    <url>/2020/10/13/51nod_1820_%E9%95%BF%E5%9F%8E%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1820">长城之旅</a></p></blockquote><p>或许是全网第一篇能看的题解 (?)<br /><span id="more"></span></p><p>首先<span class="math inline">\(\text{lcm}(a,b)=\frac{a\times b}{\gcd(a,b)}\)</span><br />根据定义可以证明。</p><p>关于<span class="math inline">\(\gcd\)</span>的一个结论。<br /><span class="math inline">\(\gcd(k^{2^l}+1,k^{2^r}+1)=(k\&amp; 1)?2:1\ ,r&gt;l\)</span></p><p>分类讨论一下 1. <span class="math inline">\(k\%2=0\)</span>时，假设<span class="math inline">\(k^{2^l}+1\)</span>有约数<span class="math inline">\(d\)</span>，即<span class="math inline">\(k^{2^l}\equiv -1\pmod d\)</span>，又<span class="math inline">\((k^{2^l})^{2^j}=k^{2^{l+j}},j\ge0\)</span>，所以<span class="math inline">\(k^{2^r}\equiv 1\pmod d\)</span>，<span class="math inline">\(k^{2^r}+1\equiv 2\pmod 2\)</span> ，所以<span class="math inline">\(k^{2^l}+1\)</span>的约数都不是<span class="math inline">\(k^{2^r}+1\)</span>的约数，当然<span class="math inline">\(d=2\)</span>需要单独讨论一下，显然<span class="math inline">\(k^{2^l}+1\)</span>是奇数。 2. <span class="math inline">\(k\%2=1\)</span>时，唯一区别是<span class="math inline">\(k^{2^l}+1\)</span>是偶数，<span class="math inline">\(\gcd=2\)</span></p><p>所以做法就比较显然。<br />模数是<span class="math inline">\(2\)</span>的单独处理。</p><p><span class="math inline">\(k\%p=0\)</span>，显然答案是<span class="math inline">\(1\)</span></p><p>其余情况，假设<span class="math inline">\(a=k^{2^l}\)</span><br />则乘积等于<span class="math inline">\((a+1)\times (a^{2^1}+1)\times (a^{2^2}+1)\times ... \times (a^{2^{r-l}}+1)\)</span><br />因为每个括号要不选前一个，要不选后一个，所以最后答案是<span class="math inline">\(\sum-{i=0}^{2^{r-l+1}-1}a^i\)</span>，这东西显然是个等比数列求和。</p><p>注意此时只是算出了所有数乘积，最后如果<span class="math inline">\(k\)</span>时奇数还得除一个<span class="math inline">\(2^{r-l}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>ll k, l, r, p;<br><span class="hljs-keyword">int</span> -;<br><br><span class="hljs-function">ll <span class="hljs-title">fpow</span><span class="hljs-params">(ll a, ll b, ll p)</span> </span>&#123;<br>ll res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % p) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br><span class="hljs-keyword">return</span> res; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;-); -; ---) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld&quot;</span>, &amp;k, &amp;l, &amp;r, &amp;p);<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (k &amp; <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (k % p == <span class="hljs-number">0</span>)<br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>    ll a = <span class="hljs-built_in">fpow</span>(k, <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, l, p - <span class="hljs-number">1</span>), p);<br>            <span class="hljs-keyword">if</span> (a != <span class="hljs-number">1</span>) &#123;<br>                res = <span class="hljs-built_in">fpow</span>(a, <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, r - l + <span class="hljs-number">1</span>, p - <span class="hljs-number">1</span>), p);<br>                res = (res - <span class="hljs-number">1</span> + p) % p;<br>                res = res * <span class="hljs-built_in">fpow</span>((a - <span class="hljs-number">1</span> + p) % p, p - <span class="hljs-number">2</span>, p) % p;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, r - l + <span class="hljs-number">1</span>, p);<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-built_in">fpow</span>(<span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, r - l, p), p - <span class="hljs-number">2</span>, p) % p;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>gcd</tag>
      
      <tag>lcm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1360 K-序列</title>
    <link href="/2020/10/10/51nod_1360_K-%E5%BA%8F%E5%88%97/"/>
    <url>/2020/10/10/51nod_1360_K-%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目">题目</h2><p><img src="http://img.51nod.com/upload/000FBE6E/08D22C601434DFA00000000000000003.png" /></p><p>有Q个查询，对于每一个查询q[i]，请计算S(q[i])%m。 拆一下第二个函数 <span class="math display">\[S((\lfloor\frac{n}{k}\rfloor-1)*k+i)=S((n-k)-n\%k+i)\]</span></p><p>可以发现这个式子按<span class="math inline">\(\mod k\)</span>余数分类后，可以用矩阵乘法来做。</p><blockquote><p>以下来自题解</p></blockquote><p>可以先把数据分块，每K个一块，后一块和前一块之间的关系可以用矩阵来表示。</p><p><img src="http://img.51nod.com/upload/000FBE6E/08D22C690A62DD740000000000000006.png" /></p><p>这个矩阵太大了。直接做矩阵乘法肯定会超时。但是这个矩阵有一个特殊性，使得它的乘法有优化的空间。</p><p><img src="http://img.51nod.com/upload/000FBE6E/08D22C692666EF8E0000000000000007.png" /></p><p>C是一个常数，先预处理，那么就可以在log(qi)的时候内计算出S(qi)的值了。</p><p>复杂度是预处理O(K),查询log(qi)</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵乘法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘</title>
    <link href="/2020/10/08/%E5%A4%87%E5%BF%98/"/>
    <url>/2020/10/08/%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<p>备忘录 &amp; 任务列表 <span id="more"></span></p><h2 id="小技巧">小技巧</h2><h3 id="逆元">逆元</h3><p>线性筛<span class="math inline">\(1-p\)</span>逆元<br />设<span class="math inline">\(t=\lfloor P /i\rfloor\)</span>，<span class="math inline">\(k=P\%i\)</span></p><p><span class="math inline">\(t*i+k\equiv 0 \pmod {P}\)</span><br /><span class="math inline">\(-t*i\equiv k \pmod {P}\)</span><br /><span class="math inline">\(-t*inv[k]\equiv inv[i]\pmod {P}\)</span><br />带回<span class="math inline">\(t,k\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">inv[i]=(P-P/i)*inv[P%i]%P<br></code></pre></td></tr></table></figure></p><h3 id="快速幂">快速幂</h3><p><span class="math inline">\(\mathcal{O}(\sqrt{P})-\mathcal{O}(1)\)</span>快速幂 https://loj.ac/article/1383</p><h2 id="任务列表">任务列表</h2><p>感觉堆了114514份计划，可能写不完了 https://www.luogu.com.cn/problem/P2619 https://loj.ac/problem/2591 https://loj.ac/problem/2212 （ 怎么做啊 https://loj.ac/problem/6342 写了，没看懂<a href="https://loj.ac/problem/6630">加强版</a>，溜了 https://loj.ac/problem/2319 学习了下平衡树的写法，有时间还是用树状数组写写 https://loj.ac/problem/519 https://loj.ac/problem/2318 （写下O(n 3^n)的状压dp （写完了） https://loj.ac/problem/3292（已完成，虽然没很看懂官方题解） http://www.boi2012.lv/data/day1/spoilers/brackets.pdf https://loj.ac/problem/2316 （已完成）</p><h2 id="其他">其他</h2><p>把 NOIP2017 时间复杂度那道大模拟写了。 上次考这题的时候还不知道怎么读字符串。 看第一篇题解看得很感慨。 --11月11日</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莓良心</title>
    <link href="/2020/10/08/%E8%8E%93%E8%89%AF%E5%BF%83/"/>
    <url>/2020/10/08/%E8%8E%93%E8%89%AF%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>莓在执行任务时，收集到了 n 份岩浆能源， <span id="more"></span> 其中第 i 份的能量值是 wi ，她 决定将它们分成恰好 k 组带回基地，每一组都要有至少 1 份能源。 每一组能源会对运输设备产生负荷值，若该组有 x 份能源，这 x 份能源能 量值之和为 y , 则产生的负荷值为 x × y 。 每种分组方案产生的负荷是每一组能源产生的负荷值总和，莓想知道所有可 能的分组方案产生的负荷之和对 998244353 取模的结果。</p><p>每个<span class="math inline">\(w-i\)</span>贡献是<span class="math inline">\(\sum w-i\times |S|\)</span></p><p>也就是一个集合里和每个数配对一下就产生一次贡献。</p><p><span class="math inline">\(w-i\)</span>在所有可能的集合中自己和自己配对<span class="math inline">\(w-i\times \begin{Bmatrix}n \\ k\end{Bmatrix}\)</span><br />枚举和其他点在一个集合<span class="math inline">\((w-i+w-j)\times \begin{Bmatrix}n-1 \\ k\end{Bmatrix}\)</span></p><p><span class="math inline">\(ans=\sum(w-i)(\begin{Bmatrix}n \\ k\end{Bmatrix}+(n-1)\begin{Bmatrix}n-1 \\ k\end{Bmatrix})\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">int</span> n, k, sum, fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % MOD;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> fac[n] * <span class="hljs-number">1ll</span> * ifac[k] % MOD * <span class="hljs-number">1ll</span> * ifac[n - k] % MOD;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;<br><span class="hljs-keyword">int</span> g = (i &amp; <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>        g = g * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(k - i, n) % MOD * <span class="hljs-built_in">C</span>(k, i) % MOD;<br>g = (g + MOD) % MOD;<br>res = (res + g) % MOD;<br>&#125;<br>res = res * <span class="hljs-number">1ll</span> * ifac[k] % MOD;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;ichigo.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;ichigo.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), sum = (sum + x) % MOD;<br>fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % MOD;<br>ifac[n] = <span class="hljs-built_in">fpow</span>(fac[n], MOD - <span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) ifac[i] = ifac[i + <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * (i + <span class="hljs-number">1</span>) % MOD;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum * <span class="hljs-number">1ll</span> * (<span class="hljs-built_in">S</span>(n, k) * <span class="hljs-number">1ll</span> + (n - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">S</span>(n - <span class="hljs-number">1</span>, k) % MOD) % MOD);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD &amp;amp; XOR</title>
    <link href="/2020/09/30/GCD_&amp;amp;_XOR/"/>
    <url>/2020/09/30/GCD_&amp;amp;_XOR/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6231">题目链接</a></p></blockquote><p><del>喜提最快解 (?)</del><br /><span id="more"></span> ## 题目 给定<span class="math inline">\(n,k\)</span> 求满足<span class="math inline">\(\gcd(A-{l\cdots r})\cdot(A-l\ \mathrm{xor} \ A-{l+1}\ \mathrm{xor} \cdots \mathrm{xor} \ A-r)=k\)</span>且字典序最小的<span class="math inline">\(l,r\)</span></p><h2 id="分析">分析</h2><p><del>可以看我前两篇博客</del><br />按照基本方法，枚举右端点<span class="math inline">\(r\)</span><br />然后我们需要什么呢</p><p>每个左端点<span class="math inline">\(l\)</span>对应的区间<span class="math inline">\(\gcd\)</span>和<span class="math inline">\(xor\)</span><br />对于<span class="math inline">\(gcd\)</span>的维护<a href="https://widsnoy.top/archives/115/">看这里</a></p><p><span class="math inline">\(A-l\ \mathrm{xor} \ A-{l+1}\ \mathrm{xor} \cdots \mathrm{xor} \ A-r\)</span>这东西显然是做个异或前缀和<br />因为右端点固定，我们显然求<span class="math inline">\(sum[r]\oplus sum[l-1] =\frac{k}{\gcd}\)</span><br />异或有个好性质<span class="math inline">\(a\oplus b=c\)</span>，则<span class="math inline">\(a\oplus c=b\)</span></p><blockquote><p>update:分析没什么问题，代码有点问题，代码删了。 正确做法还是得记录下每个<span class="math inline">\(xor\)</span>所有的位置，二分一个满足要求的位置更新答案。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>gcd</tag>
      
      <tag>数论</tag>
      
      <tag>xor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVa1642 魔法gcd Magical gcd</title>
    <link href="/2020/09/30/UVa1642_%E9%AD%94%E6%B3%95gcd_Magical_gcd/"/>
    <url>/2020/09/30/UVa1642_%E9%AD%94%E6%B3%95gcd_Magical_gcd/</url>
    
    <content type="html"><![CDATA[<p>题目： luogu: <a href="https://www.luogu.com.cn/problem/UVA1642">UVa1642</a> <span id="more"></span> # solution</p><p>因为要求一个最优的子序列，可以想到枚举这个子序列的右端点<span class="math inline">\(j\)</span>。 那么怎么快速算出左端点<span class="math inline">\(i\)</span>的答案呢？<br />枚举每一个左端点，如果能知道这个子序列所有元素的<span class="math inline">\(gcd\)</span>值就好了。<br />先考虑这样一个序列<span class="math display">\[5,8,8,6,2\]</span>，假设现在<span class="math inline">\(j=4\)</span>,可以算出所有子序列对应的<span class="math inline">\(gcd\)</span>。 1. <span class="math inline">\(i=1\)</span>, <span class="math inline">\(gcd(a-1,a-2,a-3,a-4)=1\)</span> 2. <span class="math inline">\(i=2\)</span>, <span class="math inline">\(gcd(a-2,a-3,a-4)=2\)</span> 3. <span class="math inline">\(i=3\)</span>, <span class="math inline">\(gcd(a-3,a-4)=2\)</span> 4. <span class="math inline">\(i=4\)</span>, <span class="math inline">\(gcd(a-4)=6\)</span></p><p>注意到不同子序列的<span class="math inline">\(gcd\)</span>值有可能是相等的，事实上<span class="math inline">\(gcd\)</span>值的种类最多不会超过<span class="math inline">\(\log-2 a-j\)</span>个，因为<span class="math inline">\(a-j\)</span>的约数个数一定不多于<span class="math inline">\(\log-2 a-j\)</span>。<br />上表从下向上看，每次增加一个元素的时候，<span class="math inline">\(gcd\)</span>值是不变或者减小的，而且变小时一定会变成<span class="math inline">\(a-j\)</span>的一个约数。所以就维护每个左端点对应的区间<span class="math inline">\(gcd\)</span>值(即<span class="math inline">\(gcd(a[i],a[i+1],...,a[j])\)</span>)，增加一个元素(即<span class="math inline">\(j\)</span> -&gt; <span class="math inline">\(j+1\)</span>)时，更新加上该元素后的区间<span class="math inline">\(gcd\)</span>值就可以。<br />知道了当前每个左端点对应的<span class="math inline">\(gcd\)</span>，区间长度也是已知的，就可以计算答案了，对于每个区间的结果取一个最大值。<br />但是直接这样做复杂度是不对的，<span class="math inline">\(O(n^2log n)\)</span>显然过不了。那怎么办呢。 我们可以发现，如果两个左端点的<span class="math inline">\(gcd\)</span>相等，那么<span class="math inline">\(i\)</span>更小的一定会更优，所以直接把劣的删除，对后面不造成影响。这样一来每次要枚举的<span class="math inline">\(i\)</span>就和<span class="math inline">\(gcd\)</span>的个数有关，复杂度是<span class="math inline">\(O(nlog^2 n)\)</span>，可以通过本题。</p><h1 id="code">code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br>ll n, a[N];<br>vector&lt;pair&lt;<span class="hljs-keyword">int</span>, ll&gt; &gt; v;<br><br><span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll w = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ll T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>    ll ans = <span class="hljs-number">0</span>; v.<span class="hljs-built_in">clear</span>();<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            v.push-<span class="hljs-built_in">back</span>(&#123;j, a[j]&#125;);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            v[i].second = <span class="hljs-built_in">gcd</span>(v[i].second, a[j]);<br>            <span class="hljs-keyword">if</span>(v[i].second == v[i + <span class="hljs-number">1</span>].second) v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, (j - v[i].first + <span class="hljs-number">1</span>) * (v[i].second));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcd</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3794 签到题IV</title>
    <link href="/2020/09/30/P3794_%E7%AD%BE%E5%88%B0%E9%A2%98IV/"/>
    <url>/2020/09/30/P3794_%E7%AD%BE%E5%88%B0%E9%A2%98IV/</url>
    
    <content type="html"><![CDATA[<p>题目: luogu <a href="https://www.luogu.com.cn/problem/P3794">签到题IV</a><br />话说这道题和<a href="https://www.luogu.com.cn/problem/UVA1642">UVA1642 魔法GCD</a>很类似 <span id="more"></span> # Solution</p><p>题目要求找所有满足条件的子序列，可以考虑固定右端点<span class="math inline">\(j\)</span>，然后快速求出每个左端点<span class="math inline">\(i\)</span>对应的子序列的有关信息。<br />好像有点抽象，可以想一下这个序列怎么做。<br /><span class="math display">\[3,4,6,4,2\]</span> <span class="math inline">\(j=4\)</span>时，我们写一下所有子序列的有关值，即<span class="math inline">\(gcd(a-i,a-{i+1}...a-j)\)</span>和<span class="math inline">\((a-i\  or\  a-{i+1}...\  or\  a-j)\)</span> 1. <span class="math inline">\(i=1\)</span>时,<span class="math inline">\(gcd(a-1,a-2,a-3,a-4)=1\)</span>, <span class="math inline">\((a-1\  or\  a-2\  or\  a-3\  or\  a-4)=7\)</span> 2. <span class="math inline">\(i=2\)</span>时,<span class="math inline">\(gcd(a-2,a-3,a-4)=2\)</span>, <span class="math inline">\((a-2\  or\  a-3\  or\  a-4)=6\)</span> 3. <span class="math inline">\(i=3\)</span>时,<span class="math inline">\(gcd(a-3,a-4)=2\)</span>, <span class="math inline">\((a-3\  or\  a-4)=6\)</span> 4. <span class="math inline">\(i=4\)</span>时,<span class="math inline">\(gcd(a-4)=4\)</span>, <span class="math inline">\((a-4 \  or\  a-4)=4\)</span></p><p>很显然我们可以把每个左端点<span class="math inline">\(i\)</span>对应的有关信息存下来，然后一个个判断是否符合条件。每次<span class="math inline">\(j\)</span>右移时(即增加一个元素)都把每个左端点维护的信息更新。这样做是<span class="math inline">\(O(n^2 logn)\)</span>的。<br />观察上表，可以发现有的<span class="math inline">\(gcd\)</span>或者二进制或的和是相等的。事实上每加入一个新的数，序列的<span class="math inline">\(gcd\)</span>是不变或者变小的，且变小时会变为<span class="math inline">\(a-j\)</span>的约数。而序列的二进制或则是不变或者变大的，如果把数写成二进制的形式，可以发现如果增大只会在某一位增加<span class="math inline">\(1\)</span>，而一共只有<span class="math inline">\(\log-2 a-j\)</span>位。所以<span class="math inline">\(gcd\)</span>或者二进制或的值的个数都是<span class="math inline">\(log\)</span>级别的。<br />那么如果把相等的值合并，复杂度可以降为<span class="math inline">\(O(nlog^2 n)\)</span>的。<br />因为<span class="math inline">\(a\oplus b=k\)</span>，有<span class="math inline">\(a\oplus k=b\)</span>。那么可以分别维护<span class="math inline">\(gcd(a-i,a-{i+1}...a-j)\)</span>和<span class="math inline">\((a-i\  or\  a-{i+1}...\  or\  a-j)\)</span>。计算出每个<span class="math inline">\(gcd\oplus k\)</span>，之后去找有没有等于<span class="math inline">\(gcd\oplus k\)</span>的<span class="math inline">\(or\)</span>值。<br />怎么维护呢？可以发现无论是<span class="math inline">\(gcd\)</span>还是<span class="math inline">\(or\)</span>的值都是单调的，受到<span class="math inline">\(ODT\)</span>的启发，可以把相同的值合并为一个块，也就是记录它的左右端点和值，每次查询都<span class="math inline">\(O(log)\)</span>的算出每个<span class="math inline">\(gcd\oplus k\)</span>。然后二分查找或者直接枚举有没有与它相等的<span class="math inline">\(or\)</span>值，如果有，就把两个区间(该<span class="math inline">\(gcd\)</span>对应的区间和<span class="math inline">\(or\)</span>对应的区间)取交集，答案累加上此时的元素个数就可以。时间复杂度<span class="math inline">\(O(n log^2 n)\)</span>，实际上很难有每次都使表里有<span class="math inline">\(\log a-j\)</span>个元素的数据，所以复杂度和<span class="math inline">\(O(nlog n)\)</span>接近。</p><blockquote><p>不知道为什么二分还没直接枚举跑得快QwQ</p></blockquote><h1 id="code">Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, k, a[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> l, r, v;<br>&#125;;<br>vector&lt;node&gt; v, o;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function">node <span class="hljs-title">bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; o.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span>(o[i].v == x) <span class="hljs-keyword">return</span> &#123;o[i].l, o[i].r, x&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>        v.push-<span class="hljs-built_in">back</span>(&#123;j, j, a[j]&#125;);<br>        o.push-<span class="hljs-built_in">back</span>(&#123;j, j, a[j]&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        v[i].v = <span class="hljs-built_in">gcd</span>(v[i].v, a[j]);<br>        <span class="hljs-keyword">if</span>(v[i].v == v[i + <span class="hljs-number">1</span>].v) &#123;<br>            v[i].r = v[i + <span class="hljs-number">1</span>].r;<br>            v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = o.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        o[i].v |= a[j];<br>        <span class="hljs-keyword">if</span>(o[i].v == o[i + <span class="hljs-number">1</span>].v) &#123;<br>        o[i].r = o[i + <span class="hljs-number">1</span>].r;<br>        o.<span class="hljs-built_in">erase</span>(o.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        node ans = <span class="hljs-built_in">bound</span>(v[i].v ^ k);<br>        <span class="hljs-keyword">if</span>(ans.v == <span class="hljs-number">-1</span> || ans.l &gt; v[i].r || ans.r &lt; v[i].l) <span class="hljs-keyword">continue</span>; <br>        ans.l = <span class="hljs-built_in">max</span>(v[i].l, ans.l); ans.r = <span class="hljs-built_in">min</span>(ans.r, v[i].r);<br>            sum += ans.r - ans.l + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcd</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 6181 某个套路求和题</title>
    <link href="/2020/09/29/LOJ_6181_%E6%9F%90%E4%B8%AA%E5%A5%97%E8%B7%AF%E6%B1%82%E5%92%8C%E9%A2%98/"/>
    <url>/2020/09/29/LOJ_6181_%E6%9F%90%E4%B8%AA%E5%A5%97%E8%B7%AF%E6%B1%82%E5%92%8C%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6181">题目链接</a></p></blockquote><p><del>和社论不一样的方法</del><br /><span id="more"></span> ## 题目<br />已知<span class="math inline">\(f(n) = \prod\limits-{d|n} \mu(d)\)</span> 求<span class="math inline">\(\sum\limits-{i=1}^n f(i) \bmod 998244353\)</span>，<span class="math inline">\(n\leq 10^{10}\)</span></p><h2 id="分析">分析</h2><p>求<span class="math inline">\(\sum\limits-{i=1}^n\prod\limits-{d|i} \mu(d)\)</span><br />我们来观察一下<span class="math inline">\(\prod\limits-{d|i} \mu(d)\)</span>有什么特点。</p><p>首先如果<span class="math inline">\(i\)</span>有平方因子，那么它等于<span class="math inline">\(0\)</span><br /><span class="math inline">\(i\)</span>为素数，等于<span class="math inline">\(1\)</span></p><p>其他情况，我们考虑有多少个约数<span class="math inline">\(\mu (d)=-1\)</span><br />我们把<span class="math inline">\(i\)</span>唯一分解一下，一定等于<span class="math inline">\(\prod p-i^1\)</span><br />假设一共有<span class="math inline">\(cnt\)</span>个素约数，那么<span class="math inline">\(d\)</span>无非就是从些质约数里面选一些出来。<br />等于<span class="math inline">\(\binom{cnt}{1}+\binom{cnt}{3}+...+\binom{cnt}{2k+1}\)</span><br />也就是<span class="math inline">\(\sum-{i=1}^{cnt}\binom{cnt}{i}[i\nmid 2]=2^{cnt-1}\)</span><br />所以只有<span class="math inline">\(cnt=1\)</span>时才为<span class="math inline">\(-1\)</span>，<span class="math inline">\(cnt&gt;1\)</span>时都等于<span class="math inline">\(1\)</span>，而<span class="math inline">\(cnt=1\)</span>的情况已经讨论过了。</p><p>我们把素数和其他数分类讨论<br /><span class="math inline">\(ans=\sum-{i=1,i\not\in prime}^n\mu(i)^2-\sum-{i=1,i\in prime}^n{1}\)</span> <span class="math inline">\(ans=\sum-{i=1}^n\mu(i)^2-\sum-{i=1}^n{2}\)</span></p><p>前面是积性函数前缀和，后面是素数个数。<br /><del>这东西直接min25筛不就完了</del> <del>为什么题解些这么麻烦啊</del> <sub>?</sub><br /><del>最开始代码有点小问题，还以为不能这么做</del> <del>同学帮我开了long long 竟然过了？</del></p><p>不过社论有<span class="math inline">\(O{\sqrt{n}}\)</span>筛<span class="math inline">\(\sum\mu(i)^2\)</span>的做法。 <del>诶诶题解直接看这里好了<a href="https://loj.ac/article/2165">link</a></del></p><h2 id="代码">代码</h2><p>社论做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">998244353</span>;<br>ll n, sum[N], g[N], w[N], sqr, mu[N];<br><span class="hljs-keyword">int</span> cnt, m, id1[N], id2[N], p[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i, mu[i] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= m; j++) &#123;<br>vis[i * p[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>mu[i * p[j]] = -mu[i];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>sqr = <span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-built_in">init</span>(sqr + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>w[++m] = n / l;<br>r = n / w[m];<br>g[m] = (w[m] - <span class="hljs-number">1ll</span> + MOD) % MOD;<br><span class="hljs-keyword">if</span> (w[m] &lt;= sqr) id1[w[m]] = m;<br><span class="hljs-keyword">else</span> id2[r] = m;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; p[j] * <span class="hljs-number">1ll</span> * p[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / p[j] &lt;= sqr) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];<br>g[i] = (g[i] -  (g[k] - j + <span class="hljs-number">1</span>) + MOD) % MOD;<br>&#125;<br>ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i++)<br>res = (res + mu[i] * <span class="hljs-number">1ll</span> * (n / i / i) % MOD) % MOD;<br>res -= g[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (res % MOD + MOD) % MOD);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>直接筛 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">998244353</span>;<br>ll n, sum[N], g[N], w[N], sqr;<br>ll cnt, m, id1[N], id2[N], p[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= m; j++) &#123;<br>vis[i * p[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">S</span><span class="hljs-params">(ll x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span> || p[y] &gt; x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = (x &lt;= sqr) ? id1[x] : id2[n / x];<br>ll res = g[k] - (y - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = y; i &lt;= cnt &amp;&amp; p[i] * p[i] &lt;= x; i++)<br>res = (res + <span class="hljs-built_in">S</span>(x / p[i], i + <span class="hljs-number">1</span>)) % MOD;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>sqr = <span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-built_in">init</span>(sqr);<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>w[++m] = n / l;<br>r = n / w[m];<br>g[m] = (w[m] - <span class="hljs-number">1ll</span> + MOD) % MOD;<br><span class="hljs-keyword">if</span> (w[m] &lt;= sqr) id1[w[m]] = m;<br><span class="hljs-keyword">else</span> id2[r] = m;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; p[j] * <span class="hljs-number">1ll</span> * p[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / p[j] &lt;= sqr) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];<br>g[i] = (g[i] -  (g[k] - j + <span class="hljs-number">1</span>) + MOD) % MOD;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ((-g[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % MOD + MOD) % MOD + <span class="hljs-built_in">S</span>(n, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) % MOD);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
      <tag>数论</tag>
      
      <tag>min-25筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1416C XOR Inverse</title>
    <link href="/2020/09/29/CF1416C_XOR_Inverse/"/>
    <url>/2020/09/29/CF1416C_XOR_Inverse/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/contest/1416/problem/C">题目链接</a></p></blockquote><p>按位看每一个数。<br /><span id="more"></span> 如果某两个数是逆序对，那必然是有一个高位不同。<br />如果两个数在那一位上面都<span class="math inline">\(\text{xor}\)</span>上<span class="math inline">\(1\)</span>，两个数的大小关系将会颠倒。</p><p>所以我们可以通过这种方式使逆序对变成顺序对，对于<span class="math inline">\(x\)</span>的每一位，我们需要知道有哪些数是从这一位开始不同的，也就是这一位改变会使多少逆序对变成顺序对。</p><p>把所有数都插入<span class="math inline">\(01tire\)</span>里面，每个节点记录一下被经过了多少次。<br />第一次不同无非就是某个分叉的地方，如果插入的数都是编号更小的，那么我们可以很容易计算出和当前这个数有关的顺序对和逆序对。</p><p>最后每一位都看一下<span class="math inline">\(x\)</span>这一位的取值产生的逆序对和顺序对个数。<br />贪心选更少的即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = (<span class="hljs-number">3e5</span> + <span class="hljs-number">9</span>) * <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> n, x, a[N], tr[N][<span class="hljs-number">2</span>],  tot; <br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> inv[<span class="hljs-number">33</span>], dir[<span class="hljs-number">33</span>], s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i + <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> c = ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!tr[u][c]) tr[u][c] = ++tot;<br>    u = tr[u][c];<br>        s[u]++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i + <span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-keyword">int</span> c = ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) inv[i] += s[tr[u][<span class="hljs-number">1</span>]];<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) dir[i] += s[tr[u][<span class="hljs-number">0</span>]];<br>u = tr[u][c];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), <span class="hljs-built_in">insert</span>(a[i]), <span class="hljs-built_in">qry</span>(a[i]);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (inv[i] &gt; dir[i]) x |= (<span class="hljs-number">1</span> &lt;&lt; i), res += dir[i];<br><span class="hljs-keyword">else</span> res += inv[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %d\n&quot;</span>, res, x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>01tire</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编辑距离问题</title>
    <link href="/2020/09/27/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/27/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1183">题目链接</a></p></blockquote><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之 <span id="more"></span> 间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。 例如将kitten一字转成sitting： sitten （k-&gt;s） sittin （e-&gt;i） sitting （-&gt;g） 所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。 给出两个字符串a,b，求a和b的编辑距离。</p><p>设<span class="math inline">\(f[i][j]\)</span>表示A串前<span class="math inline">\(i\)</span>位到<span class="math inline">\(B\)</span>串前<span class="math inline">\(j\)</span>位的编辑距离。<br /><span class="math inline">\(A[i]=B[j]\)</span>，<span class="math inline">\(f[i][j]=f[i-1][j-1]\)</span><br /><span class="math inline">\(A[i]\neq B[j]\)</span>，<span class="math inline">\(min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1\)</span><br />分别对应删除<span class="math inline">\(A\)</span>最后一个字符，<span class="math inline">\(A\)</span>末尾加一个字符，修改<span class="math inline">\(A\)</span>最后一个字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">char</span> a[N], b[N];<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>, a + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>), m = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">max</span>(n, m); i++) f[i][<span class="hljs-number">0</span>] = f[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]), f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「SCOI2005」栅栏</title>
    <link href="/2020/09/27/%E3%80%8CSCOI2005%E3%80%8D%E6%A0%85%E6%A0%8F/"/>
    <url>/2020/09/27/%E3%80%8CSCOI2005%E3%80%8D%E6%A0%85%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2148">题目链接</a></p></blockquote><p>这道题的正解竟然就是 dfs +剪枝...<br /><span id="more"></span> 可以把题目理解成用木板去塞木材，最多塞多少个。</p><p>先将不可能塞的不板和不可能被塞的木材排除。</p><p>二分答案最多能塞多少个木板，搜索每个木材塞到哪个板，显然用更小的木板来塞一定不会更差。</p><p>记录前 mid 个木板的和，总的木材的和。<br />搜索的时候随时减去不能再被塞的木材。</p><p>如果某个时候<span class="math inline">\(sum[mid]+w\ge S\)</span>则 return<br />如果木板大小相同，就直接从上一次塞的位置继续，因为我们应该让这些木板只能按某种顺序塞来减少状态数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n, m, mid, S, a[N], b[N], sum[N], lst[N];<br><span class="hljs-keyword">bool</span> flg;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>)(flg = <span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (a[p] &lt; b[<span class="hljs-number">1</span>] &amp;&amp; p &lt;= n) w += a[p], p++;<br><span class="hljs-keyword">if</span> (p &gt; n || w + sum[mid] &gt; S || flg) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">int</span> t = p;<br><span class="hljs-keyword">if</span> (x != mid &amp;&amp; b[x] == b[x + <span class="hljs-number">1</span>]) t = lst[x + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t; i &lt;= n; i++) <span class="hljs-keyword">if</span> (a[i] &gt;= b[x]) &#123;<br>lst[x] = i;<br>a[i] -= b[x];<br><span class="hljs-built_in">dfs</span>(x - <span class="hljs-number">1</span>, p, w);<br>a[i] += b[x];<br><span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + m + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (b[m] &gt; a[n]) m--;<br><span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span> (a[i] &gt;= b[<span class="hljs-number">1</span>]) a[++tot] = a[i];<br>    n = tot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) sum[i] = sum[i - <span class="hljs-number">1</span>] + b[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) S += a[i];<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = m, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>flg = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs</span>(mid, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (flg) ans = mid, l = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>```</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸多边形的划分</title>
    <link href="/2020/09/27/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%88%92%E5%88%86/"/>
    <url>/2020/09/27/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10149">题目链接</a><br /><span id="more"></span> 破环成链，<span class="math inline">\(f[i][j]\)</span>表示点<span class="math inline">\([i,j]\)</span>的最大价值。<br />转移时枚举最后一个三角形的划分方法即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int --int128</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>;<br><span class="hljs-keyword">int</span> n, f[N * <span class="hljs-number">2</span>][N * <span class="hljs-number">2</span>], a[N * <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>        x = -x;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>(), a[i + n] = a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * n; j++) f[i][j] = <span class="hljs-number">1e38</span>;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1e35</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<br>    <span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">2</span>) f[i][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k][j] + a[i] * a[j] * a[k]);<br>    &#125;<br>        <span class="hljs-keyword">if</span>(len == n) ans = <span class="hljs-built_in">min</span>(ans, f[i][j]); <br>    &#125;<br>    <span class="hljs-built_in">write</span>(ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10082 Word Rings</title>
    <link href="/2020/09/26/LOJ_10082_Word_Rings/"/>
    <url>/2020/09/26/LOJ_10082_Word_Rings/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10082">题目链接</a></p></blockquote><p>这道题很妙啊...</p><p>首先这个建边方式，很自然就能想到按题意串与串连边。<br /><span id="more"></span> 但是这样的复杂度是不能接受的。</p><p>我们只需要将每个串前两个字符对应的节点和后两个对应的节点连边就可以了，不难发现这样也是等价的。</p><p>现在边建好了，很自然就能想到用 spfa 跑最长路。<br />这样的时间复杂度也是不能接受的...</p><p>我们并不能直接知道答案是多少，于是二分答案上去验证<br />如果一个环<span class="math inline">\(\frac{a-1+a-2+a-3+...+a-n}{n}\geq mid\)</span><br /><span class="math inline">\((a-1-mid)+(a-2-mid)+...+(a-n-mid)\geq 0\)</span></p><p>于是我们可以枚举答案，给每条边一个新的边权，用 dfs 版的 spfa 跑最长路判断有没有正环。</p><p>枚举一定数量的起点来验证，大概率能跑对...<br />注意这里不需要每次都 memset 最短路的 dis 数组，因为如果正环上某个点<span class="math inline">\(x\)</span>被前驱是<span class="math inline">\(y\)</span>，<span class="math inline">\(dis[x]\)</span>被重赋值后，看似<span class="math inline">\(dis&#39;[x]\geq dis[y]+w\)</span>不能被更新，但是<span class="math inline">\(dis[x]\)</span>被重赋值说明已经可以作为新的起点，不需要从<span class="math inline">\(y\)</span>迭代过来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50500</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-9</span>;<br><span class="hljs-keyword">int</span> n, cnt, head[N];<br><span class="hljs-keyword">double</span> dis[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-keyword">char</span> s[<span class="hljs-number">1005</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><span class="hljs-keyword">int</span> nxt, v; <span class="hljs-keyword">double</span> w;&#125; e[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">double</span> w)</span> </span>&#123;e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> mid)</span> </span>&#123;<br>    vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">double</span> w = e[i].w - mid;<br><span class="hljs-keyword">if</span> (dis[v] &lt; dis[x] + w) &#123;<br>dis[v] = dis[x] + w;<br>    <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(v, mid)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>vis[x] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> mid)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dis);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, mid)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n) &#123;<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head);<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">int</span> pre = (s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>) * <span class="hljs-number">26</span>, suf = (s[len - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>) * <span class="hljs-number">26</span>;<br>pre = pre + s[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;a&#x27;</span>, suf = suf + s[len] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">double</span> bl = <span class="hljs-number">1.0</span> * len;<br><span class="hljs-built_in">add</span>(pre, suf, bl);<br>&#125;<br><span class="hljs-keyword">double</span> l = <span class="hljs-number">0.0</span>, r = <span class="hljs-number">1005.0</span>;<br><span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br><span class="hljs-keyword">double</span> mid = (r + l) / <span class="hljs-number">2.0</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-number">0.0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, l);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思维好题</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10010 糖果传递</title>
    <link href="/2020/09/26/LOJ_10010_%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/"/>
    <url>/2020/09/26/LOJ_10010_%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10010">糖果传递</a></p></blockquote><p>设<span class="math inline">\(x-i\)</span>表示第<span class="math inline">\(i\)</span>个人向第<span class="math inline">\(i-1\)</span>传递的糖果数，<span class="math inline">\(i\in [1,n],x-i\in \mathbb{z}\)</span><br />特别的<span class="math inline">\(x-1\)</span>表示<span class="math inline">\(1\)</span>向<span class="math inline">\(n\)</span>传递的糖果数。</p><p>设平均数为<span class="math inline">\(q\)</span><br /><span class="math inline">\(a-i-x-i+x-{i+1}=q\)</span> 则有<span class="math inline">\(x-i-x-{i+1}=a-i-q\)</span></p><p><span class="math inline">\(x-1-x-2=a-1-q\)</span><br /><span class="math inline">\(x-2-x-3=a-2-q\)</span><br /><span class="math inline">\(......\)</span><br /><span class="math inline">\(x-{n-1}-x-{n}=a-{n-1}-q\)</span></p><p>实际上还有<span class="math inline">\(x-n-x-1=a-n-q\)</span>，但是这个方程并没有什么意义。<br />我们把每个方程相加，可以得到： <span class="math inline">\(x-1=x-n+\sum-{i=1}^{n-1}a-i-q\)</span><br /><span class="math inline">\(x-2=x-n+\sum-{i=2}^{n-1}a-i-q\)</span><br /><span class="math inline">\(......\)</span> <span class="math inline">\(x-{n-1}=x-{n}+a-{n-1}-q\)</span></p><p>把<span class="math inline">\(\sum a-i-q\)</span>看作常数<br />题目求 <span class="math inline">\(\lvert x-n+t-1\rvert+\lvert x-n+t-2\rvert+...+\lvert x-n+t-{n-1}\rvert+\lvert x-n\rvert\)</span><br />为了形式统一，可以把<span class="math inline">\(\lvert x-n\rvert\)</span>变成<span class="math inline">\(\lvert x-n\rvert-t-n,t-n=0\)</span></p><p>这是一个经典的结论，当<span class="math inline">\(x-n\)</span>取<span class="math inline">\(t\)</span>中位数时最小。<br />具体证明是<span class="math inline">\(\lvert x+t\rvert\)</span>看作坐标轴上两点距离。<br />因为有<span class="math inline">\(\lvert x-a\rvert+\lvert x-b\rvert\geq \lvert a-b\rvert\)</span>调整<span class="math inline">\(x\)</span>取值，发现在中位数的时候最优。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br>ll n, sum[N], t[N], b[N], ans;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;sum[i]), sum[i] += sum[i - <span class="hljs-number">1</span>];<br>    ll qaq = sum[n] / n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        t[i] = sum[n - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>] - (n - i) * qaq;<br>t[i] = -t[i];<br>b[i] = t[i];<br>&#125;<br>t[n] = <span class="hljs-number">0</span>;<br>b[n] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">sort</span>(t + <span class="hljs-number">1</span>, t + n + <span class="hljs-number">1</span>);<br>ll xn = t[n / <span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans = ans + <span class="hljs-built_in">abs</span>(xn - b[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ10235 序列统计</title>
    <link href="/2020/09/26/LOJ10235_%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1/"/>
    <url>/2020/09/26/LOJ10235_%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10235">题目链接</a></p></blockquote><p>题目要求单调不降很不好做。<br /><span id="more"></span> 我们把每个数都加上它的下标，就变成了单调上升序列，值域是<span class="math inline">\([l+1,r+n]\)</span></p><p>在<span class="math inline">\([l+1,r+n]\)</span>里面选<span class="math inline">\(n\)</span>个数和单调上升序列的方案数是一一对应的。<br />答案是<span class="math inline">\(\sum-{i=1}^n\binom{r-l+i}{i}=\binom{r-l+n+1}{n}-1\)</span></p><p>因为模数是小质数，用<span class="math inline">\(lucas\)</span>定理做就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1e6</span> + <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> n, l, r, a[p + <span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % p) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % p;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a[n] * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(a[n - m], p - <span class="hljs-number">2</span>) % p * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">fpow</span>(a[m], p - <span class="hljs-number">2</span>) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">solve</span>(n / p, m / p) * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(n % p, m % p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> -;<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) a[i] = a[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % p;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;-); -; ---) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;l, &amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (<span class="hljs-built_in">solve</span>(r - l + <span class="hljs-number">1</span> + n, n) * <span class="hljs-number">1ll</span> - <span class="hljs-number">1ll</span> + p) % p);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>```</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ10059 Censoring</title>
    <link href="/2020/09/26/LOJ10059_Censoring/"/>
    <url>/2020/09/26/LOJ10059_Censoring/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10059">题目链接</a><br /><span id="more"></span> 维护一个栈，表示每个输出字符对应<span class="math inline">\(tire\)</span>图上的节点，在<span class="math inline">\(tire\)</span>图上游走时，如果走到某个节点是敏感词结束的地方，就弹出敏感词，并且栈回退到到这个敏感词之前的位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, tr[N][<span class="hljs-number">26</span>], fail[N], id[N], tot, stk[N], top, o[N];<br><span class="hljs-keyword">char</span> s[N], qaq[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>, n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!tr[u][c]) tr[u][c] = ++tot;<br>u = tr[u][c];<br>&#125;<br>id[u] = n;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-keyword">if</span> (tr[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(tr[<span class="hljs-number">0</span>][i]);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.<span class="hljs-built_in">push</span>(tr[u][i]);<br><span class="hljs-keyword">else</span> tr[u][i] = tr[fail[u]][i];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, qaq + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>), <span class="hljs-built_in">insert</span>(s);<br><span class="hljs-built_in">build</span>();<br><span class="hljs-keyword">int</span> m = <span class="hljs-built_in">strlen</span>(qaq + <span class="hljs-number">1</span>), u = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> c = qaq[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>u = tr[u][c];<br>stk[++top] = u;<br>o[top] = i;<br><span class="hljs-keyword">if</span> (id[u]) &#123;<br>top -= id[u];<br>u = stk[top];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= top; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, qaq[o[i]]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>AC自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉格朗日插值</title>
    <link href="/2020/09/23/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    <url>/2020/09/23/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>具体证明见<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95">wikipedia</a><br /><span id="more"></span> ## 拉格朗日插值 如果给一个度数为<span class="math inline">\(n\)</span>的多项式的<span class="math inline">\(n+1\)</span>个点<span class="math inline">\((x-i,y-i)\)</span>，那么我们可以用拉格朗日插值将求出这个多项式在所有点的取值。</p></blockquote><p>假设<span class="math inline">\(x-i\)</span>互不相同，<span class="math inline">\(F(k)=\sum\limits-{i=0}^{deg} y-i \ell-i(k)\)</span></p><p>其中<span class="math inline">\(\ell-i\)</span>是拉格朗日基本多项式，<span class="math inline">\(\ell-i(k)=\prod\limits-{j=0,i\neq j}^{deg}\frac{k-x-j}{x-i-x-j}\)</span></p><p>这个<span class="math inline">\(\ell\)</span>有什么特点呢？<br />对于<span class="math inline">\(\forall j\neq i\)</span>，<span class="math inline">\(\ell-i(x-j)=0，而\)</span>-i(x-i)=1$。<br />代值进去即可验证。</p><p>所以<span class="math inline">\(\forall x-i,F(x-i)=\sum\limits-{i=0}^{deg} y-i \ell-i(x-i)=y-i\)</span>，一共有<span class="math inline">\(deg+1\)</span>个点，所以能确定一个多项式。<br />时间复杂度<span class="math inline">\(\mathcal{O}(n^2)\)</span></p><h2 id="重心拉格朗日插值">重心拉格朗日插值</h2><p>每一次都算<span class="math inline">\(\ell\)</span>好像很慢。<br />令<span class="math inline">\(\ell(x)=(x-x-1)(x-x-2)...(x-x-n)\)</span><br /><span class="math inline">\(w-i=\frac{1}{\prod\limits-{j=0,i\neq j}^{deg}(x-i-x-j)}\)</span></p><p>则<span class="math inline">\(\ell-i(x)=\frac{\ell(x)}{x-x-i}w-i\)</span><br /><span class="math inline">\(F(x)=\sum\limits-{i=0}^{deg}y-i\ell-i(x)\)</span><br /><span class="math inline">\(F(x)=\ell(x)\sum\limits-{i=0}^{deg}y-i\frac{w-i}{x-x-i}\)</span></p><p><span class="math inline">\(w-i\)</span>称为<span class="math inline">\(i\)</span>的重心，每次加入新点时可以<span class="math inline">\(\mathcal{O}(n)\)</span>算新重心，计算<span class="math inline">\(F\)</span>也是<span class="math inline">\(\mathcal{O}(n)\)</span>的。</p><p><del>当然初始化重心是<span class="math inline">\(\mathcal{O}(n^2)\)</span></del></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 3265 Delegation</title>
    <link href="/2020/09/23/LOJ_3265_Delegation/"/>
    <url>/2020/09/23/LOJ_3265_Delegation/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/3265">题目链接</a></p></blockquote><p>这题看起来挺像赛道修建。<br /><span id="more"></span> 但是是要求把所有路选完，所以贪心方法不太一样。</p><p>首先，二分以后并不是能选就选，这个看样例就知道。<br /><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure> <span class="math inline">\(\text{mid}=2\)</span>时，如果能选就选最后是不合法的，因为有边最后不能放到长度不小于<span class="math inline">\(2\)</span>的链里面。</p><p>考虑最后合并一个点的所有链，如果有多于一条链最后不能合并，那就是不合法的。<br />所有链都满足要求的前提下，可以选取一条尽量长的链给父节点，这样一定是不劣的，因为可以顺便把这条链合并了，也有可能这条链刚好时父节点合并完。</p><p>最后特别判断一下父节点。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> n, mid, head[N], cnt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v;<br>&#125; e[N &lt;&lt; <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v&#125;; head[u] = cnt;<br>e[++cnt] = &#123;head[v], u&#125;; head[v] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>multiset&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">int</span> d = <span class="hljs-built_in">dfs</span>(v, u);<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>s.<span class="hljs-built_in">insert</span>(d + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>, pt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">int</span> x = *it;<br>s.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-keyword">auto</span> itl = s.lower-<span class="hljs-built_in">bound</span>(mid - x);<br><span class="hljs-keyword">if</span> (itl == s.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-keyword">if</span> (!t) t = x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (*itl &gt;= mid) pt = x;<br>s.<span class="hljs-built_in">erase</span>(itl);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (u != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> t ? t : pt;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br><span class="hljs-built_in">add</span>(u, v);<br>&#125;<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> x = <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || x &gt;= mid) l = mid + <span class="hljs-number">1</span>, ans = mid;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2721「NOI2018」屠龙勇士</title>
    <link href="/2020/09/21/LOJ_2721%E3%80%8CNOI2018%E3%80%8D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/"/>
    <url>/2020/09/21/LOJ_2721%E3%80%8CNOI2018%E3%80%8D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2721">题目链接</a></p></blockquote><p>因为是按照<span class="math inline">\(1-n\)</span>的顺序杀龙，所以每次用的剑是固定的，可以先预处理出来。<br /><span id="more"></span> 每次需要满足<br />1 .<span class="math inline">\(atk*x\geq a-i\)</span><br />2. <span class="math inline">\(atk*x\equiv a-i\pmod {p-i}\)</span></p><p>观察数据，可以发现要不<span class="math inline">\(p-i\)</span>满足<span class="math inline">\(a-i\leq p-i\)</span>，要不<span class="math inline">\(p-i=1\)</span></p><p>对于第二种只需要刚好打到不大于<span class="math inline">\(0\)</span>就可以了。</p><p>第一种情况，第一个限制显然是可以忽略的，因为满足第二个限制一定就满足第一种限制。</p><p>我们只需要考虑解出<span class="math inline">\(x\)</span>，把每个方程都化为<span class="math inline">\(x\equiv r-i\pmod {m-i}\)</span>这种一般形式。</p><p>直接的想法就是变成<span class="math inline">\(x\equiv a-i*inv(atk)\pmod{p-i}\)</span><br />但是模<span class="math inline">\(p-i\)</span>意义下，<span class="math inline">\(atk\)</span>的逆元不一定存在。<br />同余方程同时约去<span class="math inline">\(\gcd(a-i,p-i,atk)\)</span><br />如果<span class="math inline">\(\gcd(atk,p-i)\)</span>仍不等于 <span class="math inline">\(1\)</span>，则无解。</p><p>因为约去<span class="math inline">\(\gcd(a-i,p-i,atk)\)</span> 后仍不互质，说明<span class="math inline">\(\gcd(atk,p-i)\nmid a-i\)</span>，不满足翡蜀定理，则无解。</p><p>化完之后来解同余方程组就可以了。</p><p>细节没处理好，代码毒瘤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int --int128 </span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> -, n, k, atk[N], nw[N];<br><span class="hljs-keyword">int</span> r[N], m[N];<br><span class="hljs-keyword">int</span> a[N], p[N];<br><span class="hljs-keyword">bool</span> pd = <span class="hljs-number">1</span>;<br>multiset&lt;<span class="hljs-keyword">int</span>&gt; s;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>        x = -x;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prework</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> it = s.upper-<span class="hljs-built_in">bound</span>(a[i]);<br>    <span class="hljs-keyword">if</span> (it == s.<span class="hljs-built_in">begin</span>()) res = *it;<br>        <span class="hljs-keyword">else</span> res = *(--it);<br>    s.<span class="hljs-built_in">erase</span>(it);<br>    atk[i] = res;<br>s.<span class="hljs-built_in">insert</span>(nw[i]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>a = (a % p + p) % p;<br>    b = (b % p + p) % p;<br><span class="hljs-keyword">return</span> (a * b % p + p) % p;<br><span class="hljs-comment">/*assert(a &gt;= 0); assert(b &gt;= 0);</span><br><span class="hljs-comment">    int res = 0;</span><br><span class="hljs-comment">for (; b; b &gt;&gt;= 1, a = (a + a) % p) if (b &amp; 1) res = (res + a) % p;</span><br><span class="hljs-comment">return res;*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>        res = <span class="hljs-built_in">max</span>(res, (a[i] + atk[i] - <span class="hljs-number">1</span>) / atk[i]);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span>&amp; d, <span class="hljs-keyword">int</span>&amp; x, <span class="hljs-keyword">int</span>&amp; y)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) &#123;d = a, x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">China</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> M = m[<span class="hljs-number">1</span>], R = r[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">int</span> a = M, b = m[i], c = r[i] - R, x, y, d;<br>    <span class="hljs-built_in">exgcd</span>(a, b, d, x, y);<br>    <span class="hljs-keyword">if</span>(c % d != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        x = (<span class="hljs-built_in">mul</span>(x, c / d, b) + b) % b;<br>        R += x * M, M *= m[i] / d, R = (R + M) % M;<br>    &#125;<br>    <span class="hljs-keyword">return</span> R;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">int</span> d, x, y;<br><span class="hljs-built_in">exgcd</span>(a, p, d, x, y);<br><span class="hljs-keyword">return</span> (x % p + p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> d;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    d = <span class="hljs-built_in">gcd</span>(atk[i], p[i]); d = <span class="hljs-built_in">gcd</span>(d, a[i]);<br>   atk[i] /= d, p[i] /= d, a[i] /= d;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">gcd</span>(atk[i], p[i]) != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>m[i] = p[i], r[i] = <span class="hljs-built_in">mul</span>(a[i], <span class="hljs-built_in">inv</span>(atk[i], p[i]), p[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;dragon.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;dragon.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-keyword">for</span> ( - = <span class="hljs-built_in">read</span>(); -; ---) &#123;<br>    s.<span class="hljs-built_in">clear</span>();<br>    pd = <span class="hljs-number">1</span>;<br>n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;p[i] = <span class="hljs-built_in">read</span>(); <span class="hljs-keyword">if</span> (p[i] != <span class="hljs-number">1</span>) pd = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) nw[i] = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= k; i++) x = <span class="hljs-built_in">read</span>(), s.<span class="hljs-built_in">insert</span>(x);<br><span class="hljs-built_in">prework</span>();<br><span class="hljs-keyword">if</span> (pd == <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">write</span>(<span class="hljs-built_in">solve1</span>()); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">build</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-built_in">write</span>(<span class="hljs-built_in">China</span>());<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10115 校门外的树</title>
    <link href="/2020/09/21/LOJ_10115_%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/"/>
    <url>/2020/09/21/LOJ_10115_%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10115">题目链接</a></p></blockquote><p>神仙思路。<br /><span id="more"></span> 每次g种树树把左端点插到一个树状数组<span class="math inline">\(a\)</span>，右端点插<span class="math inline">\(b\)</span>。<br />每次查询查<span class="math inline">\(qry(r,a)-qry(l-1,b)\)</span></p><p>为什么这样是对的呢？<br /><span class="math inline">\(qry(r,a)\)</span>表示所有左端点在查询区间<span class="math inline">\(l\)</span>右边的，这些树有可能会对答案产生贡献。<br />但是有些树没有贡献，只有这些区间右端点比<span class="math inline">\(l\)</span>小的时候。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, m, a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<span class="hljs-keyword">for</span> (; x &lt;= n; x += x &amp; -x) a[x] += <span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span> (; x; x -= x &amp; -x) res += a[x]; <span class="hljs-keyword">return</span> res;&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">while</span> (m--) &#123;<br><span class="hljs-keyword">int</span> op, l, r;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;l, &amp;r);<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <span class="hljs-built_in">upd</span>(l, a), <span class="hljs-built_in">upd</span>(r, b);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">qry</span>(r, a) - <span class="hljs-built_in">qry</span>(l - <span class="hljs-number">1</span>, b));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思维好题</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 6682 梦中的数论</title>
    <link href="/2020/09/21/LOJ_6682_%E6%A2%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/"/>
    <url>/2020/09/21/LOJ_6682_%E6%A2%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6682">题目链接</a><br /><span id="more"></span> <span class="math inline">\(\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{n}\sum\limits-{k=1}^{n}[(j\mid i) \land ((j+k)\mid i)]\)</span><br /><span class="math inline">\(\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{n}\sum\limits-{d=j+1}^{j+n}[(j\mid i) \land (d\mid i)]\)</span></p></blockquote><p>把枚举后验证变为直接计算贡献，显然只有当<span class="math inline">\(j,d\)</span>是<span class="math inline">\(i\)</span>的约数时才有贡献。<br />从<span class="math inline">\(i\)</span>的约数中选两个大小不同的约数的选法有<span class="math inline">\(\binom{\sigma-0 i}{2}\)</span>种。<br />即求<span class="math inline">\(\sum\limits-{i=1}^n\frac{\sigma-0^2 i-\sigma-0 i}{2}\)</span></p><p>因为<span class="math inline">\(\sigma\)</span>是积性函数，用数论分块和<span class="math inline">\(\text{min25}\)</span> 分别求解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>,  MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> ll i2 = <span class="hljs-number">499122177</span>;<br>ll n, id1[N], id2[N], w[N], g[N], p[N], sqr;<br><span class="hljs-keyword">int</span> m, cnt;<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function">ll <span class="hljs-title">add</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> (a + b &gt;= MOD) ? a + b - MOD : a + b;&#125;<br><span class="hljs-function">ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> a * b % MOD;&#125;<br><span class="hljs-function">ll <span class="hljs-title">dec</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> ((a - b) % MOD + MOD) % MOD;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= m; j++) &#123;<br>vis[i * p[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>r = n / (n / l);<br>res = <span class="hljs-built_in">add</span>(res, <span class="hljs-built_in">mul</span>(r - l + <span class="hljs-number">1</span>, n / l));<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">S</span><span class="hljs-params">(ll x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (p[y] &gt; x || x &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = (x &lt;= sqr) ? id1[x] : id2[n / x];<br>ll res = <span class="hljs-built_in">dec</span>(g[k], <span class="hljs-built_in">mul</span>(<span class="hljs-number">4</span>, y - <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = y; i &lt;= cnt &amp;&amp; p[i] * p[i] &lt;= x; i++) &#123;<br>ll pow1 = p[i], pow2 = p[i] * p[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e = <span class="hljs-number">1</span>; pow2 &lt;= x; pow1 = pow2, pow2 *= p[i], e++) &#123;<br>res =  <span class="hljs-built_in">add</span>(res, <span class="hljs-built_in">add</span>(<span class="hljs-built_in">mul</span>(<span class="hljs-built_in">mul</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span>), <span class="hljs-built_in">S</span>(x / pow1, i + <span class="hljs-number">1</span>)), <span class="hljs-built_in">mul</span>(e + <span class="hljs-number">2</span>, e + <span class="hljs-number">2</span>)));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>sqr = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in">sqrt</span>(n)) + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">init</span>(sqr);<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>r = n / (n / l);<br>w[++m] = n / l;<br>g[m] = <span class="hljs-built_in">dec</span>(w[m], <span class="hljs-number">1</span>);<br>    (w[m] &lt;= sqr) ? id1[w[m]] = m : id2[r] = m;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; p[j] * p[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / p[j] &lt;= sqr) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];<br>g[i] = <span class="hljs-built_in">dec</span>(g[i], <span class="hljs-built_in">dec</span>(g[k], j - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) g[i] = <span class="hljs-built_in">mul</span>(g[i], <span class="hljs-number">4</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">dec</span>(<span class="hljs-built_in">add</span>(<span class="hljs-built_in">S</span>(n, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>), <span class="hljs-built_in">solve</span>()), i2));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数</tag>
      
      <tag>数论</tag>
      
      <tag>min-25筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>min-25筛学习笔记</title>
    <link href="/2020/09/20/min_25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/20/min_25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>min-25筛学习笔记 <a href="https://jkloverdcoi.github.io/2019/06/05/min-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">参考</a> 好像有些地方把<span class="math inline">\(F\)</span>，<span class="math inline">\(f\)</span>搞混了，应该能看懂吧（</p></blockquote><p><span class="math inline">\(\text{min25}\)</span>筛是一种求积性函数前缀和的筛法。 <span id="more"></span> 即<span class="math inline">\(\sum\limits-{i=1}^{n}F(i)\)</span>，要求<span class="math inline">\(\sum\limits-{i=1}^{n}[i\in prime]*F(i)\)</span>可以被快速算出。 时间复杂度  $\mathcal{O}(\frac{n^{{\frac{3}{4}}}}{\log-2n})$ ，空间复杂度<span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span>。</p><h2 id="min-25筛">min-25筛</h2><h3 id="预处理">预处理</h3><p>计算<span class="math inline">\(\sum\limits-{i=1}^{cnt}F(p-i)=\sum\limits-{i=1}^{n}[i\in prime]*F(i)\)</span> 定义<span class="math inline">\(g(n,j)=\sum\limits-{i=2}^nf(i)*[i\in prime\vee r(i)&gt;p-j]\)</span>，<span class="math inline">\(r(i)\)</span>表示<span class="math inline">\(i\)</span>的最小素约数。 这里，<span class="math inline">\(f\)</span>和<span class="math inline">\(F\)</span>不一样，<span class="math inline">\(f\)</span>的每一个数都和<span class="math inline">\(F\)</span>为素数时的计算方法一样，因为好算<span class="math inline">\(g\)</span>。 形象理解<span class="math inline">\(r(i)&gt;p-j\)</span> 表示埃氏筛第<span class="math inline">\(j\)</span> 次后还没筛出的数<span class="math inline">\(f(i)\)</span>之和。 因为每个<span class="math inline">\(i\)</span>都一定有素约数<span class="math inline">\(\leq\sqrt{i}\)</span>。 最后<span class="math inline">\(g(n,cnt)\)</span>即为所求。</p><p>所以<span class="math inline">\({p-j}^2&gt;n\)</span>时，<span class="math inline">\(g(n,j)=g(n,j-1)\)</span>，因为<span class="math inline">\(p-j\)</span>并没有多筛出的数。 <span class="math inline">\({p-j}^2\leq n\)</span>时，考虑<span class="math inline">\(p-j\)</span>的贡献。 多出来的部分无非就是<span class="math inline">\(r-i=p-j\)</span>的数，这些数显然不大于<span class="math inline">\(\lfloor\frac{n}{p-j}\rfloor\)</span>，且<span class="math inline">\(r-i&gt;p-{j-1}\)</span>。 <span class="math inline">\(g(n,j)=g(n,j-1)-f(p-j)\times (g(\frac{n}{p-j},j-1)-\sum\limits-{k=1}^{j-1}f(p-k))\)</span> 因为<span class="math inline">\({p-j}^2\leq n\)</span>，所以<span class="math inline">\(\lfloor\frac{n}{p-j}\rfloor\geq p-j\)</span>。 因为枚举了<span class="math inline">\(p-1,p-2,\text{...},p-{j-1}\)</span>，这些数乘上<span class="math inline">\(p-j\)</span>后<span class="math inline">\(r-i&lt;p-j\)</span>，所以应当把多算的部分减去。</p><h3 id="计算">计算</h3><p>我们现在知道<span class="math inline">\(\sum\limits-{i=1}^{n}F(i)\)</span>素数部分的贡献。 设一个二元组<span class="math inline">\(s(n,j)=\sum\limits-{i=2}^nF(i)[r(i)\geq p-j]\)</span></p><p>可以发现<span class="math inline">\(\sum\limits-{i=1}^{n}F(i)=s(n,1)+F(1)\)</span> 考虑计算<span class="math inline">\(s(n,j)\)</span> , 运用之前预处理的答案，素数部分的贡献是<span class="math inline">\(g(n,cnt)-\sum\limits-{i=1}^{j-1}f(p-j)\)</span>。 合数部分我们枚举最小的质因子<span class="math inline">\(p-k\)</span>和幂次<span class="math inline">\(e-i\)</span>  $s(n,j)=g(n,cnt)-\sum\limits-{i=1}^{j-1}F(p-j)+\sum\limits-{k=j}^{{p-k}^2\leq n}\sum\limits-{e=1}^{p-k^{e+1}\leq n}F(p-k^e)s(\frac{n}{p-k^e},k+1)+F(p-k^{e+1})$ 边界是$n=1\vee p-j>n$，$s(n,j)=0$时间复杂度  $\mathcal{O}(\frac{n^{{\frac{3}{4}}}}{\log-2n})$ </p><h2 id="例题">例题</h2><h3 id="区间素数个数">区间素数个数</h3><blockquote><p><a href="https://loj.ac/problem/6235">题目链接</a></p></blockquote><p>因为<span class="math inline">\(F(i)=0\text{,}i\notin prime\)</span> 所以这道题只需要算<span class="math inline">\(g\)</span>，且<span class="math inline">\(f(i)=1\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4e6</span> + <span class="hljs-number">50</span>;<br>ll n, id1[N], id2[N], g[N], p[N], w[N], sqr;<br><span class="hljs-keyword">int</span> cnt, m;<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= m; j++) &#123;<br>vis[i * p[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>sqr = <span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-built_in">init</span>(sqr);<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>    r = n / (n / l);<br>w[++m] = n / l;<br>g[m] = w[m] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (w[m] &lt;= sqr) id1[w[m]] = m;<br><span class="hljs-keyword">else</span> id2[r] = m;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; p[j] * p[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / p[j] &lt;= sqr) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];<br>g[i] = g[i] - (g[k] - j + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, g[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="简单函数">简单函数</h3><blockquote><p><a href="https://loj.ac/problem/6053">题目链接</a></p></blockquote><p>因为除了<span class="math inline">\(2\)</span>的所有约数都是奇数。 可以令所有<span class="math inline">\(f(i)=i-1\)</span>，特别的<span class="math inline">\(f(2)\)</span>加上<span class="math inline">\(2\)</span>即可。 直接套板子就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, inv2 = (MOD + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>ll id1[N], id2[N], n, m, g[N], h[N], P[N], sum[N], w[N];<br><span class="hljs-keyword">int</span> cnt, tot;<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) P[++cnt] = i, sum[cnt] = (sum[cnt - <span class="hljs-number">1</span>] + i) % MOD;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; P[j] * i &lt;= m; j++) &#123;<br>vis[P[j] * i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % P[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">fpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>ll res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % MOD;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">S</span><span class="hljs-params">(ll x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span> || P[y] &gt; x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = (x &lt;= m) ? id1[x] : id2[n / x];<br>ll res = (g[k] - sum[y - <span class="hljs-number">1</span>] - h[k] + y - <span class="hljs-number">1</span> + MOD) % MOD;<br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">1</span>) res += <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = y; i &lt;= cnt &amp;&amp; P[i] * P[i] &lt;= x; i++) &#123;<br>ll pow1 = P[i], pow2 = P[i] * P[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e = <span class="hljs-number">1</span>; pow2 &lt;= x; e++, pow1 = pow2, pow2 *= P[i]) &#123;<br>ll tmp = (<span class="hljs-built_in">S</span>(x / pow1, i + <span class="hljs-number">1</span>) * (P[i] ^ e) % MOD + (P[i] ^ (e + <span class="hljs-number">1</span>))) % MOD;<br>    res = (res + tmp) % MOD;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>m = <span class="hljs-built_in">sqrt</span>(n + <span class="hljs-number">0.5</span>);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>r = n / (n / l);<br>w[++tot] = n / l;<br>h[tot] = w[tot] % MOD - <span class="hljs-number">1</span>;<br>g[tot] = w[tot] % MOD * (w[tot] + <span class="hljs-number">1</span>) % MOD * inv2 % MOD;<br>g[tot] = (g[tot] - <span class="hljs-number">1</span> + MOD) % MOD;<br><span class="hljs-keyword">if</span> (w[tot] &gt; m) id2[r] = tot;<br><span class="hljs-keyword">else</span> id1[w[tot]] = tot;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot &amp;&amp; P[j] * P[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / P[j] &lt;= m) ? id1[w[i] / P[j]] : id2[n / (w[i] / P[j])];<br>g[i] = (g[i] - (P[j] * ((g[k] - sum[j - <span class="hljs-number">1</span>] + MOD) % MOD)) % MOD + MOD) % MOD;<br>    h[i] = (h[i] - h[k] + j - <span class="hljs-number">1</span> + MOD) % MOD;<br>&#125;<br>ll ans = (<span class="hljs-built_in">S</span>(n, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) % MOD;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (ans + MOD) % MOD);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="min-25筛-1">Min-25筛</h3><blockquote><p><a href="https://www.luogu.com.cn/problem/P5325">题目链接</a></p></blockquote><p><span class="math inline">\(F(p)=p(p-1)=p^2-p\)</span> 因为要求我们的<span class="math inline">\(f\)</span>函数完全积性，所以令<span class="math inline">\(f(i)=i^2\)</span>，<span class="math inline">\(f&#39;(i)=i\)</span> 定义二元组<span class="math inline">\(g(n,j)=\sum\limits-{i=2}^{n}f(i)[i\in prime\vee r(i) &gt; p[j]]\)</span> ，<span class="math inline">\(h(n,j)=\sum\limits-{i=2}^{n}f&#39;(i)[i\in prime\vee r(i) &gt; p[j]]\)</span></p><p>则<span class="math inline">\(s(n,j)=g(n,cnt)-h(n,cnt)-\sum\limits-{i=1}^{j-1}{p-i}^2-p-i\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4e6</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> ll i6 = <span class="hljs-number">166666668</span>, i2 = <span class="hljs-number">500000004</span>;<br>ll n, id1[N], id2[N], su1[N], su2[N], p[N], sqr, w[N], g[N], h[N];<br><span class="hljs-keyword">int</span> cnt, m;<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function">ll <span class="hljs-title">add</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> (a + b &gt;= MOD) ? a + b - MOD : a + b;&#125;<br><span class="hljs-function">ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> a * b % MOD;&#125;<br><span class="hljs-function">ll <span class="hljs-title">dec</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;a %= MOD, b %= MOD; <span class="hljs-keyword">return</span> ((a - b) % MOD + MOD) % MOD;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) p[++cnt] = i, su1[cnt] = <span class="hljs-built_in">add</span>(su1[cnt - <span class="hljs-number">1</span>], i), su2[cnt] = <span class="hljs-built_in">add</span>(su2[cnt - <span class="hljs-number">1</span>], <span class="hljs-built_in">mul</span>(i, i));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= m; j++) &#123;<br>vis[p[j] * i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">S</span><span class="hljs-params">(ll x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (p[y] &gt; x || x &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = (x &lt;= sqr) ? id1[x] : id2[n / x];<br>ll res = <span class="hljs-built_in">dec</span>(<span class="hljs-built_in">dec</span>(g[k], h[k]), <span class="hljs-built_in">dec</span>(su2[y - <span class="hljs-number">1</span>], su1[y - <span class="hljs-number">1</span>]));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = y; i &lt;= cnt &amp;&amp; p[i] * p[i] &lt;= x; i++) &#123;<br>ll pow1 = p[i], pow2 = p[i] * p[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e = <span class="hljs-number">1</span>; pow2 &lt;= x; pow1 = pow2, pow2 *= p[i], e++) &#123;<br>ll tmp = <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">mul</span>(pow1, <span class="hljs-built_in">dec</span>(pow1, <span class="hljs-number">1</span>)), <span class="hljs-built_in">S</span>(x / pow1, i + <span class="hljs-number">1</span>));<br>tmp = <span class="hljs-built_in">add</span>(tmp, <span class="hljs-built_in">mul</span>(pow2, <span class="hljs-built_in">dec</span>(pow2, <span class="hljs-number">1</span>)));<br>res = <span class="hljs-built_in">add</span>(res, tmp);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>sqr = <span class="hljs-built_in">sqrt</span>(n + <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">init</span>(sqr);<br><span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = n / (n / l);<br>w[++m] = n / l;<br>g[m] = <span class="hljs-built_in">mul</span>(w[m] % MOD, (w[m] + <span class="hljs-number">1</span>) % MOD);<br>g[m] = <span class="hljs-built_in">mul</span>(g[m], (<span class="hljs-number">2</span> * w[m] + <span class="hljs-number">1</span>) % MOD);<br>g[m] = <span class="hljs-built_in">mul</span>(g[m], i6);<br>        g[m] = <span class="hljs-built_in">dec</span>(g[m], <span class="hljs-number">1</span>);<br>h[m] = <span class="hljs-built_in">mul</span>(w[m] % MOD, (w[m] + <span class="hljs-number">1</span>) % MOD);;<br>    h[m] = <span class="hljs-built_in">mul</span>(h[m], i2);<br>h[m] = <span class="hljs-built_in">dec</span>(h[m], <span class="hljs-number">1</span>);<br>    (w[m] &lt;= sqr) ? id1[w[m]] = m : id2[r] = m;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; p[j] * p[j] &lt;= w[i]; i++) &#123;<br><span class="hljs-keyword">int</span> k = (w[i] / p[j] &lt;= sqr) ? id1[w[i] / p[j]] : id2[n / (w[i] / p[j])];<br>    g[i] = <span class="hljs-built_in">dec</span>(g[i], <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">mul</span>(p[j], p[j]), <span class="hljs-built_in">dec</span>(g[k], su2[j - <span class="hljs-number">1</span>])));<br>h[i] = <span class="hljs-built_in">dec</span>(h[i], <span class="hljs-built_in">mul</span>(p[j], <span class="hljs-built_in">dec</span>(h[k], su1[j - <span class="hljs-number">1</span>])));<br>&#125;<br><span class="hljs-comment">//printf(&quot;%lld\n&quot;, g[1] - h[1]);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">add</span>(<span class="hljs-built_in">S</span>(n, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>min-25筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 3152 取数游戏</title>
    <link href="/2020/09/18/51nod_3152_%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <url>/2020/09/18/51nod_3152_%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=3152">题目链接</a></p></blockquote><p><del>我甚至不知道数大小是多少？</del> <span id="more"></span> 因为要选一半的数，所以每个数被选的概率是<span class="math inline">\(\frac{1}{2}\)</span><br />我们直接随机一个数，它大概率最后会被选。</p><p>那么现在只用计算这个数最后被选时，可能的<span class="math inline">\(\gcd\)</span>是多少。<br /><span class="math inline">\(\gcd\)</span>一定是数<span class="math inline">\(x\)</span> 的一个约数，所以分解<span class="math inline">\(x\)</span>后求出所有约数。<br />求出所有<span class="math inline">\(a-i\)</span>和<span class="math inline">\(x\)</span>的<span class="math inline">\(\gcd\)</span>，用桶<span class="math inline">\(cnt[i]\)</span>记录每个<span class="math inline">\(\gcd\)</span>出现的次数。<br />要求每一个约数的<span class="math inline">\(cnt\)</span>，只需要找到所有的<span class="math inline">\(d\mid d-i\)</span>，<span class="math inline">\(cnt-d\text{加上}cnt-{d-i}\)</span>。 而不用每一个数都唯一分解暴力找。<br />因为对于当前要求的<span class="math inline">\(cnt-d，\)</span><span class="math inline">\(a-i\)</span>和<span class="math inline">\(x\)</span>的<span class="math inline">\(\gcd\)</span>无非两种情况<br />1. <span class="math inline">\(\gcd(a-i,x)=d\)</span>，这种情况已经记录。<br />2. 另一种是<span class="math inline">\(g=\gcd(a-i,x)\)</span>不等于<span class="math inline">\(d\)</span>，如果<span class="math inline">\(d\mid g\)</span>，这个<span class="math inline">\(a-i\)</span>也要记到<span class="math inline">\(cnt-d\)</span>贡献里面。</p><p>注意在算<span class="math inline">\(cnt\)</span>时的顺序，更新<span class="math inline">\(cnt-{\gcd}\)</span>以后应该从小的数更新到大的数，不然有可能会算重。因为只能从<span class="math inline">\(\gcd\)</span>那里更新下来</p><p>最后扫一遍<span class="math inline">\(cnt\)</span>数组，更新所有<span class="math inline">\(cnt-i\geq\left\lceil\frac{n}{2}\right\rceil\)</span></p><p>假设随机<span class="math inline">\(k\)</span>次，时间复杂度<span class="math inline">\(\mathcal{O}(k(n\log a+\sqrt{a}+\sigma(a)^2))\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> n, a[N], vis[N], ans, p[N], e[N], tot;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>unordered-map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;p[++tot] = <span class="hljs-number">1</span>, e[tot] = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">int</span> qaq = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, qaq++;<br>p[++tot] = i, e[tot] = qaq;<br>&#125;<br><span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) p[++tot] = x, e[tot] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == tot + <span class="hljs-number">1</span>) &#123;<br>v.push-<span class="hljs-built_in">back</span>(res);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> now = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= e[x]; i++, now = now * p[x]) &#123;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, res * now);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    v.<span class="hljs-built_in">clear</span>();<br>cnt.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">div</span>(a[id]);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    stable-<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cnt[<span class="hljs-built_in">gcd</span>(a[id], a[i])]++;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; v.<span class="hljs-built_in">size</span>(); j++) &#123;<br><span class="hljs-keyword">if</span> (v[j] % v[i] == <span class="hljs-number">0</span>) cnt[v[i]] += cnt[v[j]];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-keyword">if</span> (cnt[v[i]] &gt;= n / <span class="hljs-number">2</span>) ans = <span class="hljs-built_in">max</span>(ans, v[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> - = <span class="hljs-number">1</span>; - &lt;= <span class="hljs-built_in">min</span>(n, <span class="hljs-number">10</span>); -++) &#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-built_in">rand</span>() % n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (vis[x]) x = <span class="hljs-built_in">rand</span>() % n + <span class="hljs-number">1</span>;<br>vis[x] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">solve</span>(x);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>思维好题</tag>
      
      <tag>唯一分解定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2038 超能粒子炮・改</title>
    <link href="/2020/09/17/LOJ_2038_%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE%E3%83%BB%E6%94%B9/"/>
    <url>/2020/09/17/LOJ_2038_%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE%E3%83%BB%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2038">题目链接</a></p></blockquote><h2 id="题目">题目</h2><p>求<span class="math inline">\(\sum\limits-{i=0}^{k}\binom{n}{i}\bmod 2333\)</span><br /><span id="more"></span> ## 分析<br />用卢卡斯定理拆组合数。<br /><span class="math inline">\(\sum\limits-{i=0}^{k}\binom{n/p}{i/p}\binom{n\bmod p}{i\bmod p}\bmod 2333\)</span></p><p>观察一下发现等于,<br /><span class="math inline">\(\binom{n/p}{0}\sum\limits-{i=0}^{p-1}\binom{n\bmod p}{i}+\binom{n/p}{1}\sum\limits-{i=0}^{p-1}\binom{n\bmod p}{i}+\binom{n/p}{2}\sum\limits-{i=0}^{p-1}\binom{n\bmod p}{i}+\text{...}+\binom{n/p}{k/p}\sum\limits-{i=0}^{k\bmod p}\binom{n\bmod p}{i}\)</span></p><p>也就是<span class="math inline">\(\left\{\binom{n/p}{0}+\binom{n/p}{1} +\text{...}+{\binom{n/p}{n/p-1}}\right\}\times \sum\limits-{i=0}^{p-1}\binom{n\bmod p}{i}+\binom{n/p}{k/p}\sum\limits-{i=0}^{k\bmod p}\binom{n\bmod p}{i}\)</span></p><p>我们令<span class="math inline">\(f(n,k)\)</span>表示<span class="math inline">\(\sum\limits-{i=0}^{k}\binom{n}{i} \bmod 2333\)</span><br />则<span class="math inline">\(f(n,k)=f(n/p,n/p-1)\times f(n\bmod p,p-1)+f(n\bmod p,k\bmod p)\times \binom{n/p}{k/p}\)</span><br />显然取模的可以暴力预处理，除号用卢卡斯定理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2345</span>, MOD = <span class="hljs-number">2333</span>;<br><span class="hljs-keyword">int</span> T, n, k, f[N][N], c[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lucas</span>(n / MOD, m / MOD) * <span class="hljs-number">1ll</span> * c[n % MOD][m % MOD] % MOD;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &lt; MOD &amp;&amp; k &lt; MOD) <span class="hljs-keyword">return</span> f[n][k];<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">F</span>(n / MOD, k / MOD - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * f[n % MOD][MOD - <span class="hljs-number">1</span>] % MOD + <span class="hljs-built_in">lucas</span>(n / MOD, k / MOD) * <span class="hljs-number">1ll</span> * f[n % MOD][k % MOD] % MOD) % MOD;<br>&#125;<br><br><span class="hljs-built_in">main</span>() &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;T);<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == i) c[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + c[i - <span class="hljs-number">1</span>][j]) % MOD;<br>&#125;<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) f[i][j] = c[i][j];<br><span class="hljs-keyword">else</span> f[i][j] = (f[i][j - <span class="hljs-number">1</span>] + c[i][j]) % MOD;<br>&#125;<br><span class="hljs-keyword">while</span> (T--) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">F</span>(n, k));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
      <tag>卢卡斯定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 1034 泡泡堂BNB</title>
    <link href="/2020/09/17/BZOJ_1034_%E6%B3%A1%E6%B3%A1%E5%A0%82BNB/"/>
    <url>/2020/09/17/BZOJ_1034_%E6%B3%A1%E6%B3%A1%E5%A0%82BNB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://darkbzoj.tk/problem/1034">题目链接</a></p></blockquote><p>田忌赛马 <span id="more"></span> 1. 如果最强的能赢最强的，先赢一把 2. 最弱的能赢最弱的，先赢一把<br />3. 否则用最弱的打最强的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">int</span> n, a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> l1 = <span class="hljs-number">1</span>, r1 = n, l2 = <span class="hljs-number">1</span>, r2 = n, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) &#123;<br><span class="hljs-keyword">if</span> (a[l1] &gt; b[l2]) res += <span class="hljs-number">2</span>, l1++, l2++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[r1] &gt; b[r2]) res += <span class="hljs-number">2</span>, r1--, r2--;<br><span class="hljs-keyword">else</span> res += (a[l1] == b[r2]), l1++, r2--;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]); <br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n), <span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, <span class="hljs-built_in">solve</span>(a, b), n + n - <span class="hljs-built_in">solve</span>(b, a));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 6165  一道水题</title>
    <link href="/2020/09/17/LOJ_6165__%E4%B8%80%E9%81%93%E6%B0%B4%E9%A2%98/"/>
    <url>/2020/09/17/LOJ_6165__%E4%B8%80%E9%81%93%E6%B0%B4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6165">题目链接</a></p></blockquote><p>把每个数唯一分解<span class="math inline">\(n=\prod p-i^{e-i}\)</span>，显然最终答案的每个质因数指数都不小于<span class="math inline">\([1,n]\)</span>的每个数分解的指数。<br />但是这样是<span class="math inline">\(\mathcal{O}(n\sqrt{n})\)</span>的。</p><p>我们只用关心每个质数最大的<span class="math inline">\(e-i\)</span>是多少。<br />显然是其他数都是<span class="math inline">\(1\)</span>的时候，不断用<span class="math inline">\(n\)</span>除就能得到<span class="math inline">\(e-i\)</span>的值。</p><p>话说我怎么要用<span class="math inline">\(bitset\)</span>才能过这道题啊...</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e8</span> + <span class="hljs-number">4</span>, MOD = <span class="hljs-number">100000007</span>;<br><span class="hljs-keyword">int</span> P[<span class="hljs-number">6200000</span>], tot, n;<br>bitset&lt;N&gt; vis;<br><br>ll qaq = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) P[++tot] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; P[j] * i &lt;= n; j++) &#123;<br>vis[i * P[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % P[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">init</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) &#123;<br>        <span class="hljs-keyword">int</span> d = n, p = P[i];<br><span class="hljs-keyword">while</span> (d / p) d /= p, qaq = qaq * <span class="hljs-number">1ll</span> * p % MOD;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, qaq);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唯一分解定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6713 [CCO2018] Geese vs. Hawks</title>
    <link href="/2020/09/17/P6713_%5BCCO2018%5D_Geese_vs._Hawks/"/>
    <url>/2020/09/17/P6713_%5BCCO2018%5D_Geese_vs._Hawks/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译好像没太说清楚啊?QAQ<br /><span id="more"></span> ## 题意<br />两个人分别在看两支球队比赛, 并且只记录了自己观看一方的胜负和得分.<br />现在问你,是否能够从两个人的记录中选出一些合法的比赛,使得分之和最大.<br />合法的意思是赢了的一方得分比对方高.<br />注意没选的比赛也要合法.(这就是为什么第二个样例没有选<span class="math inline">\((2,3)\)</span>的原因)</p></blockquote><h2 id="题解">题解</h2><p>并没有要求打印方案,所以有一个很好想的<span class="math inline">\(DP\)</span>?<br />设<span class="math inline">\(f[i][j]\)</span>表示考虑了第一个人的前<span class="math inline">\(i\)</span>个记录,第二个人的前<span class="math inline">\(j\)</span>个记录时的最优答案.<br />转移的时候先令<span class="math inline">\(f[i][j]=max(f[i-1][j],f[i][j-1])\)</span>.<br />然后如果<span class="math inline">\((i,j)\)</span>合法,<span class="math inline">\(f[i][j]=max(f[i][j],f[i-1][j-1]+a[i]+b[j]\)</span>.<br />其实就是<span class="math inline">\(LCS\)</span>模型吧.</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n, a[N], b[N];<br><span class="hljs-keyword">char</span> S[N], T[N];<br><br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>&amp; res = f[i][j];<br>    <span class="hljs-keyword">if</span> (~res) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">if</span>(S[i] != T[j] &amp;&amp; ((S[i] == <span class="hljs-string">&#x27;W&#x27;</span> &amp;&amp; a[i] &gt; b[j]) || (T[j] == <span class="hljs-string">&#x27;W&#x27;</span> &amp;&amp; b[j] &gt; a[i]))) res = <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + a[i] + b[j];<br>    <span class="hljs-keyword">return</span> res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j), <span class="hljs-built_in">dfs</span>(i, j - <span class="hljs-number">1</span>)));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, T);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4173 残缺的字符串</title>
    <link href="/2020/09/17/P4173_%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/09/17/P4173_%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更精彩内容看这个巨佬的<a href="https://www.luogu.com.cn/blog/Ebola-Emperor/solution-p4173">博文</a></p></blockquote><p>没想到字符串匹配还能这么玩<br /><span id="more"></span> 把比较两个字符串的过程形式化, 判断两个字符串相等<span class="math inline">\(a[i]-b[i]=0\)</span><br />普通的模式串匹配<br />若模式串与另一个串以<span class="math inline">\(x\)</span>结尾的字串匹配, 即<span class="math inline">\(P(x)=\sum\limits-{i=0}^{m-1}(a[i]-b[x-m+i+1])=0\)</span>.<br />但是这样是有问题的,两个字符串只要字符种类和个数相同就被认为匹配了...<br />原因是会出现负号...<br />令<span class="math inline">\(P(x)=\sum\limits-{i=0}^{m-1}(a[i]-b[x-m+i+1])^2\)</span>就解决这个问题了.<br />大力展开式子并翻转 a 串, 可以发现第三项是卷积形式, 可以用 FFT 优化</p><p>那么通配符怎么办? 重新设计<span class="math inline">\(P(x)\)</span>, 我们只需要让通配符的匹配函数都等于<span class="math inline">\(0\)</span>就可以了.<br />把 * 对应<span class="math inline">\(0\)</span>, 就是满足<span class="math inline">\(P(x)=\sum\limits-{i=0}^{m-1}(a[i]-b[x-m+i+1])^2a[i]b[x-m+i+1]=0\)</span>.<br />大力展开式子, <span class="math inline">\(P(x)=\sum\limits-{i=0}^{m-1}a[i]b[x-m+i+1]^3+a[i]^3b[x-m+i+1]+2a[i]^2b[x-m+i+1]^2\)</span><br />翻转一下 a 串, 即<span class="math inline">\(a[i]=a&#39;[m-i-1]\)</span>.<br /><span class="math inline">\(P(x)=\sum\limits-{i=0}^{m-1}a&#39;[m-i-1]b[x-m+i+1]^3+a&#39;[m-i-1]^3b[x-m+i+1]+2a&#39;[m-i-1]^2b[x-m+i+1]^2\)</span><br />可以发现这三个都是卷积形式, 所以做三次 FFT, 一次 IFFT就可以解决问题了.<br />时间复杂度<span class="math inline">\(\mathcal{O}(n\log n)\)</span>, 常数有点大, 还有这道题卡精度, 把 eps 设置大一点可过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y1 gmdllll</span><br><span class="hljs-keyword">typedef</span> complex&lt;<span class="hljs-keyword">double</span>&gt; cp;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1200005</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>), eps = <span class="hljs-number">0.05</span>;<br><span class="hljs-keyword">int</span> n, m, rev[N];<br><span class="hljs-keyword">double</span> x1[N], y1[N];<br>cp a[N], b[N], p[N];<br><span class="hljs-keyword">char</span> x[N], y[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(cp *a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> inv)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function">cp <span class="hljs-title">wn</span><span class="hljs-params">(cos(pi / k), inv * sin(pi / k))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;<br><span class="hljs-function">cp <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++, w *= wn) &#123;<br>cp x = a[i + j], y = w * a[i + j + k];<br>a[i + j] = x + y, a[i + j + k] = x - y;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (inv &lt; <span class="hljs-number">0.0</span>) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) a[i] /= n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>, x , y);<br>    <span class="hljs-built_in">reverse</span>(x, x + m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) x1[i] = (x[i] == <span class="hljs-string">&#x27;*&#x27;</span>) ? <span class="hljs-number">0.0</span> : (x[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) y1[i] = (y[i] == <span class="hljs-string">&#x27;*&#x27;</span>) ? <span class="hljs-number">0.0</span> : (y[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="hljs-number">1</span>, l++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (l - <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) a[i] = <span class="hljs-built_in">cp</span>(x1[i], <span class="hljs-number">0.0</span>), b[i] = <span class="hljs-built_in">cp</span>((y1[i]) * (y1[i]) * (y1[i]), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) p[i] += a[i] * b[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) a[i] = <span class="hljs-built_in">cp</span>((x1[i]) * (x1[i]) * (x1[i]), <span class="hljs-number">0.0</span>), b[i] = <span class="hljs-built_in">cp</span>(y1[i], <span class="hljs-number">0.0</span>);<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) p[i] += a[i] * b[i];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) a[i] = <span class="hljs-built_in">cp</span>((x1[i]) * (x1[i]), <span class="hljs-number">0.0</span>), b[i] = <span class="hljs-built_in">cp</span>((y1[i]) * (y1[i]), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) p[i] -= <span class="hljs-built_in">cp</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>) * a[i] * b[i];<br>    <span class="hljs-built_in">fft</span>(p, len, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">int</span> v[N], top = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(p[i].<span class="hljs-built_in">real</span>()) &lt; eps) v[++top] = i - m + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, top);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= top; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>字符串</tag>
      
      <tag>FFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2074 灯塔</title>
    <link href="/2020/09/16/LOJ_2074_%E7%81%AF%E5%A1%94/"/>
    <url>/2020/09/16/LOJ_2074_%E7%81%AF%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2074">题目链接</a></p></blockquote><p>题目要求<span class="math inline">\(p-i\geq h-j+\sqrt{|i-j|}-h-i\)</span><br /><span id="more"></span> 即<span class="math inline">\(p-i=\max\limits-{j=1}^{n}h-j+\left\lceil\sqrt{|i-j|}\right\rceil -h-i\)</span></p><p>因为可以观察的到<span class="math inline">\(\left\lceil\sqrt{|i-j|}\right\rceil\)</span>取值个数是<span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span>的。<br />所以枚举所有长度根号的上取整值，<span class="math inline">\(RMQ\)</span>上查询对应区间的最大最小值。<br />即可<span class="math inline">\(\mathcal{O}(n\log n+n\sqrt{n})\)</span>时间内完成。</p><p><del>据说还有<span class="math inline">\(\mathcal{O}(n\log n)\)</span>的做法，咱也不会啊...</del><br /><del>这题把高度改成小数就没法把小数改成上取整的了，这做法不就被卡了吗</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, a[N], cnt, f[N][<span class="hljs-number">21</span>], lo[N];<br>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; sq[N / <span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(n * <span class="hljs-number">1.0</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>; i++) &#123;<br>f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) lo[i] = lo[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>i = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, i), j = <span class="hljs-built_in">min</span>(j, n);<br>    <span class="hljs-keyword">int</span> len = j - i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> res = <span class="hljs-built_in">max</span>(f[i][lo[len]], f[j - (<span class="hljs-number">1</span> &lt;&lt; lo[len]) + <span class="hljs-number">1</span>][lo[len]]);<br><span class="hljs-keyword">return</span> res + k - a[now];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">int</span> head = <span class="hljs-number">1</span>,  now = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">sqrt</span>(i) != now) &#123;<br>            sq[++cnt] = &#123;head, i - <span class="hljs-number">1</span>&#125;;<br>now = <span class="hljs-built_in">sqrt</span>(i);<br>head = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (head != n + <span class="hljs-number">1</span>) sq[++cnt] = &#123;head, n&#125;;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> le = <span class="hljs-number">1</span>, re = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; j++) &#123;<br><span class="hljs-keyword">if</span> (!le &amp;&amp; !re) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">int</span> l = sq[j].first, r = sq[j].second;<br><span class="hljs-keyword">if</span> (le) res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">qry</span>(i - r, i - l, i, j), res);<br><span class="hljs-keyword">if</span> (re) res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">qry</span>(i + l, i + r, i, j), res);<br><span class="hljs-keyword">if</span> (i - r &lt;= <span class="hljs-number">1</span>) le = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (i + r &gt;= n) re = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分块</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 3894 文理分科</title>
    <link href="/2020/09/16/BZOJ_3894_%E6%96%87%E7%90%86%E5%88%86%E7%A7%91/"/>
    <url>/2020/09/16/BZOJ_3894_%E6%96%87%E7%90%86%E5%88%86%E7%A7%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://darkbzoj.tk/problem/3894">题目链接</a></p></blockquote><p>最小割经典模型<br />把文科看做源点，理科为汇点。<br />不考虑额外收益的情况下，直接连接对应的点到源点，如<span class="math inline">\((s,u)\)</span>，或者<span class="math inline">\((u,t)\)</span>。</p><p>考虑额外收益，用一个虚点表示一个點集。<br />虚点向點集每个点连一条<span class="math inline">\(inf\)</span>的边，向源点或者汇点连权值为<span class="math inline">\(value\)</span> 的边。<br />所以虚点连向点集的边不会断开，而且只有一组点集在同一个集合的时候，虚点所对应的收益边才不会断开，而另一个集合一定会断开，否则就不能满足<span class="math inline">\(s,t\)</span>不联通。<br />所以这样建边是正确的，跑一次最小割，把总共的收益减去断开的收益。</p><p><del>dbzoj评测机挂掉了，不知道下面代码能不能AC</del></p><blockquote><p>upd:改下数组大小在luogu过了，那没事了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">30005</span>, M = <span class="hljs-number">300005</span>, inf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, head[N], cnt = <span class="hljs-number">1</span>, dis[N], now[N], tot;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br>    <span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>    e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>    e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) dis[i] = inf;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    now[s] = head[s];<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e[i].v;<br>            <span class="hljs-keyword">if</span> (dis[v] == inf &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>                dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>                now[v] = head[v];<br>                q.<span class="hljs-built_in">push</span>(v);<br>                <span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br>    <span class="hljs-keyword">int</span> k, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].v;<br>        now[u] = i;<br>        <span class="hljs-keyword">if</span> (dis[v] == dis[u] + <span class="hljs-number">1</span> &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>            k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>            e[i].w -= k;<br>            e[i ^ <span class="hljs-number">1</span>].w += k;<br>            res += k;<br>            sum -= k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) res += <span class="hljs-built_in">dfs</span>(s, inf);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) * m + j; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>tot = n * m;<br>s = ++tot, t = ++tot; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>res += x;<br><span class="hljs-built_in">add</span>(s, <span class="hljs-built_in">pos</span>(i, j), x);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>res += x;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i, j), t, x);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><span class="hljs-keyword">int</span> ss = ++tot, x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>res += x;<br><span class="hljs-built_in">add</span>(s, ss, x);<br><span class="hljs-built_in">add</span>(ss, <span class="hljs-built_in">pos</span>(i, j), inf);<br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(ss, <span class="hljs-built_in">pos</span>(i - <span class="hljs-number">1</span>, j), inf);<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(ss, <span class="hljs-built_in">pos</span>(i, j - <span class="hljs-number">1</span>), inf);<br><span class="hljs-keyword">if</span> (i &lt; n) <span class="hljs-built_in">add</span>(ss, <span class="hljs-built_in">pos</span>(i + <span class="hljs-number">1</span>, j), inf);<br><span class="hljs-keyword">if</span> (j &lt; m) <span class="hljs-built_in">add</span>(ss, <span class="hljs-built_in">pos</span>(i, j + <span class="hljs-number">1</span>), inf);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><span class="hljs-keyword">int</span> tt = ++tot, x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>res += x;<br><span class="hljs-built_in">add</span>(tt, t, x);<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i, j), tt, inf);<br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i - <span class="hljs-number">1</span>, j), tt, inf);<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i, j - <span class="hljs-number">1</span>), tt, inf);<br><span class="hljs-keyword">if</span> (i &lt; n) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i + <span class="hljs-number">1</span>, j), tt, inf);<br><span class="hljs-keyword">if</span> (j &lt; m) <span class="hljs-built_in">add</span>(<span class="hljs-built_in">pos</span>(i, j + <span class="hljs-number">1</span>), tt, inf);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res - <span class="hljs-built_in">dinic</span>(s, t));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P2057 Vote 善意的投票</title>
    <link href="/2020/09/16/P2057_Vote_%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8/"/>
    <url>/2020/09/16/P2057_Vote_%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P2057">题目链接</a></p></blockquote><p>最小割经典模型<br /><span id="more"></span> 把投票的<span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span>分别看作源点和汇点。<br />每个小朋友都和自己投票的种类连一条边。<br />而好朋友直接也连一条边。</p><p>如果好朋友不在一个集合，他们的边会断，反之不会。<br />而自己不在想投的集合，边会断，反之不会。</p><p>要求断边最小，把所有边权设为<span class="math inline">\(1\)</span>跑一次最小割就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">305</span>, M = N * N * <span class="hljs-number">2</span>, inf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, head[N], cnt = <span class="hljs-number">1</span>, dis[N], now[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">2</span>; i++) dis[i] = inf;<br>dis[s] = <span class="hljs-number">0</span>;<br>now[s] = head[s];<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (dis[v] == inf &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>    dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>now[v] = head[v];<br>q.<span class="hljs-built_in">push</span>(v);<br><span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br><span class="hljs-keyword">int</span> k, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br>now[u] = i;<br><span class="hljs-keyword">if</span> (dis[v] == dis[u] + <span class="hljs-number">1</span> &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>e[i].w -= k;<br>e[i ^ <span class="hljs-number">1</span>].w += k;<br>res += k;<br>sum -= k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) res += <span class="hljs-built_in">dfs</span>(s, inf);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>s = n + <span class="hljs-number">1</span>, t = n + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-built_in">add</span>(s, i, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(i ,t, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br><span class="hljs-built_in">add</span>(u, v, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">add</span>(v, u, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dinic</span>(s, t));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1361 小M的作物</title>
    <link href="/2020/09/16/P1361_%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9/"/>
    <url>/2020/09/16/P1361_%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P1361">题目链接</a></p></blockquote><p>看了下题解，感觉很神奇，所以记录一下。<br /><span id="more"></span> 先不考虑组合，很显然是最小割的经典模型。<br />所有点<span class="math inline">\(u\)</span>都从<span class="math inline">\(s\)</span>向它连一条边，<span class="math inline">\(u\)</span>向<span class="math inline">\(t\)</span>连一条边</p><p>因为最后<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>要在两个集合，所以每个点都会断一条边。<br /><span class="math inline">\((u,t)\)</span>断开代表<span class="math inline">\(u\)</span>在<span class="math inline">\(s\)</span>的集合中，求出最小割，用总收益减去断掉的边。</p><p>现在有组合，考虑一个點集对<span class="math inline">\(A\)</span>的贡献<br />假设这个點集是<span class="math inline">\(\{u,v,w \}\)</span>，如果有一个点不在<span class="math inline">\(A\)</span>中，那么點集对<span class="math inline">\(A\)</span>是没有贡献的。</p><p>我们建一个虚点，用这个虚点代表一个點集。并虚点向<span class="math inline">\(A\)</span>连一个<span class="math inline">\(c\)</span>的边，虚点向组合里的数连<span class="math inline">\(inf\)</span>的边。<br />所以组合里面的边不会断，而虚点断不断代表组合在哪个集合。</p><p>可以发现这样建边是正确的，跑一遍最小割就知道要断的权值了。</p><p><del>少女口阿</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3005</span>, M = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>, inf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, dis[N], head[N], cnt = <span class="hljs-number">1</span>, tot, now[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br>    <span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) dis[i] = inf;<br>    dis[s] = <span class="hljs-number">0</span>; now[s] = head[s];<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e[i].v;<br>            <span class="hljs-keyword">if</span> (dis[v] == inf &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>                dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>                now[v] = head[v];<br>                q.<span class="hljs-built_in">push</span>(v);<br>                <span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br>    <span class="hljs-keyword">int</span> k, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br>        now[u] = i;<br>        <span class="hljs-keyword">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (dis[v] == dis[u] + <span class="hljs-number">1</span> &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>            k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>            e[i].w -= k;<br>            e[i ^ <span class="hljs-number">1</span>].w += k;<br>            sum -= k;<br>            res += k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>())  res += <span class="hljs-built_in">dfs</span>(s, inf);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>tot = n;<br>s = ++tot, t = ++tot;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-built_in">add</span>(s, i, x);<br>res += x;<br>&#125; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-built_in">add</span>(i, t, x);<br>res += x;<br>&#125;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> z, x, y, ss = ++tot, tt = ++tot;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;z);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><span class="hljs-built_in">add</span>(s, ss, x);<br><span class="hljs-built_in">add</span>(tt, t, y);<br>res += x + y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= z; j++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;y);<br>            <span class="hljs-built_in">add</span>(ss, y, inf);<br><span class="hljs-built_in">add</span>(y, tt, inf);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res - <span class="hljs-built_in">dinic</span>(s, t));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思维好题</tag>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1345 Telecowmunication</title>
    <link href="/2020/09/16/P1345_Telecowmunication/"/>
    <url>/2020/09/16/P1345_Telecowmunication/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P1345">题目链接</a></p></blockquote><p>这道题是删点<br />那我们想办法把它变成删边的题，就是删除某条边和删一个点效果一样<br /><span id="more"></span> 把每个点<span class="math inline">\(i\)</span>拆成<span class="math inline">\(i+n\)</span>和<span class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span>连入边，<span class="math inline">\(i+n\)</span>连所有出边。<br />再把<span class="math inline">\(i\)</span>和<span class="math inline">\(i+n\)</span>连上一条边。<br />那么删除<span class="math inline">\(i\)</span>和<span class="math inline">\(i+n\)</span>间的边和删除<span class="math inline">\(i\)</span>点效果一样<br />就变成了求最小割的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">205</span>, M = <span class="hljs-number">2605</span>, inf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">25</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, head[N], cnt = <span class="hljs-number">1</span>, dis[N], now[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br>    <span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>    e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>    e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) dis[i] = inf;<br>    dis[s] = <span class="hljs-number">0</span>; now[s] = head[s];<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>            <span class="hljs-keyword">int</span> v = e[i].v;<br>            <span class="hljs-keyword">if</span> (dis[v] == inf &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>                dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>                now[v] = head[v];<br>                q.<span class="hljs-built_in">push</span>(v);<br>                <span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br>    <span class="hljs-keyword">int</span> k, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br>        now[u] = i;<br><span class="hljs-keyword">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span> (dis[v] == dis[u] + <span class="hljs-number">1</span> &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>            k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>            e[i].w -= k;<br>            e[i ^ <span class="hljs-number">1</span>].w += k;<br>            sum -= k;<br>            res += k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>())  res += <span class="hljs-built_in">dfs</span>(s, inf);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(i, i + n, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br><span class="hljs-built_in">add</span>(u + n, v, inf);<br><span class="hljs-built_in">add</span>(v + n, u, inf);<br>&#125;<br>s += n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dinic</span>(s, t));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1344 Pollutant Control</title>
    <link href="/2020/09/16/P1344_Pollutant_Control/"/>
    <url>/2020/09/16/P1344_Pollutant_Control/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P1344">题目链接</a></p></blockquote><p>最小割模板题<br /><span id="more"></span> 根据最小割最大流定理<br /><span class="math inline">\(f(s,t)-{max}=c(s,t)-{min}\)</span><br />证明如下:<br /><span class="math inline">\(f(s,t)\leq c(s,t)\)</span><br /><span class="math inline">\(f(s,t)=S\text{出边流量}-S\text{入边流量}\leq S\text{出边流量}=c(s,t)\)</span><br />当<span class="math inline">\(s,t\)</span>不联通时，入边流量为 0 流，而出边流量满流。<br />所以最小割等于最大流</p><p>而割边数只需要把所有边权调为<span class="math inline">\(1\)</span>，求一次最大流即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">35</span>, M = <span class="hljs-number">2005</span>, inf = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, head[N], cnt = <span class="hljs-number">1</span>, dis[N], now[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v, w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>    e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dis[i] = inf;<br>dis[s] = <span class="hljs-number">0</span>; now[s] = head[s];<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (dis[v] == inf &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>now[v] = head[v];<br>q.<span class="hljs-built_in">push</span>(v);<br><span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br><span class="hljs-keyword">int</span> k, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (dis[v] == dis[u] + <span class="hljs-number">1</span> &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>e[i].w -= k;<br>e[i ^ <span class="hljs-number">1</span>].w += k;<br>sum -= k;<br>res += k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) res += <span class="hljs-built_in">dfs</span>(s, inf);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>s = <span class="hljs-number">1</span>, t = n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> u, v, w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br><span class="hljs-built_in">add</span>(u, v, w);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">dinic</span>(s, t));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cnt; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) e[i].w = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> e[i].w = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dinic</span>(s, t));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dinic 学习笔记</title>
    <link href="/2020/09/16/Dinic_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/16/Dinic_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P3376">最大流模板题</a></p></blockquote><p>dinic 是在残量网络上分层后<span class="math inline">\(\mathcal{O}(n^2m)\)</span>找增广路的算法<br /><span id="more"></span> ## 定义 1. 容量：<span class="math inline">\(c(u,v)\)</span>表示边最大允许的容量<br />2. 流量：<span class="math inline">\(f(u,v)\)</span>表示一条有向边中已经占用的流量<br />3. 剩余流量：<span class="math inline">\(c(u,v)-f(u,v)\)</span><br />4. 残量网络：原图基础上，添加每条边的反向边构成残量网络<br />5. 增广路：在残量网络中，一条从原点到汇点的路，所有边的最小流量称为增广流量<br />6. 增广：在残量网络中寻找一条增广路，并将所有边流量加上增广流量<br />7. 层次：表示节点<span class="math inline">\(u\)</span>在层次图中和源点的距离<br />8. 层次图：在残量网络中按照每个节点的层次分层，只保留相邻两层节点的图，流量已经等于容量的边不在层次图中</p><h2 id="性质">性质</h2><p>合法的流量图满足三个性质：<br />1. 容量限制：<span class="math inline">\(f(u,v)\leq c(u,v)\)</span><br />2. 斜对称性：<span class="math inline">\(f(u,v)=-f(v,u)\)</span><br />3. 流量守恒：除了源点和汇点，<span class="math inline">\(\sum\limits-{(u,v)\in E}f(u,v)=0\)</span></p><h2 id="dinic">dinic</h2><p>最大流问题是最大化<span class="math inline">\(\sum\limits-{(s,v)\in E}f(s,v)\)</span>或者<span class="math inline">\(\sum\limits-{(v,t)\in E}f(v,t)\)</span><br />dinic 算法在不断 bfs 将图分层后，寻找增广路进行增广。<br />当无法增广，即层次图中没有汇点时，增广结束，此时源点到汇点的流量最大。</p><p>反向边是为了反悔，如果当前增广个增广路不是最大流，但已经没有其他增广路。<br />可以通过反向边来撤销之前选的流量。</p><p>当前弧优化，在一次找增广路的过程中，如果某条边已经被增广了，那么之后在当前层次图不会用到。<br />直接从下一条边开始增广。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">205</span>, M = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> ll inf = <span class="hljs-number">1e16</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, m, s, t, head[N], now[N], cnt = <span class="hljs-number">1</span>;<br>ll dis[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br>    <span class="hljs-keyword">int</span> nxt, v;<br>    ll w;<br>&#125; e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, ll w)</span> </span>&#123;<br>e[++cnt] = &#123;head[u], v, w&#125;; head[u] = cnt;<br>e[++cnt] = &#123;head[v], u, <span class="hljs-number">0</span>&#125;; head[v] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dis[i] = inf;<br>q.<span class="hljs-built_in">push</span>(s); dis[s] = <span class="hljs-number">0</span>;<br>now[s] = head[s];<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>    <span class="hljs-keyword">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (e[i].w &gt; <span class="hljs-number">0</span> &amp;&amp; dis[v] == inf) &#123;<br>now[v] = head[v];<br>dis[v] = dis[u] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(v);<br><span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, ll sum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> sum;<br>    ll res = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now[u]; i &amp;&amp; sum; i = e[i].nxt) &#123;<br>now[u] = i;<br><span class="hljs-keyword">int</span> v = e[i].v;<br>    <span class="hljs-keyword">if</span> ((dis[v] == dis[u] + <span class="hljs-number">1</span>) &amp;&amp; e[i].w &gt; <span class="hljs-number">0</span>) &#123;<br>    k = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(sum, e[i].w));<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dis[v] = inf;<br>    e[i].w -= k;<br>    e[i ^ <span class="hljs-number">1</span>].w += k;<br>    sum -= k;<br>    res += k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> u, v; ll w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);<br>    <span class="hljs-built_in">add</span>(u, v, w);<br>&#125;<br>ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) res += <span class="hljs-built_in">dfs</span>(s, inf * <span class="hljs-number">10</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 2763 飞行路线</title>
    <link href="/2020/09/15/BZOJ_2763_%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF/"/>
    <url>/2020/09/15/BZOJ_2763_%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://darkbzoj.tk/problem/2763">题目链接</a></p></blockquote><p>分层图模板题<br />一开始写了一个 dp ，<span class="math inline">\(f[i][j]\)</span>表示第<span class="math inline">\(i\)</span>个点用了<span class="math inline">\(j\)</span>次的最小值。<br /><span id="more"></span><br /><span class="math inline">\(f[i][0]\)</span>是不用免费机会，跑一次单源最短路就可以预处理。<br />在图上枚举转移，每次无非就是选和不选两种决策。<br />感觉挺对的，然而不知道怎么 WA 了...</p><p>发现这个枚举转移好像很笨，因为可以在最短路时顺便处理出来。<br />建立分层图<span class="math inline">\(u,j*n\)</span>向<span class="math inline">\(v,(j+1)*n\)</span>连边表示用一次机会到<span class="math inline">\(v\)</span>的最小值。<br /><span class="math inline">\(u,j*n\)</span>向<span class="math inline">\(v,j*n\)</span>连边表示不使用机会。</p><p>最后把每一层的<span class="math inline">\(t\)</span>连接起来，<span class="math inline">\(dis[t,k*n]\)</span>即是答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10005</span>;<br>vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; e[N * <span class="hljs-number">15</span>];<br><span class="hljs-keyword">int</span> n, m, k, s, t, book[N * <span class="hljs-number">15</span>], dis[N * <span class="hljs-number">15</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>dis[s] = <span class="hljs-number">0</span>;<br>priority-queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> now = q.<span class="hljs-built_in">top</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (book[now]) <span class="hljs-keyword">continue</span>;<br>book[now] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[now]) &#123;<br><span class="hljs-keyword">if</span> (dis[now] + v.second &lt; dis[v.first]) &#123;<br>dis[v.first] = dis[now] + v.second;<br>q.<span class="hljs-built_in">push</span>(&#123;-dis[v.first], v.first&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d %d&quot;</span>, &amp;n ,&amp;m, &amp;k, &amp;s ,&amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v, w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>e[u].push-<span class="hljs-built_in">back</span>(&#123;v, w&#125;);<br>e[v].push-<span class="hljs-built_in">back</span>(&#123;u, w&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br>e[u + (j - <span class="hljs-number">1</span>) * n].push-<span class="hljs-built_in">back</span>(&#123;v + j * n, <span class="hljs-number">0</span>&#125;);<br>e[v + (j - <span class="hljs-number">1</span>) * n].push-<span class="hljs-built_in">back</span>(&#123;u + j * n, <span class="hljs-number">0</span>&#125;);<br>e[u + j * n].push-<span class="hljs-built_in">back</span>(&#123;v + j * n, w&#125;);<br>e[v + j * n].push-<span class="hljs-built_in">back</span>(&#123;u + j * n, w&#125;);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) e[t + (i - <span class="hljs-number">1</span>) * n].push-<span class="hljs-built_in">back</span>(&#123;t + i * n, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-built_in">dij</span>(s);<br>    <span class="hljs-comment">/*for (int i = 0; i &lt; n; i++) </span><br><span class="hljs-comment">    for (int j = 0; j &lt;= k; j++) &#123;</span><br><span class="hljs-comment">for (auto v : e[i]) &#123;</span><br><span class="hljs-comment">            if (j != k) dp[v.first][j + 1] = min(dp[v.first][j + 1], dp[i][j]);</span><br><span class="hljs-comment">if (j != 0) dp[v.first][j] = min(dp[v.first][j], dp[i][j] + v.second);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[t + k * n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分层图</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 1677 求和</title>
    <link href="/2020/09/15/BZOJ_1677_%E6%B1%82%E5%92%8C/"/>
    <url>/2020/09/15/BZOJ_1677_%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://darkbzoj.tk/problem/1677">题目链接</a></p></blockquote><p>设<span class="math inline">\(f[i]\)</span>表示凑成<span class="math inline">\(i\)</span>的方案数。<br /><span id="more"></span> 枚举所有<span class="math inline">\(f[i-2^k]\)</span>加上是错误的，因为有些方案可能会重复。</p><p>比如现在要凑<span class="math inline">\(7\)</span><br />有可能从<span class="math inline">\(5=1+2+2\)</span>或者<span class="math inline">\(6=2+2+2\)</span>转移过来。<br />显然是重复了。</p><p>正确的姿势是做完全背包，也就是交换一下枚举顺序...<br />把<span class="math inline">\(2^k\)</span>当作物品凑<span class="math inline">\(i\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> n, f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="hljs-comment">for (int j = 0; (1 &lt;&lt; j) &lt;= i; j++) &#123;</span><br><span class="hljs-comment">f[i] = (f[i] * 1ll + f[i - (1 &lt;&lt; j)] * 1ll) % MOD;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span>(i &gt;= (<span class="hljs-number">1</span> &lt;&lt; j)) f[i] = (f[i] * <span class="hljs-number">1ll</span> + f[i - (<span class="hljs-number">1</span> &lt;&lt; j)] * <span class="hljs-number">1ll</span>) % MOD;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10067 构造完全图</title>
    <link href="/2020/09/15/LOJ_10067_%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E5%9B%BE/"/>
    <url>/2020/09/15/LOJ_10067_%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10067">题目链接</a></p></blockquote><p>因为要求完全图的最小生成树是给定的<span class="math inline">\(T\)</span>，那么与树边等效的边边权都要大于树边。<br />考虑在求最小生成树的过程中，合并两个点集，除了树边的两个端点，两两直接都要连一条权值为<span class="math inline">\(w+1\)</span>的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, fa[N], siz[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> u, v, w;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> E&amp; q) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> w &lt; q.w;<br>&#125;<br>&#125; e[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fa[i] = i, siz[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + n);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> u = e[i].u, v = e[i].v, w = e[i].w;<br><span class="hljs-keyword">int</span> uf = <span class="hljs-built_in">find</span>(u), vf = <span class="hljs-built_in">find</span>(v);<br>res = res + <span class="hljs-number">1ll</span> * siz[uf] * siz[vf] * (w + <span class="hljs-number">1</span>);<br>res -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (siz[uf] &gt; siz[vf]) <span class="hljs-built_in">swap</span>(uf, vf);<br>fa[uf] = vf;<br>siz[vf] += siz[uf];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA10859 Placing Lampposts</title>
    <link href="/2020/09/15/UVA10859_Placing_Lampposts/"/>
    <url>/2020/09/15/UVA10859_Placing_Lampposts/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接: <a href="https://www.luogu.com.cn/problem/UVA10859">luogu</a></p></blockquote><p>最优化两个目标，好像不太好处理。 可以先转化一下，求被两盏灯同时照亮的边数应该尽可能大，就等价被一盏灯照亮的边数应该尽可能小。 <span id="more"></span><br />假设放了<span class="math inline">\(x\)</span>盏灯，被一个灯照的边有<span class="math inline">\(y\)</span>条，那么可以设计一个目标函数<span class="math inline">\(g=Mx+y\)</span>，让<span class="math inline">\(g\)</span>尽量小。<span class="math inline">\(M\)</span>是什么？可以想到<span class="math inline">\(M\)</span>是一个比较大的数，因为要让<span class="math inline">\(x\)</span>的个数对目标函数的大小起决定性作用，可以证明<span class="math inline">\(M\)</span>只要比<span class="math inline">\(y-max-y-min\)</span>大就可以了。<br />那么接下来就考虑一下怎么<span class="math inline">\(dp\)</span>，假设现在在节点<span class="math inline">\(u\)</span>，<span class="math inline">\(u\)</span>的决策就是放灯或者不放灯，这个决策是具有后效性的，怎么办呢？<br />我们可以把状态表示为<span class="math inline">\(f[u][j]\)</span>，<span class="math inline">\(j=0\)</span>表示父节点没放灯，<span class="math inline">\(j=1\)</span>则反之。 讨论<span class="math inline">\(u\)</span>点放不放灯的两种情况，转移是很容易想到的。<br />注意给出的是一个森林，分别计算每棵树的答案就好了。 设答案是<span class="math inline">\(ans\)</span>，那么输出就分别是<span class="math inline">\(ans/M\)</span>,<span class="math inline">\(m-ans\ mod\ M\)</span>,<span class="math inline">\(ans\ mod\ M\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2000</span>, N = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n, m, f[N][<span class="hljs-number">2</span>], vis[N][<span class="hljs-number">2</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>ch = <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> &amp;ans = f[u][j], sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(vis[u][j]) <span class="hljs-keyword">return</span> ans;<br>    vis[u][j] = <span class="hljs-number">1</span>; ans = M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v[u].<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 放灯</span><br>    <span class="hljs-keyword">int</span> to = v[u][i]; <span class="hljs-keyword">if</span>(to == fa) <span class="hljs-keyword">continue</span>;<br>    ans += <span class="hljs-built_in">dfs</span>(to, <span class="hljs-number">1</span>, u);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fa != <span class="hljs-number">-1</span> &amp;&amp; !j) ans += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(j || fa == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">int</span> to = v[u][i]; <span class="hljs-keyword">if</span>(to == fa) <span class="hljs-keyword">continue</span>;<br>    sum += <span class="hljs-built_in">dfs</span>(to, <span class="hljs-number">0</span>, u);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fa != <span class="hljs-number">-1</span>) sum += <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">min</span>(ans, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) v[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">read</span>(), to = <span class="hljs-built_in">read</span>();<br>        v[u].push-<span class="hljs-built_in">back</span>(to); v[to].push-<span class="hljs-built_in">back</span>(u);<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!vis[i][<span class="hljs-number">0</span>]) ans += <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, ans / M, m - ans % M, ans % M);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>trick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类欧几里得算法</title>
    <link href="/2020/09/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P5170">题目链接</a></p></blockquote><p>花一上午学了下这个东西,记录一下方便以后复习,<del>以下主要靠抄<a href="https://oi-wiki.org/math/euclidean/">OI-Wiki</a></del> <span id="more"></span> ## 题目<br />给定<span class="math inline">\(n,a,b,c\)</span>.计算:<br /><span class="math display">\[ f(a,b,c,n)=\sum\limits-{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor \]</span> <span class="math display">\[ g(a,b,c,n)=\sum\limits-{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor \]</span> <span class="math display">\[ h(a,b,c,n)=\sum\limits-{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2  \]</span></p><h2 id="题解">题解</h2><h3 id="f函数">f函数</h3><p><span class="math display">\[ f(a,b,c,n)=\sum\limits-{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor \]</span> 可以把原来的式子变化一下.<br />$ f(a,b,c,n)=-{i=0}^n  $</p><p><span class="math inline">\(=\sum\limits-{i=0}^n\left\lfloor \frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}\right\rfloor\ \)</span></p><p><span class="math inline">\(=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+ \sum\limits-{i=0}^n\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c} \right\rfloor\ \)</span></p><p><span class="math inline">\(=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor +(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)\)</span></p><p>现在只用考虑<span class="math inline">\(a&lt;c,b&lt;c\)</span>的情况.<br />把式子变化一下, <span class="math display">\[f(a,b,c,n)=\sum\limits-{i=0}^n\sum\limits-{j=0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}1\]</span><br />因为想办法把<span class="math inline">\(i\)</span>处理掉,常见的方法是交换求和符号.<br /><span class="math display">\[\sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1} \sum\limits-{i=0}^n\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\]</span></p><p>因为<span class="math inline">\(j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\Leftrightarrow j+1\leq \left\lfloor \frac{ai+b}{c} \right\rfloor\Leftrightarrow j+1\leq \frac{ai+b}{c}\Leftrightarrow cj+c\leq ai+b\Leftrightarrow \left\lfloor\frac{cj+c-b-1}{a}\right\rfloor&lt;i\)</span><br />所以也等价于<br /><span class="math inline">\(\sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1} \sum\limits-{i=0}^n\left[\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor&lt;i\right]\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1}n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\)</span><br /><span class="math inline">\(=\left\lfloor \frac{an+b}{c} \right\rfloor\times n-f(c,c-b-1,a,\left\lfloor \frac{an+b}{c} \right\rfloor-1)\)</span><br />发现<span class="math inline">\(a,c\)</span>也恰好是交换的,是可以像欧几里得算法那样递归处理.<br />### g函数 <span class="math display">\[ g(a,b,c,n)=\sum\limits-{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor \]</span></p><p>好像和上面挺相似的.<br /><span class="math display">\[ g(a,b,c,n) =g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2} \]</span></p><p>然后考虑<span class="math inline">\(b&lt;c,a&lt;c\)</span>的情况<br /><span class="math inline">\(g(a,b,c,n)=\sum\limits-{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{m-1} \sum\limits-{i=0}^n\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cdot i\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{m-1}\sum\limits-{i=0}^n\left[\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor&lt;i\right]\cdot i\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{m-1}\frac{1}{2}\cdot (t+n+1)(n-t)\)</span><br /><span class="math inline">\(=\frac{1}{2}\sum\limits-{j=0}^{m-1}n(n+1)-t^2-t\)</span><br /><span class="math inline">\(=\frac{1}{2}mn(n+1)-\frac{1}{2}\sum\limits-{j=0}^{m-1}t-\frac{1}{2}\sum\limits-{j=0}^{m-1}t^2\)</span><br /><span class="math inline">\(=\frac{1}{2}mn(n+1)-\frac{1}{2}f(c,c-b-1,a,m-1)-\frac{1}{2}h(c,c-b-1,a,m-1)\)</span></p><p>其中<span class="math inline">\(m=\left\lfloor\frac{an+b}{c}\right\rfloor\)</span>,<span class="math inline">\(t=\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\)</span>.</p><h3 id="h函数">h函数</h3><p><span class="math display">\[ h(a,b,c,n)=\sum\limits-{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2  \]</span><br />这个要复杂一些.<br />还是先取模.<br /><span class="math inline">\(h(a,b,c,n)=h(a\bmod c,b\bmod c,c,n) +2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n) +2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1) +\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)\)</span></p><p>把平方拆开</p><p><span class="math display">\[ n^2=2\frac{n(n+1)}{2}-n=\left(2\sum\limits-{i=0}^ni\right)-n\]</span></p><p>这样添加变量的时候就不会出现两个求和符号相乘,即<span class="math inline">\(\sum\times \sum\)</span></p><p>$ h(a,b,c,n)=-{i=0}^n ^2$</p><p>$ =-{i=0}^n $</p><p>$=(2-{i=0}<sup>n-{j=1}</sup>{ }j) -f(a,b,c,n) $</p><p>化简前一部分<br /><span class="math inline">\(\ \sum\limits-{i=0}^n\sum\limits-{j=1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\)</span><br />$=-{i=0}<sup>n-{j=0}</sup>{ }(j+1) $<br /><span class="math inline">\(=\sum\limits-{j=0}^{m-1}(j+1) \sum\limits-{i=0}^n\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{m-1}(j+1)\sum\limits-{i=0}^n[i&gt;t]\)</span> <span class="math inline">\(=\sum\limits-{j=0}^{m-1}(j+1)(n-t)\)</span> <span class="math inline">\(=\frac{1}{2}nm(m+1)-\sum\limits-{j=0}^{m-1}(j+1)\left\lfloor \frac{jc+c-b-1}{a} \right\rfloor\)</span> <span class="math inline">\(=\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)\)</span></p><p>最后, <span class="math inline">\(h(a,b,c,n)=nm(m+1)-2\cdot g(c,c-b-1,a,m-1)-2\cdot f(c,c-b-1,a,m-1)-f(a,b,c,n)\)</span></p><h2 id="代码">代码</h2><p>因为这三个函数不全是独立的,且计算的过程大致相同,所以应该一起递归计算.<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> P = <span class="hljs-number">998244353</span>, i2 = <span class="hljs-number">499122177</span>, i6 = <span class="hljs-number">166374059</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> f, g, h;<br>    <span class="hljs-built_in">node</span>() &#123;f = g = h = <span class="hljs-number">0</span>;&#125;<br>&#125;;<br><span class="hljs-function">node <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + <span class="hljs-number">1</span>, n2 = n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    node d;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;<br>        d.f = bc * n1 % P;<br>        d.g = bc * n % P * n1 % P * i2 % P;<br>        d.h = bc * bc % P * n1 % P;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a &gt;= c || b &gt;= c) &#123;<br>        d.f = (n * n1 % P * i2 % P * ac % P + bc * n1 % P) % P;<br>        d.g = (ac * n % P * n1 % P * n2 % P * i6 % P + bc * n % P * n1 % P * i2 % P) % P;<br>        d.h = (ac * ac % P * n % P * n1 % P * n2 % P * i6 % P + bc * bc % P * n1 % P + ac * bc % P * n % P * n1 % P) % P;<br>        node e = <span class="hljs-built_in">calc</span>(n, a % c, b % c, c);<br>        d.g += e.g, d.f += e.f;<br>        d.h += e.h + <span class="hljs-number">2</span> * bc % P * e.f % P + <span class="hljs-number">2</span> * ac % P * e.g % P;<br>        d.g %= P, d.f %= P, d.h %=P;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    node e = <span class="hljs-built_in">calc</span>(m - <span class="hljs-number">1</span>, c, c - b - <span class="hljs-number">1</span>, a);<br>    d.f = n * m % P - e.f, d.f = (d.f % P + P) % P;<br>    d.g = m * n % P * n1 % P - e.h - e.f, d.g = (d.g * i2 % P + P) % P;<br>    d.h = n * m % P * (m + <span class="hljs-number">1</span>) % P - <span class="hljs-number">2</span> * e.g - <span class="hljs-number">2</span> * e.f - d.f;<br>    d.h = (d.h % P + P) % P;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-built_in">main</span>() &#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t);<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-keyword">int</span> n, a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;c);<br>        node res = <span class="hljs-built_in">calc</span>(n, a, b, c);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld %lld\n&quot;</span>, res.f, res.h, res.g);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>类欧几里得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF868F Yet Another Minimization Problem</title>
    <link href="/2020/09/15/CF868F_Yet_Another_Minimization_Problem/"/>
    <url>/2020/09/15/CF868F_Yet_Another_Minimization_Problem/</url>
    
    <content type="html"><![CDATA[<p>写这种题先写一下暴力的<span class="math inline">\(dp\)</span>式子.<br /><span class="math inline">\(dp[i][k]=min(dp[j][k-1]+w)\)</span>.<br />可以发现决策是具有单调性的,其他题解说得都很清楚了.<br />那么就可以用分治来优化这个方程.<br />因为是分层的复杂度是<span class="math inline">\(\mathcal{O}(nlogn)\)</span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, p, a[N];<br>ll f[N][<span class="hljs-number">21</span>], m[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-function">ll <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; <span class="hljs-keyword">static</span> ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l &gt; L) l--, res += m[a[l]]++; <br><span class="hljs-keyword">while</span>(r &lt; R) r++, res += m[a[r]]++;<br><span class="hljs-keyword">while</span>(l &lt; L) res -= --m[a[l]], l++;<br><span class="hljs-keyword">while</span>(r &gt; R) res -= --m[a[r]], r--;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CDQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> tl, <span class="hljs-keyword">int</span> tr, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt; r || tl &gt; tr) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, pos = <span class="hljs-number">0</span>; ll res = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = tl; i &lt;= tr; i++) &#123;<br>    ll v = f[i][cur - <span class="hljs-number">1</span>] + <span class="hljs-built_in">value</span>(i + <span class="hljs-number">1</span>, mid);<br>    <span class="hljs-keyword">if</span>(v &lt; res) &#123;<br>    res = v; pos = i;<br>    &#125;<br>    &#125;<br>    f[mid][cur] = <span class="hljs-built_in">min</span>(f[mid][cur], res); <span class="hljs-built_in">CDQ</span>(l, mid - <span class="hljs-number">1</span>, tl, pos, cur); <span class="hljs-built_in">CDQ</span>(mid + <span class="hljs-number">1</span>, r, pos, tr, cur);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f); f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), v.push-<span class="hljs-built_in">back</span>(a[i]);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = lower-<span class="hljs-built_in">bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), a[i]) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) <span class="hljs-built_in">CDQ</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[n][p]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>CDQ分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF476D Dreamoon and Sets</title>
    <link href="/2020/09/15/CF476D_Dreamoon_and_Sets/"/>
    <url>/2020/09/15/CF476D_Dreamoon_and_Sets/</url>
    
    <content type="html"><![CDATA[<p>构造。 <span id="more"></span> 因为四元组最大公因数是<span class="math inline">\(k\)</span>，所以将四个数同时除以<span class="math inline">\(k\)</span>，得到的四个数互质。<br />所以构造出四个互质的数就可以了。<br />设第一个数是<span class="math inline">\(x\)</span>，因为四元组尽量小，所以构造的数要尽量接近。<br />显然只能有一个偶数，所以很容易得到第二个数是<span class="math inline">\(x+1\)</span>，第三个数是<span class="math inline">\(x+2\)</span>，并且<span class="math inline">\(2\nmid x\)</span>。<br />第四个数不能是<span class="math inline">\(x+3\)</span>，因为只能有一个偶数。那么可不可以是<span class="math inline">\(x+4\)</span>呢？<br />我们知道连续<span class="math inline">\(n\)</span>个数一定有一个能被<span class="math inline">\(n\)</span>整除，因为<span class="math inline">\(2\nmid x\)</span>，所以是可以的。<br />注意一下每个数只能在答案中出现一次，找下规律就可以了。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,( <span class="hljs-number">6</span> * n - <span class="hljs-number">1</span>) * k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> m1 = (i - <span class="hljs-number">1</span>) * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, m1 * k, (m1+<span class="hljs-number">1</span>) * k, (m1+<span class="hljs-number">2</span>) * k, (m1+<span class="hljs-number">4</span>) * k);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三元环</title>
    <link href="/2020/09/15/%E4%B8%89%E5%85%83%E7%8E%AF/"/>
    <url>/2020/09/15/%E4%B8%89%E5%85%83%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="三元环个数">三元环个数</h2><p>可以看看这篇文章<a href="https://www.luogu.com.cn/blog/KingSann/fou-chang-yong-di-hei-ke-ji-san-yuan-huan-post">不常用的黑科技——「三元环」</a><br />给每条边定向，度数不同的大度数向小度数连边，度数相同编号小的向大连边。<br /><span id="more"></span> 这样会生成一个有向无环图。<br />直接搜索每个点<span class="math inline">\(u\)</span>的相邻的点，打上标记是被谁(u)访问的。<br />搜索每个点相邻的点的相邻点，如果某个点被<span class="math inline">\(u\)</span>访问过了，说明这是一个三元环。</p><p>因为每个三元环都长这样<br /><img src="https://s1.ax1x.com/2018/09/06/i9OXWt.png" /> &gt;[图片来源]((https://www.luogu.com.cn/blog/KingSann/fou-chang-yong-di-hei-ke-ji-san-yuan-huan-post)</p><p>所以每个三元环只被统计一次。</p><h3 id="例题">例题</h3><blockquote><p><a href="https://vjudge.net/problem/HDU-6184">Counting Stars</a></p></blockquote><p>这道题需要知道每条边在多少个三元环上，所以每次找三元环时给边打上标记。<br />建图的时候记录下<span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span>之间的边。<br />最后的答案就是<span class="math inline">\(\sum\limits-{i=1}^{m}\binom{cnt-i}{2}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> cnt[N], deg[N], vis[N], x[N], y[N], n, m;<br>vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; e[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x[i], &amp;y[i]);<br>deg[x[i]] += <span class="hljs-number">1</span>;<br>deg[y[i]] += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> u = x[i], v = y[i];<br><span class="hljs-keyword">if</span> (deg[u] &lt; deg[v] || (deg[u] == deg[v] &amp;&amp; u &gt; v)) <span class="hljs-built_in">swap</span>(u, v);<br>e[u].push-<span class="hljs-built_in">back</span>(&#123;v, i&#125;);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) vis[v.first] = v.second;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> w : e[v.first]) &#123;<br><span class="hljs-keyword">if</span> (vis[w.first]) &#123;<br>cnt[w.second]++;<br>cnt[v.second]++;<br>cnt[vis[w.first]]++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) vis[v.first] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            res = res + cnt[i] * <span class="hljs-number">1ll</span> * (cnt[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    cnt[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) e[i].<span class="hljs-built_in">clear</span>(), deg[i] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造三元环图">构造三元环图</h2><blockquote><p><a href="https://loj.ac/problem/540">题目链接</a></p></blockquote><p>有一种构造方式是每个点给编号更小的点连边，知道有<span class="math inline">\(n\)</span>个三元环为止。<br /><span class="math inline">\(k\)</span>个点时，三元环个数是<span class="math inline">\(\sum\limits-{i=3}^{k}\binom{i-1}{2}\)</span><br />考虑<span class="math inline">\(k\)</span>到某个大小时，三元环个数与<span class="math inline">\(n\)</span>尽量接近且不大于<span class="math inline">\(n\)</span><br />这时候再继续连边，连<span class="math inline">\(i\)</span>条边会增加<span class="math inline">\(\binom{i}{2}\)</span>个三元环。<br />所以无论如何最终都可以凑成<span class="math inline">\(n\)</span>个三元环。<br />--话说<span class="math inline">\(k\)</span>的大小怎么证明啊？--</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n, k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">606</span>][<span class="hljs-number">606</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i; n; n -= (i - <span class="hljs-number">1</span>) * (i - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>, k++) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; k &amp;&amp; (i - <span class="hljs-number">1</span>) * i / <span class="hljs-number">2</span> &lt;= n; i++) a[i][k] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++, <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>))<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; k; j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i][j] | a[j][i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>三元环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10225 迷路</title>
    <link href="/2020/09/15/LOJ_10225_%E8%BF%B7%E8%B7%AF/"/>
    <url>/2020/09/15/LOJ_10225_%E8%BF%B7%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10225">题目链接</a></p></blockquote><p>如果边权都是<span class="math inline">\(1\)</span>，那么矩阵<span class="math inline">\(i,j\)</span>表示的就是单位时间<span class="math inline">\(i\)</span>到<span class="math inline">\(j\)</span>的方案数。<br /><span id="more"></span> 假设<span class="math inline">\(f-t\)</span>表示在<span class="math inline">\(t\)</span>时刻的方案数矩阵，<span class="math inline">\(f-t[i][j]=\sum\limits-{k=1}^{n}=f-{t-1}[i][k]*f-{1}[k][j]\)</span><br />显然是可以用矩阵乘法直接算的。<br />即<span class="math inline">\(f-t=f-{t-1}*f-1\)</span></p><p>那么现在边权不为<span class="math inline">\(1\)</span>了，拆点，把每个点拆成<span class="math inline">\(w\)</span>个，每个假点向上一个点连一条边。<br /><span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span>直接有<span class="math inline">\(w\)</span>的边，就<span class="math inline">\(f[u][w-1]\)</span>向<span class="math inline">\(f[v][1]\)</span>连边。<br />一样的矩阵乘法就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>, MOD = <span class="hljs-number">2009</span>;<br><span class="hljs-keyword">int</span> n, m, T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) * <span class="hljs-number">9</span> + j;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Martix</span> &#123;</span><br><span class="hljs-keyword">int</span> x, y, f[N][N];<br><span class="hljs-built_in">Martix</span> (<span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y) &#123;<br>        x = X, y = Y;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>&#125;<br>Martix <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> Martix&amp; q) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-function">Martix <span class="hljs-title">t</span><span class="hljs-params">(x, q.y)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= t.x; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.y; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= y; k++) t.f[i][j] = (<span class="hljs-number">1ll</span> * t.f[i][j] + f[i][k] * <span class="hljs-number">1ll</span> * q.f[k][j]) % MOD;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;T);<br>    <span class="hljs-function">Martix <span class="hljs-title">a</span><span class="hljs-params">(n * <span class="hljs-number">9</span>, n * <span class="hljs-number">9</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">9</span>; j++) a.f[<span class="hljs-built_in">pos</span>(i, j)][<span class="hljs-built_in">pos</span>(i, j + <span class="hljs-number">1</span>)] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">int</span> x = s[j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span>) a.f[<span class="hljs-built_in">pos</span>(i, x)][<span class="hljs-built_in">pos</span>(j, <span class="hljs-number">1</span>)] = <span class="hljs-number">1</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-function">Martix <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">9</span> * n, <span class="hljs-number">9</span> * n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span> * n; i++) ans.f[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; T; T &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) <span class="hljs-keyword">if</span> (T &amp; <span class="hljs-number">1</span>) ans = ans * a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans.f[<span class="hljs-built_in">pos</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)][<span class="hljs-built_in">pos</span>(n, <span class="hljs-number">1</span>)]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵乘法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10224 GT 考试</title>
    <link href="/2020/09/15/LOJ_10224_GT_%E8%80%83%E8%AF%95_/"/>
    <url>/2020/09/15/LOJ_10224_GT_%E8%80%83%E8%AF%95_/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10224">题目链接</a></p></blockquote><p>设<span class="math inline">\(f[i][j]\)</span>表示考虑准考证号<span class="math inline">\(i\)</span>的后缀与 A 长度为<span class="math inline">\(j\)</span>的前缀匹配的方案数。<br /><span id="more"></span> <span class="math inline">\(f[i][j]=\sum\limits-{k=0}^{n}f[i-1][k]\times g[k][j]\)</span><br /><span class="math inline">\(g[k][j]\)</span>表示填入有多少个数字使匹配长度从<span class="math inline">\(k\)</span>变成<span class="math inline">\(j\)</span><br />第二个可以用 kmp 预处理。<br />dp 方程是矩乘的形式，可以用矩阵乘法优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> n, m, MOD, f[N], mc[N][N];<br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Martix</span> &#123;</span><br><span class="hljs-keyword">int</span> x, y, f[N][N];<br><span class="hljs-built_in">Martix</span> (<span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y) &#123;<br>        x = X, y = Y;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>&#125;<br>Martix <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> Martix&amp; q) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-function">Martix <span class="hljs-title">t</span><span class="hljs-params">(x, q.y)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.x; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; t.y; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; y; k++) t.f[i][j] = (<span class="hljs-number">1ll</span> * t.f[i][j] + f[i][k] * <span class="hljs-number">1ll</span> * q.f[k][j]) % MOD;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span> </span>&#123;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> j = f[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (s[j + <span class="hljs-number">1</span>] != s[i] &amp;&amp; j != <span class="hljs-number">-1</span>) j = f[j];<br>        f[i] = j + <span class="hljs-number">1</span>;<br>    &#125;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-string">&#x27;0&#x27;</span>; j &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; j++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = i;<br>            <span class="hljs-keyword">while</span> (s[tmp + <span class="hljs-number">1</span>] != j &amp;&amp; tmp &gt; <span class="hljs-number">0</span>) tmp = f[tmp];<br>            <span class="hljs-keyword">if</span> (s[tmp + <span class="hljs-number">1</span>] == j)<br>                tmp++;<br>            mc[i][tmp]++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">Martix <span class="hljs-title">fpow</span><span class="hljs-params">(Martix c, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-function">Martix <span class="hljs-title">res</span><span class="hljs-params">(m, m)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) res.f[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, c = c * c) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = c * res;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;MOD);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">kmp</span>();<br>    <span class="hljs-function">Martix <span class="hljs-title">g</span><span class="hljs-params">(m, m)</span>, <span class="hljs-title">a</span><span class="hljs-params">(m, <span class="hljs-number">1</span>)</span></span>;<br>    a.f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) g.f[i][j] = mc[i][j];<br>    g = <span class="hljs-built_in">fpow</span>(g, n);<br>    a = a * g;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) ans = (ans + a.f[<span class="hljs-number">0</span>][i]) % MOD;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>矩阵乘法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 6087 毒瘤题 与 加强版</title>
    <link href="/2020/09/14/LOJ_6087_%E6%AF%92%E7%98%A4%E9%A2%98_%E4%B8%8E_%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <url>/2020/09/14/LOJ_6087_%E6%AF%92%E7%98%A4%E9%A2%98_%E4%B8%8E_%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6087">普通版题目链接</a></p></blockquote><h2 id="k1">k=1</h2><p>所有数异或起来，最后的异或和就是答案<br /><span id="more"></span></p><h2 id="k2">k=2</h2><p>如果和上一样的做法，最后会得到两个数异或的结果。<br />既然是两个不同数，那么二进制下也一定有一位不一样。<br />我们开按位置来异或，<span class="math inline">\(a[i]\)</span>表示第<span class="math inline">\(i\)</span>位为<span class="math inline">\(1\)</span>的数的异或和，<span class="math inline">\(b[i]\)</span>表示第<span class="math inline">\(i\)</span>位为<span class="math inline">\(0\)</span>的数的异或和。<br />因为同一个数一定会在一个桶里面异或，那么出现偶数次的是没有影响的。<br />最后只有两个出现奇数次的数产生贡献。<br />找到某一位<span class="math inline">\(bit[a,i]!=bit[b,i]\)</span><br />于是就找到了两个出现奇数次的数<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>sum ^= x;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">32</span>] = &#123;&#125;, b[<span class="hljs-number">32</span>] = &#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">31</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br><span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) &#123;<br>                    a[j] ^= x;<br>&#125; <span class="hljs-keyword">else</span> b[j] ^= x;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (b[i] &amp;&amp; a[i]) &#123;<br><span class="hljs-keyword">if</span> (a[i] &gt; b[i]) <span class="hljs-built_in">swap</span>(a[i], b[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, a[i], b[i]);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="k500-or-k5000">k=500 or k=5000</h2><p>需要一点奇技淫巧。<br />和算法二一样，我们目的是让出现偶数次的数不产生贡献，而出现奇数次的能够单独出现。<br />取几个模数，每个数<span class="math inline">\(x\)</span>都把哈希值对应的桶异或上 x 对应的hash值 。<br />同一个数一定是在同一个桶里面异或，出现偶数次的一样没有影响。<br />那么怎么判断最后桶里面是几个数异或在一起的呢？</p><p>这需要构造一下 hash 函数<br />如果对于输入的<span class="math inline">\(x\)</span>，hash值为<span class="math inline">\(Ax+B\)</span><br />其中<span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>是大质数，且<span class="math inline">\(A&gt;B\)</span>。</p><p>如果最后桶里面的值是<span class="math inline">\(val\bmod A=B\)</span>，因为多个数异或在一起后，大概率都不能满足这个条件...<br />这样可能会漏一些答案，但是不会多选出不合法答案，因为出现偶数次的数是对桶没有贡献的。<br />这样多选几个数，大概率就能让出现奇数次的数取模后 hash 值不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">99823533</span>, B = <span class="hljs-number">1926817</span>, N = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">int</span> mod[N] = &#123;<span class="hljs-number">12107</span>, <span class="hljs-number">10627</span>, <span class="hljs-number">21079</span>, <span class="hljs-number">27077</span>, <span class="hljs-number">28007</span>, <span class="hljs-number">21009</span>, <span class="hljs-number">25080</span>, <span class="hljs-number">20395</span>, <span class="hljs-number">22308</span>, <span class="hljs-number">20486</span>, <span class="hljs-number">20468</span>, <span class="hljs-number">21905</span>, <span class="hljs-number">10201</span>&#125;;<br>ll f[N][<span class="hljs-number">25990</span>], x;<br><span class="hljs-keyword">int</span> n, k;<br>vector&lt;ll&gt; v;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>ll H = A * <span class="hljs-number">1ll</span> * x + B;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) f[i][H % mod[i]] ^= H;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mod[i]; j++) &#123;<br><span class="hljs-keyword">if</span> (f[i][j] % A == B) v.push-<span class="hljs-built_in">back</span>(f[i][j] / A);<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20200914 T1 s 德 kr 摩</title>
    <link href="/2020/09/14/20200914_T1_s_%E5%BE%B7_kr_%E6%91%A9/"/>
    <url>/2020/09/14/20200914_T1_s_%E5%BE%B7_kr_%E6%91%A9/</url>
    
    <content type="html"><![CDATA[<p>提供一种题解没有提到的做法。<br />感觉比题解的 dp 自然？<br /><span id="more"></span> 因为要求某两种n顔色出现偶数次，那我们直接枚举好了。</p><p><span class="math inline">\(\sum\limits-{i=0}^n\sum\limits-{j=0}^{n-i}\binom{n}{i}\binom{n-i}{j}[2\mid i][2\mid j]2^{n-i-j}\)</span></p><p>很自然能够想到<span class="math display">\[\sum\limits-{i=0}^{n}\binom{n}{i}[2\mid i]=\sum\limits-{i=0}^{n}\binom{n}{i}[2\nmid i]=2^{n-1}\]</span><br />理解方式是前面<span class="math inline">\(i-1\)</span>个乱选，最后一个用来凑奇数或者偶数，所以只有最后一个是固定的。</p><p>但是这样好像并不太好做</p><p>于是如果能把奇偶的限制拿掉就好了。<br />构造一个式子<span class="math inline">\(\frac{(-1)^i+1^i}{2}\)</span>。<br />可以发现在偶数时为<span class="math inline">\(1\)</span>，奇数是为<span class="math inline">\(0\)</span>。<br />于是把条件换成这个式子。</p><p><span class="math inline">\(\sum\limits-{i=0}^n[2\mid i]\binom{n}{i}\sum\limits-{j=0}^{n-i}\binom{n-i}{j}\frac{(-1)^i+1^i}{2}2^{n-i-j}\)</span></p><p>我们先考虑<span class="math inline">\(j\)</span>那部分怎么算，如果把刚刚那个式子<span class="math inline">\(2^{-1}\)</span>提出去，<span class="math inline">\(-1\)</span>和<span class="math inline">\(1\)</span>分开算，用二项式定理。<br />式子变成<span class="math inline">\(\sum\limits-{i=0}^{n}[2\mid i]\binom{n}{i}\frac{3^{n-i}+1}{2}\)</span></p><p>和刚才差不多，把偶数的限制换一下，把括号打开用二项式定理。<br />最后答案是<span class="math inline">\(2^{n-1}+4^{n-1}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10091 受欢迎的牛</title>
    <link href="/2020/09/13/LOJ_10091_%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/"/>
    <url>/2020/09/13/LOJ_10091_%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10091">题目链接</a></p></blockquote><p>建图之后，对于每个点遍历一次。<br />只有被经过<span class="math inline">\(n\)</span>次的是被除它所有人欢迎的。</p><p><del>话说暴搜怎么过了？？？</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, vis[N], s[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-number">1</span>;<br>s[u]++;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br><span class="hljs-keyword">if</span> (!vis[v]) <span class="hljs-built_in">dfs</span>(v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">int</span> a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);<br>e[a].push-<span class="hljs-built_in">back</span>(b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br><span class="hljs-built_in">dfs</span>(i);<br>&#125;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += (s[i] == n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10081 道路与航线</title>
    <link href="/2020/09/13/LOJ_10081_%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF/"/>
    <url>/2020/09/13/LOJ_10081_%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10081">题目链接</a></p></blockquote><p>因为是没有负环的，所以可以用 spfa<br />好像有点卡？<br />用双端队列过了，听说双端队列优化是假的？<br />啊，这...</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">250005</span>;<br><span class="hljs-keyword">int</span> n, r, p, s, dis[N], vis[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; e[N], w[N];<br><br>deque&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>q.push-<span class="hljs-built_in">back</span>(s);<br>vis[s] = <span class="hljs-number">1</span>;<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> now = q.<span class="hljs-built_in">front</span>();<br>q.pop-<span class="hljs-built_in">front</span>(); vis[now] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e[now].<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">int</span> v = e[now][i], W = w[now][i];<br><span class="hljs-keyword">if</span> (dis[now] + W &lt; dis[v]) &#123;<br>dis[v] = dis[now] + W;<br><span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>vis[v] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) q.push-<span class="hljs-built_in">back</span>(v);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[v] &lt; dis[q.<span class="hljs-built_in">front</span>()]) q.push-<span class="hljs-built_in">front</span>(v);<br><span class="hljs-keyword">else</span> q.push-<span class="hljs-built_in">back</span>(v);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;r, &amp;p, &amp;s);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br><span class="hljs-keyword">int</span> u, v, a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;a);<br>e[u].push-<span class="hljs-built_in">back</span>(v);<br>e[v].push-<span class="hljs-built_in">back</span>(u);<br>w[u].push-<span class="hljs-built_in">back</span>(a);<br>w[v].push-<span class="hljs-built_in">back</span>(a);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++) &#123;<br><span class="hljs-keyword">int</span> u, v, a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;a);<br>e[u].push-<span class="hljs-built_in">back</span>(v);<br>w[u].push-<span class="hljs-built_in">back</span>(a);<br>&#125;<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (dis[i] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PATH&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2604 「NOIP2012」开车旅行</title>
    <link href="/2020/09/13/LOJ_2604_%E3%80%8CNOIP2012%E3%80%8D%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/"/>
    <url>/2020/09/13/LOJ_2604_%E3%80%8CNOIP2012%E3%80%8D%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2604">题目链接</a></p></blockquote><p>之前听学长讲过，好像是在 dp 专题讲的？<br />这东西好像不是很 dp 啊。<br /><span id="more"></span> 先想想暴力的做法。<br />问题一直接枚举起点后模拟一下，<span class="math inline">\(\mathcal{O}(n^3)\)</span><br />问题二一样的模拟...</p><p>有两个优化，可以先预处理一下每个点对应的最小和次小的目的地，之后直接走。<br />二是每次决策好像都差不多，可不可以一次多走几步...</p><p>第一个，因为只能往东走，所以西边的点对东方没有影响。<br />可以在一个 set 里面按顺序进行查询，每次查完就删除现在的点, <span class="math inline">\(\mathcal{O}(n\log n)\)</span><br />第二个，可以倍增处理。<br /><span class="math inline">\(fi][j]\)</span>表示从<span class="math inline">\(i\)</span>开始走<span class="math inline">\(2^j\)</span>步到的点是谁。<br />每一步的定义是<span class="math inline">\(A,B\)</span>各开了一次车。 <span class="math inline">\(A[i][j]\)</span>表示从<span class="math inline">\(i\)</span>开始<span class="math inline">\(2^j\)</span>步，<span class="math inline">\(A\)</span>驾驶的总距离。<br /><span class="math inline">\(B[i][j]\)</span>同理。</p><p>注意判断一下走不动的情况，即<span class="math inline">\(f\)</span>为<span class="math inline">\(0\)</span>，和最后<span class="math inline">\(A\)</span>是否可以单独走一步。<br />时间复杂度<span class="math inline">\(\mathcal{O}(n\log n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, h[N], d1[N], d2[N], f[N][<span class="hljs-number">19</span>];<br>ll A[N][<span class="hljs-number">19</span>], B[N][<span class="hljs-number">19</span>], s1, s2, x0;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">return</span> h[x] &lt; h[y];<br>&#125;<br>&#125;;<br>set&lt;<span class="hljs-keyword">int</span>, cmp&gt; s;<br>set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it, t;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(h[i] - h[j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!d1[i]) &#123;<br>d1[i] = j;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dis</span>(i, j) &lt; <span class="hljs-built_in">dis</span>(i, d1[i]) || (<span class="hljs-built_in">dis</span>(i, j) == <span class="hljs-built_in">dis</span>(i, d1[i]) &amp;&amp; h[j] &lt; h[d1[i]])) &#123;<br>d2[i] = d1[i], d1[i] = j;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!d2[i] || <span class="hljs-built_in">dis</span>(i, j) &lt; <span class="hljs-built_in">dis</span>(i, d2[i]) || (<span class="hljs-built_in">dis</span>(i, j) == <span class="hljs-built_in">dis</span>(i, d2[i]) &amp;&amp; h[j] &lt; h[d2[i]])) d2[i] = j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, ll x)</span> </span>&#123;<br>    s1 = s2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">16</span>; j + <span class="hljs-number">1</span>; j--) &#123;<br><span class="hljs-keyword">if</span> (f[p][j] &amp;&amp; s1 + s2 + A[p][j] + B[p][j] &lt;= x) &#123;<br>s1 += A[p][j];<br>s2 += B[p][j];<br>p = f[p][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (d2[p] &amp;&amp; s1 + s2 + A[p][<span class="hljs-number">0</span>] &lt;= x) s1 += A[p][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i]), s.<span class="hljs-built_in">insert</span>(i);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x0);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        it = s.lower-<span class="hljs-built_in">bound</span>(i);<br>        <span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>()) &#123;<br>t = it;<br><span class="hljs-built_in">check</span>(i, *--t);<br><span class="hljs-keyword">if</span> (t != s.<span class="hljs-built_in">begin</span>()) <span class="hljs-built_in">check</span>(i, *--t);<br>&#125;<br><span class="hljs-keyword">if</span> (++it != s.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-built_in">check</span>(i, *it);<br><span class="hljs-keyword">if</span> (++it != s.<span class="hljs-built_in">end</span>()) <span class="hljs-built_in">check</span>(i, *it);<br>&#125;<br>s.<span class="hljs-built_in">erase</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = d1[d2[i]], A[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">dis</span>(i, d2[i]), B[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">dis</span>(d2[i], d1[d2[i]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            f[i][j + <span class="hljs-number">1</span>] = f[f[i][j]][j];<br>A[i][j + <span class="hljs-number">1</span>] = A[f[i][j]][j] + A[i][j];<br>B[i][j + <span class="hljs-number">1</span>] = B[f[i][j]][j] + B[i][j];<br>&#125;<br>ll a = <span class="hljs-number">1e9</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">solve</span>(i, x0);<br><span class="hljs-keyword">if</span> (!s2) &#123;<br>            <span class="hljs-keyword">if</span> (!b) &#123;<br><span class="hljs-keyword">if</span> (h[i] &gt; h[pos]) pos = i;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (s2 * a &gt; s1 * b || (s2 * a == s1 * b &amp;&amp; h[i] &gt; h[pos])) &#123;<br>                a = s1, b = s2, pos = i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, pos);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> S; ll x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %lld&quot;</span>, &amp;S, &amp;x);<br><span class="hljs-built_in">solve</span>(S, x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>, s1, s2);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3941 入阵曲</title>
    <link href="/2020/09/09/P3941_%E5%85%A5%E9%98%B5%E6%9B%B2/"/>
    <url>/2020/09/09/P3941_%E5%85%A5%E9%98%B5%E6%9B%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P3941">题目链接</a></p></blockquote><p>二维前缀和直接枚举顶点统计答案。<br />可不可以不枚举呢？</p><p>如果两个前缀和在模<span class="math inline">\(k\)</span>意义下相等，那这两个前缀和的子矩阵是<span class="math inline">\(k\)</span>的倍数。<br />所以问题变成统计所有和相等的子矩阵对数。<br />可以枚举上下边，就可以统计所有以此为上下边的矩阵合法的对数。<br />注意要求的是单个矩阵是<span class="math inline">\(k\)</span>的倍数，所以两个前缀和相减要是有意义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">405</span>;<br><span class="hljs-keyword">int</span> n, m, k;<br>ll sum[N][N], b[<span class="hljs-number">1000005</span>], ans, cnt[<span class="hljs-number">1000005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;sum[i][j]);<br>            sum[i][j] = -sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + sum[i][j - <span class="hljs-number">1</span>] + sum[i - <span class="hljs-number">1</span>][j] + sum[i][j];<br>            sum[i][j] = (sum[i][j] % k + k) % k;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= m; l++) ans += cnt[b[l] = ((sum[j][l] - sum[i][l] + k) % k)]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= m; l++) cnt[b[l]] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2234「JLOI2014」聪明的燕姿</title>
    <link href="/2020/09/09/LOJ_2234%E3%80%8CJLOI2014%E3%80%8D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF/"/>
    <url>/2020/09/09/LOJ_2234%E3%80%8CJLOI2014%E3%80%8D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2234">题目链接</a></p></blockquote><p>感觉自己代码能力好弱啊....<br /><a href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428">约数个数和定理</a></p><p>枚举每个约数的指数，然后 dfs 一下。<br />特判指数为 1 的情况， 如果某个未用过的素数满足<span class="math inline">\(sum\times (p-i+1)=S\)</span>,就记录一下答案。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (lst &gt; P[x] &amp;&amp; <span class="hljs-built_in">isprime</span>(lst - <span class="hljs-number">1</span>)) v[++tot] = (lst - <span class="hljs-number">1</span>) * cur;<br></code></pre></td></tr></table></figure> 还需要枚举所有<span class="math inline">\(e-i\leq 2\)</span>的质因子。<br />因为最多有一个大于<span class="math inline">\(\sqrt n\)</span>的数，它指数一定为 1， 之前已经特判了，所以只用管所有<span class="math inline">\((p-i+1)(p-i+1)\leq S\)</span>的质数。</p><p>约数和的题大概都是分类讨论一下<span class="math inline">\(e-i=1\)</span>和<span class="math inline">\(e-i&gt;1\)</span>的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50007</span>;<br><span class="hljs-keyword">int</span> P[N], vis[N], cnt, n, v[N], tot;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) P[++cnt] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; P[j] * i &lt;= n; j++) &#123;<br>    vis[P[j] * i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i % P[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> lst, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (lst == <span class="hljs-number">1</span>) &#123; <br>v[++tot] = cur;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (lst &gt; P[x] &amp;&amp; <span class="hljs-built_in">isprime</span>(lst - <span class="hljs-number">1</span>)) v[++tot] = (lst - <span class="hljs-number">1</span>) * cur;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; P[i] * P[i] &lt;= lst; i++) &#123;<br><span class="hljs-keyword">int</span> s1 = P[i], s2 = P[i] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; s2 &lt;= lst; s1 *= P[i], s2 += s1) &#123;<br><span class="hljs-keyword">if</span> (lst % s2 == <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, lst / s2, cur * s1);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(N - <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br>        tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">sort</span>(v + <span class="hljs-number">1</span>, v + tot + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tot);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tot != <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10162 骑士</title>
    <link href="/2020/09/08/LOJ_10162_%E9%AA%91%E5%A3%AB/"/>
    <url>/2020/09/08/LOJ_10162_%E9%AA%91%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10162">题目链接</a></p></blockquote><p>把不能在一起的骑士连一条边，可以发现每个连通块最多一个环。<br />每个联通块单独考虑，变成了选儿子不能选父亲这种经典 dp <span id="more"></span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> n, a[N], b[N], cnt = <span class="hljs-number">1</span>, head[N], x1, x2, now, vis[N];<br>ll f[N][<span class="hljs-number">2</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><span class="hljs-keyword">int</span> nxt, v;&#125; e[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    e[++cnt] = &#123;head[x], y&#125;; head[x] = cnt;<br>    e[++cnt] = &#123;head[y], x&#125;; head[y] = cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fr)</span> </span>&#123;<br>vis[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>    <span class="hljs-keyword">int</span> v = e[i].v;<br>    <span class="hljs-keyword">if</span> ((i ^ <span class="hljs-number">1</span>) == fr) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (vis[v]) &#123;<br>    now = i, x1 = u, x2 = v;<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">find</span>(v, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;<br>    f[u][<span class="hljs-number">1</span>] = a[u];<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>    <span class="hljs-keyword">if</span> (i == now || (i ^ <span class="hljs-number">1</span>) == now || (i ^ <span class="hljs-number">1</span>) == pre) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(e[i].v, i);<br>        f[u][<span class="hljs-number">0</span>] = f[u][<span class="hljs-number">0</span>] + <span class="hljs-built_in">max</span>(f[e[i].v][<span class="hljs-number">0</span>], f[e[i].v][<span class="hljs-number">1</span>]);<br>        f[u][<span class="hljs-number">1</span>] = f[u][<span class="hljs-number">1</span>] + f[e[i].v][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">int</span> v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a[i], &amp;v);<br>    <span class="hljs-built_in">add</span>(i, v); <br>    &#125;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>    <span class="hljs-built_in">find</span>(i, <span class="hljs-number">-2</span>);<br>    <span class="hljs-built_in">dfs</span>(x1, <span class="hljs-number">-2</span>);<br>    ans = f[x1][<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">dfs</span>(x2, <span class="hljs-number">-2</span>);<br>        res += <span class="hljs-built_in">max</span>(ans, f[x2][<span class="hljs-number">0</span>]);<br>    &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA 12170 Easy Climb</title>
    <link href="/2020/09/07/UVA_12170_Easy_Climb/"/>
    <url>/2020/09/07/UVA_12170_Easy_Climb/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://vjudge.net/problem/UVA-12170">题目链接</a></p></blockquote><p>很容易想到一个状态表示方法<span class="math inline">\(f[i][j]\)</span>表示前<span class="math inline">\(i\)</span>个点，最后一个高度为<span class="math inline">\(j\)</span>时的最小花费。转移只用考虑上一个点填什么。<br /><span id="more"></span> 但是状态是表示不下的...</p><p>如果只有三个点，因为最左和最右不能改，那么中间的调整范围是<span class="math inline">\([\max (h-1-b,h-3-b),\min (h-1+b,h-3+b)]\)</span>，因为要代价最小，显然只能不调整或者取端点的高度。</p><p>yy 一下，发现其实每个点情况都类似，即<span class="math inline">\(h\)</span>最终一定是<span class="math inline">\(p-k+qd\)</span>这种形式。<br /><span class="math inline">\(1\leq p\leq n\)</span>, <span class="math inline">\(-n&lt;q&lt;n\)</span>。</p><p>所以把能用到的答案记录下来，第二维就被精简到了<span class="math inline">\(\mathcal{O}(2n^2)\)</span>。</p><p>于是现在有了一个<span class="math inline">\(\mathcal{O}(n^5)\)</span>的做法。</p><p>按<span class="math inline">\(h\)</span>的大小顺序转移，因为每个点的合法区间都是递增的，所以可以用单调队列像滑动窗口那样优化。决策是有单调性的，<del>虽然并不太会证</del>。<br />一个窗口内如果某时刻<span class="math inline">\(f[i-1][j]\)</span>增大了，后面的值不会更小，自己画个图看看应该不难理解...<br />判断一下不合法的条件是<span class="math inline">\(|h-1-h-n|&gt;(n-1)d\)</span><br />时间复杂度<span class="math inline">\(\mathcal{O}(n^3)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-keyword">const</span> ll INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">int</span> n, T, tn, q[N], head;<br>ll a[N * N * <span class="hljs-number">2</span>], d, f[<span class="hljs-number">2</span>][N * N * <span class="hljs-number">2</span>], h[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>tn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = -n + <span class="hljs-number">1</span>; j &lt;= n - <span class="hljs-number">1</span>; j++) &#123;<br>    a[++tn] = h[i] + j * <span class="hljs-number">1ll</span> * d;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + tn + <span class="hljs-number">1</span>);<br>    tn = <span class="hljs-built_in">unique</span>(a + <span class="hljs-number">1</span>, a + tn + <span class="hljs-number">1</span>) - a - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(h[n] - h[<span class="hljs-number">1</span>]) &gt; (n - <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * d) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tn; i++) &#123;<br>    f[now][i] = INF;<br>    <span class="hljs-keyword">if</span> (a[i] == h[<span class="hljs-number">1</span>]) f[now][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    now ^= <span class="hljs-number">1</span>;<br>    head = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tn; j++) &#123;<br>    <span class="hljs-keyword">while</span> (head &lt; tn &amp;&amp; a[head] &lt; a[j] - d) head++;<br>    <span class="hljs-keyword">while</span> (head &lt; tn &amp;&amp; f[now ^ <span class="hljs-number">1</span>][head + <span class="hljs-number">1</span>] &lt;= f[now ^ <span class="hljs-number">1</span>][head] &amp;&amp; a[head + <span class="hljs-number">1</span>] &lt;= a[j] + d) head++;<br>            <span class="hljs-keyword">if</span> (f[now ^ <span class="hljs-number">1</span>][head] == INF) f[now][j] = INF;<br>            <span class="hljs-keyword">else</span> f[now][j] = <span class="hljs-built_in">abs</span>(a[j] - h[i]) + f[now ^ <span class="hljs-number">1</span>][head];<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tn; i++) <span class="hljs-keyword">if</span> (a[i] == h[n]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[now][i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %lld&quot;</span>, &amp;n, &amp;d);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;h[i]);<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVALive 6938 Outer space invaders</title>
    <link href="/2020/09/07/UVALive_6938_Outer_space_invaders/"/>
    <url>/2020/09/07/UVALive_6938_Outer_space_invaders/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://vjudge.net/problem/UVALive-6938">题目链接</a></p></blockquote><p>把时间轴作为一个轴，距离做纵轴。<br />每个外星人的信息都是一条水平线段。<br />问题变成选一些竖直线段，使穿过所有的水平线段。</p><p>可以发现如果一段直线移动到刚刚穿过最近的一个端点，不会影响穿过的线段，所以启发我们只需要管端点。</p><p>区间 dp <span class="math inline">\(f[l][r]\)</span>表示<span class="math inline">\(l\)</span>到<span class="math inline">\(r\)</span>的最优答案。<br />每次决策只需要考虑最高线段在最高点哪个位置。</p><p>注意<span class="math inline">\(f\)</span>数组要开两倍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">705</span>;<br><span class="hljs-keyword">int</span> T, n, a[N], b[N], d[N], tx, f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) v.push-<span class="hljs-built_in">back</span>(a[i]), v.push-<span class="hljs-built_in">back</span>(b[i]);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    a[i] = lower-<span class="hljs-built_in">bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), a[i]) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>    b[i] = lower-<span class="hljs-built_in">bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), b[i]) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-keyword">int</span> m = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= m; len++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> L = <span class="hljs-number">-1</span>, R = <span class="hljs-number">-1</span>, C = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>    <span class="hljs-keyword">if</span> (a[k] &gt;= i &amp;&amp; b[k] &lt;= j) &#123;<br>    <span class="hljs-keyword">if</span> (C &lt; d[k]) C = d[k], L = a[k], R = b[k];<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-number">-1</span>) &#123;f[i][j] = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>;&#125;<br>            f[i][j] = <span class="hljs-number">1000000000</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = L; k &lt;= R; k++) &#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k - <span class="hljs-number">1</span>] + f[k + <span class="hljs-number">1</span>][j] + C);<br>            &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][m]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;a[i], &amp;b[i], &amp;d[i]);<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA10817 Headmaster&#39;s Headache</title>
    <link href="/2020/09/07/UVA10817_Headmaster&#39;s_Headache/"/>
    <url>/2020/09/07/UVA10817_Headmaster&#39;s_Headache/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://vjudge.net/problem/UVA-10817">题目链接</a></p></blockquote><p>读入方式很新颖啊<br />把没人教的科目，只有一个人教的科目，和两个人教的科目状压一下。<br /><span id="more"></span> 设状态<span class="math inline">\(f[i][s0][s1][s2]\)</span>为当前考虑了前<span class="math inline">\(i\)</span>人每个科目的状况，还需要的最小花费。<br />每个人无非选和不选两种决策，记搜一下。<br />转移从后面一个人转移过来，好像有点诡异。</p><p>这道题好像很难正向转移的样子，因为 s2 表示的其实是大于等于 2 人的科目，所以正着转移很难表示旧的 s2。<br />而考虑还剩多少钱，可以发现 s2 的科目是不减的，所以这样的状态就很方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">125</span>, M = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, s, S[N], C[N], f[N][M][M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> s0, <span class="hljs-keyword">int</span> s1, <span class="hljs-keyword">int</span> s2)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == n + m) <span class="hljs-keyword">return</span> s2 == (<span class="hljs-number">1</span> &lt;&lt; s) - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1000000000</span>;<br><span class="hljs-keyword">int</span> &amp;ans = f[x][s1][s2];<br><span class="hljs-keyword">if</span> (ans != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ans;<br>ans = <span class="hljs-number">1000000000</span>;<br><span class="hljs-keyword">if</span> (x &gt;= m) ans = <span class="hljs-built_in">min</span>(ans ,<span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, s0, s1, s2));<br>    <span class="hljs-keyword">int</span> m0 = S[x] &amp; s0, m1 = S[x] &amp; s1;<br>    s0 ^= m0; s1 ^= m1; s1 |= m0; s2 |= m1;<br>    ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, s0, s1, s2) + C[x]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span><br><span class="hljs-keyword">int</span> x;<br>    string line;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, line)) &#123;<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>    ss &gt;&gt; s &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span> &amp;&amp; m == <span class="hljs-number">0</span> &amp;&amp; n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n + m; i++) &#123;<br>    <span class="hljs-built_in">getline</span>(cin, line);<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>    ss &gt;&gt; C[i];<br>    S[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ss &gt;&gt; x) S[i] = (S[i] | (<span class="hljs-number">1</span> &lt;&lt;(x - <span class="hljs-number">1</span>)));<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, (<span class="hljs-number">1</span> &lt;&lt; s) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间交</title>
    <link href="/2020/09/05/%E5%8C%BA%E9%97%B4%E4%BA%A4/"/>
    <url>/2020/09/05/%E5%8C%BA%E9%97%B4%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://zhengruioi.com/contest/615/">题目链接</a></p></blockquote><h1 id="problem">Problem</h1><p>选取一些区间，使其区间交不小于<span class="math inline">\(k\)</span>。 <span id="more"></span> # Solution 区间交即是选出的区间的<span class="math inline">\([L-max,R-min]\)</span>。将所有区间按左端点排序，枚举每一个区间(区间的<span class="math inline">\(r-l &gt;= k\)</span>)将其左端点作为<span class="math inline">\(L-max\)</span>。设之前右端点不小于<span class="math inline">\(L-max+k\)</span>的区间有<span class="math inline">\(a\)</span>个，对答案的贡献是<span class="math inline">\(2^a\)</span>。可以用数据结构(比如支持单点修改和区间查询的线段树)或者优先队列维护。 # Code <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n,k,ans;<br>priority-queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> l,r;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;b) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> l&lt;b.l;<br>&#125;<br>&#125;a[N];<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-built_in">qpow</span>(a,b<span class="hljs-number">-1</span>)*a)%MOD;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mul=<span class="hljs-built_in">qpow</span>(a,b&gt;&gt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> (mul*mul)%MOD;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>()&lt;a[i].l+k) q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(a[i].l+k&lt;=a[i].r) ans=(ans+(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,q.<span class="hljs-built_in">size</span>())))%MOD;<br>    q.<span class="hljs-built_in">push</span>(a[i].r);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans%MOD);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10128 花神游历各国</title>
    <link href="/2020/09/04/LOJ_10128_%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/"/>
    <url>/2020/09/04/LOJ_10128_%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10128">题目链接</a></p></blockquote><p>线段树维护<span class="math inline">\(\max\)</span>, <span class="math inline">\(sum\)</span> 因为每个数最多被开根<span class="math inline">\(\log \log a-i\)</span>次，所以直接暴力修改。<br />当某个区间所有数开根后值不变时不用再修改，即<span class="math inline">\(0\leq a-i\leq 1\)</span>。<br />时间复杂度<span class="math inline">\(\mathcal{O}(m\log n+n\log \log a)\)</span><br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson (p &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson (p &lt;&lt; 1 | 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><br>ll sum[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> mx[N &lt;&lt; <span class="hljs-number">2</span>], a[N], n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>sum[p] = sum[lson] + sum[rson];<br>mx[p] = <span class="hljs-built_in">max</span>(mx[lson], mx[rson]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>    sum[p] = (ll)a[l]; <br>    mx[p] = a[l];<br>    <span class="hljs-keyword">return</span>; <br>    &#125;<br>    <span class="hljs-built_in">build</span>(lson, l, mid);<br>    <span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (mx[p] &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>a[l] = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(a[l]);<br>sum[p] = (ll)a[l]; <br>mx[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (L &lt;= mid) <span class="hljs-built_in">modify</span>(lson, l, mid, L, R);<br><span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">modify</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R);<br><span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qrymx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mx[p];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">qrymx</span>(lson, l, mid, L, R), <span class="hljs-built_in">qrymx</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R));<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">qrysum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> sum[p];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">qrysum</span>(lson, l, mid, L, R) + <span class="hljs-built_in">qrysum</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a + i);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> op, l, r;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;l, &amp;r);<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">qrysum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">qrymx</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构模板整理</title>
    <link href="/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"/>
    <url>/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>发现把数据结构忘得差不多了，赶紧补了一下<br />贴几篇讲得不错的博客，不打算再写一遍，骗访问量也要按基本法。<br /><span id="more"></span> ## 主席树 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span> &#123;</span><br><span class="hljs-keyword">int</span> l, r;<br>ll s;<br>&#125; tr[N &lt;&lt; <span class="hljs-number">7</span>];<br><br><span class="hljs-keyword">int</span> n, m, a[N], tot, root[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    p = ++tot;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>    tr[p].s = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">build</span>(tr[p].l, l, mid);<br>    <span class="hljs-built_in">build</span>(tr[p].r, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    tr[++tot] = tr[p];<br>    tr[tot].s += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>    p = <span class="hljs-built_in">clone</span>(p);<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (pos &lt;= mid) <span class="hljs-built_in">modify</span>(tr[p].l, l, mid, pos);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(tr[p].r, mid + <span class="hljs-number">1</span>, r, pos);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">int</span> kth = tr[tr[x].l].s - tr[tr[y].l].s;<br>    <span class="hljs-keyword">if</span> (kth &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(tr[x].l, tr[y].l, l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(tr[x].r, tr[y].r, mid + <span class="hljs-number">1</span>, r, k - kth);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), v.push-<span class="hljs-built_in">back</span>(a[i]);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> vn = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, vn);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>        a[i] = lower-<span class="hljs-built_in">bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), a[i]) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">modify</span>(root[i] = root[i - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>, vn, a[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> l, r, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, v[<span class="hljs-built_in">query</span>(root[r], root[l - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>, vn, k) - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> ## 平衡树 ### splay <a href="https://blog.csdn.net/Clove-unique/article/details/50630280">https://blog.csdn.net/Clove-unique/article/details/50630280</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1000019</span>, inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> tot, root, size[maxn], cnt[maxn], dat[maxn], val[maxn], ch[maxn][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    val[++tot] = v;<br>    dat[tot] = <span class="hljs-built_in">rand</span>();<br>    cnt[tot] = <span class="hljs-number">1</span>;<br>    size[tot] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; size[v] = size[ch[v][<span class="hljs-number">0</span>]] + size[ch[v][<span class="hljs-number">1</span>]] + cnt[v]; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = ch[id][d ^ <span class="hljs-number">1</span>];<br>    ch[id][d ^ <span class="hljs-number">1</span>] = ch[tmp][d];<br>    ch[tmp][d] = id;<br>    id = tmp;<br>    <span class="hljs-built_in">pushup</span>(ch[id][d]), <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id) &#123;<br>        id = <span class="hljs-built_in">New</span>(v);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (val[id] == v) &#123;<br>        cnt[id]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> d = val[id] &gt; v ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">insert</span>(ch[id][d], v);<br>        <span class="hljs-keyword">if</span> (dat[ch[id][d]] &gt; dat[id])<br>            <span class="hljs-built_in">rotate</span>(id, d ^ <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (val[id] == v) &#123;<br>        <span class="hljs-keyword">if</span> (cnt[id] &gt; <span class="hljs-number">1</span>) &#123;<br>            cnt[id]--;<br>            <span class="hljs-built_in">pushup</span>(id);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ch[id][<span class="hljs-number">1</span>] || ch[id][<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (!ch[id][<span class="hljs-number">0</span>] || dat[ch[id][<span class="hljs-number">1</span>]] &gt; dat[ch[id][<span class="hljs-number">0</span>]]) &#123;<br>                <span class="hljs-built_in">rotate</span>(id, <span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">1</span>], v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">rotate</span>(id, <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">0</span>], v);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span><br>            id = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pushup</span>(id);<br>    &#125;<br>    v &lt; val[id] ? <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">0</span>], v) : <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">1</span>], v);<br>    <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getrank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (val[id] == k)<br>        <span class="hljs-keyword">return</span> size[ch[id][<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; val[id])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getrank</span>(ch[id][<span class="hljs-number">0</span>], k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> size[ch[id][<span class="hljs-number">0</span>]] + cnt[id] + <span class="hljs-built_in">getrank</span>(ch[id][<span class="hljs-number">1</span>], k);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> rank)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">if</span> (rank &lt;= size[ch[id][<span class="hljs-number">0</span>]])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(ch[id][<span class="hljs-number">0</span>], rank);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank &lt;= size[ch[id][<span class="hljs-number">0</span>]] + cnt[id])<br>        <span class="hljs-keyword">return</span> val[id];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getval</span>(ch[id][<span class="hljs-number">1</span>], rank - size[ch[id][<span class="hljs-number">0</span>]] - cnt[id]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id = root, pre;<br>    <span class="hljs-keyword">while</span> (id) &#123;<br>        <span class="hljs-keyword">if</span> (v &gt; val[id])<br>            pre = val[id], id = ch[id][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span><br>            id = ch[id][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id = root, next;<br>    <span class="hljs-keyword">while</span> (id) &#123;<br>        <span class="hljs-keyword">if</span> (v &lt; val[id])<br>            next = val[id], id = ch[id][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span><br>            id = ch[id][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非旋treap">非旋treap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> root, dat[N], siz[N], val[N], ch[N][<span class="hljs-number">2</span>], cnt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NEW</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    siz[++cnt] = <span class="hljs-number">1</span>;<br>    dat[cnt] = <span class="hljs-built_in">rand</span>();<br>    val[cnt] = v;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;siz[x] = siz[ch[x][<span class="hljs-number">0</span>]] + siz[ch[x][<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span>&amp; x, <span class="hljs-keyword">int</span>&amp; y, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!now) &#123;x = y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">if</span> (val[now] &lt;= k) &#123;<br>        x = now;<br>        <span class="hljs-built_in">split</span>(ch[now][<span class="hljs-number">1</span>], ch[now][<span class="hljs-number">1</span>], y, k);<br>        <span class="hljs-built_in">pushup</span>(now);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y = now;<br>        <span class="hljs-built_in">split</span>(ch[now][<span class="hljs-number">0</span>], x, ch[now][<span class="hljs-number">0</span>], k);<br>        <span class="hljs-built_in">pushup</span>(now);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!x || !y) <span class="hljs-keyword">return</span> x | y;<br>    <span class="hljs-keyword">if</span>(dat[x] &lt; dat[y]) &#123;<br>        ch[x][<span class="hljs-number">1</span>] = <span class="hljs-built_in">merge</span>(ch[x][<span class="hljs-number">1</span>], y);<br>        <span class="hljs-built_in">pushup</span>(x);<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ch[y][<span class="hljs-number">0</span>] = <span class="hljs-built_in">merge</span>(x, ch[y][<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">pushup</span>(y);<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-built_in">split</span>(root, x, y, v - <span class="hljs-number">1</span>);<br>    root = <span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">NEW</span>(v), y));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x, y, z;<br>    <span class="hljs-built_in">split</span>(root, x, z, v);<br>    <span class="hljs-built_in">split</span>(x, x, y, v - <span class="hljs-number">1</span>);<br>    y = <span class="hljs-built_in">merge</span>(ch[y][<span class="hljs-number">0</span>], ch[y][<span class="hljs-number">1</span>]);<br>    root = <span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">merge</span>(y, z));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!now) <span class="hljs-keyword">return</span> <span class="hljs-number">-19260817</span>;<br>    <span class="hljs-keyword">if</span> (siz[ch[now][<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span> == k) <span class="hljs-keyword">return</span> val[now];<br>    <span class="hljs-keyword">if</span> (siz[ch[now][<span class="hljs-number">0</span>]] &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(ch[now][<span class="hljs-number">0</span>], k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(ch[now][<span class="hljs-number">1</span>], k - siz[ch[now][<span class="hljs-number">0</span>]] - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="旋转treap">旋转treap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> root, ch[N][<span class="hljs-number">2</span>], val[N], tot[N], cnt, dat[N], size[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    val[++cnt] = v;<br>    dat[cnt] = <span class="hljs-built_in">rand</span>();<br>    size[cnt] = <span class="hljs-number">1</span>;<br>    tot[cnt] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; size[v] = tot[v] + size[ch[v][<span class="hljs-number">0</span>]] + size[ch[v][<span class="hljs-number">1</span>]]; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    root = <span class="hljs-built_in">New</span>(-inf);<br>    ch[root][<span class="hljs-number">1</span>] = <span class="hljs-built_in">New</span>(inf);<br>    <span class="hljs-built_in">pushup</span>(root);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = ch[id][d ^ <span class="hljs-number">1</span>];<br>    ch[id][d ^ <span class="hljs-number">1</span>] = ch[tmp][d];<br>    ch[tmp][d] = id;<br>    id = tmp;<br>    <span class="hljs-built_in">pushup</span>(ch[id][d]);<br>    <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id) &#123;<br>        id = <span class="hljs-built_in">New</span>(v);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (val[id] == v) &#123;<br>        tot[id]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> d = v &gt; val[id];<br>        <span class="hljs-built_in">insert</span>(ch[id][d], v);<br>        <span class="hljs-keyword">if</span> (dat[ch[id][d]] &gt; dat[id])<br>            <span class="hljs-built_in">rotate</span>(id, d ^ <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;id, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[id] == v) &#123;<br>        <span class="hljs-keyword">if</span> (tot[id] &gt; <span class="hljs-number">1</span>) &#123;<br>            tot[id]--;<br>            <span class="hljs-built_in">pushup</span>(id);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch[id][<span class="hljs-number">1</span>] || ch[id][<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (!ch[id][<span class="hljs-number">1</span>] || dat[ch[id][<span class="hljs-number">0</span>]] &gt; dat[ch[id][<span class="hljs-number">1</span>]]) &#123;<br>                <span class="hljs-built_in">rotate</span>(id, <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">1</span>], v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">rotate</span>(id, <span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">0</span>], v);<br>            &#125;<br>            <span class="hljs-built_in">pushup</span>(id);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            id = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">pushup</span>(id);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    v &gt; val[id] ? <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">1</span>], v) : <span class="hljs-built_in">remove</span>(ch[id][<span class="hljs-number">0</span>], v);<br>    <span class="hljs-built_in">pushup</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">opt3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (val[id] == x)<br>        <span class="hljs-keyword">return</span> size[ch[id][<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; val[id])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">opt3</span>(ch[id][<span class="hljs-number">0</span>], x);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> tot[id] + size[ch[id][<span class="hljs-number">0</span>]] + <span class="hljs-built_in">opt3</span>(ch[id][<span class="hljs-number">1</span>], x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">opt4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (size[ch[id][<span class="hljs-number">0</span>]] &gt;= x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">opt4</span>(ch[id][<span class="hljs-number">0</span>], x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size[ch[id][<span class="hljs-number">0</span>]] + tot[id] &gt;= x)<br>        <span class="hljs-keyword">return</span> val[id];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">opt4</span>(ch[id][<span class="hljs-number">1</span>], x - tot[id] - size[ch[id][<span class="hljs-number">0</span>]]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pre, id = root;<br>    <span class="hljs-keyword">while</span> (id) &#123;<br>        <span class="hljs-keyword">if</span> (x &gt; val[id]) &#123;<br>            pre = id;<br>            id = ch[id][<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span><br>            id = ch[id][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> val[pre];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnxt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> nxt, id = root;<br>    <span class="hljs-keyword">while</span> (id) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; val[id]) &#123;<br>            nxt = id;<br>            id = ch[id][<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span><br>            id = ch[id][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> val[nxt];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串相关">字符串相关</h2><h3 id="sa">SA</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, sa[N], x[N], y[N], c[N], ht[N], m, p; <span class="hljs-comment">//x-&gt;rank  y[i]-&gt;第i大的第二关键字所对应的第一关键字位置</span><br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>); m = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ++c[x[i] = s[i]];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) c[i] += c[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) sa[c[x[i]]--] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w = <span class="hljs-number">1</span>; w &lt;= n; w &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - w + <span class="hljs-number">1</span>; i &lt;= n; i++) y[++p] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-keyword">if</span>(sa[i] &gt; w) y[++p] = sa[i] - w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) c[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ++c[x[i]];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) c[i] += c[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) sa[c[x[y[i]]]--] = y[i];<br>    <span class="hljs-built_in">swap</span>(x, y); p = <span class="hljs-number">1</span>;<br>        x[sa[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="hljs-number">1</span>]] &amp;&amp; y[sa[i] + w] == y[sa[i - <span class="hljs-number">1</span>] + w]) ? p : ++p;<br>        <span class="hljs-keyword">if</span>(p == n) <span class="hljs-keyword">break</span>;<br>        m = p;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">if</span>(k) --k;<br>      <span class="hljs-keyword">while</span>(s[i + k] == s[sa[x[i] - <span class="hljs-number">1</span>] + k]) ++k;<br>      ht[x[i]] = k;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, sa[i]);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ht[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kmp">kmp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1000086</span>;<br><span class="hljs-keyword">int</span> f[N], n;<br><span class="hljs-keyword">char</span> s[N], a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; a + <span class="hljs-number">1</span> &gt;&gt; s + <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>), j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (s[j + <span class="hljs-number">1</span>] != s[i] &amp;&amp; j) j = f[j];<br>        j += s[i] == s[j + <span class="hljs-number">1</span>];<br>        f[i] = j;<br>    &#125;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (s[j + <span class="hljs-number">1</span>] != a[i] &amp;&amp; j) j = f[j];<br>        j += s[j + <span class="hljs-number">1</span>] == a[i];<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            ans++;<br>            j = f[j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态树">动态树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, ch[N][<span class="hljs-number">2</span>], f[N], s[N], r[N], v[N];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lc ch[x][0]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rc ch[x][1]</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">noroot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> ch[f[x]][<span class="hljs-number">1</span>] == x || ch[f[x]][<span class="hljs-number">0</span>] == x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    s[x] = s[lc] ^ s[rc] ^ v[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">swap</span>(lc, rc);<br>r[x] ^= <span class="hljs-number">1</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (r[x]) &#123;<br><span class="hljs-keyword">if</span> (lc) <span class="hljs-built_in">pushr</span>(lc);<br><span class="hljs-keyword">if</span> (rc) <span class="hljs-built_in">pushr</span>(rc);<br>r[x] = <span class="hljs-number">0</span>; <br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> y = f[x], z = f[y], k = (ch[y][<span class="hljs-number">1</span>] == x), w = ch[x][k ^ <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">noroot</span>(y)) ch[z][y == ch[z][<span class="hljs-number">1</span>]] = x;<br>ch[x][k ^ <span class="hljs-number">1</span>] = y;<br>ch[y][k] = w;<br><span class="hljs-keyword">if</span> (w) f[w] = y;<br>f[y] = x;<br>f[x] = z;<br><span class="hljs-built_in">pushup</span>(y);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">noroot</span>(x)) <span class="hljs-built_in">update</span>(f[x]);<br><span class="hljs-built_in">pushdown</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> ch[f[x]][<span class="hljs-number">1</span>] == x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">update</span>(x);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> fa; fa = f[x], <span class="hljs-built_in">noroot</span>(x); <span class="hljs-built_in">rotate</span>(x)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">noroot</span>(fa)) <span class="hljs-built_in">rotate</span>(<span class="hljs-built_in">get</span>(x) == <span class="hljs-built_in">get</span>(fa) ? fa : x);<br>&#125;<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p;<br>    <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; x; p = x, x = f[x]) &#123;<br>        <span class="hljs-built_in">splay</span>(x), ch[x][<span class="hljs-number">1</span>] = p, <span class="hljs-built_in">pushup</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x);<br><span class="hljs-built_in">pushr</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">access</span>(x);<br><span class="hljs-built_in">splay</span>(x);<br><span class="hljs-keyword">while</span> (lc) <span class="hljs-built_in">pushdown</span>(x), x = lc;<br><span class="hljs-built_in">splay</span>(x);<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">makeroot</span>(x);<br>    <span class="hljs-built_in">access</span>(y);<span class="hljs-built_in">splay</span>(y);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">makeroot</span>(x);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">findroot</span>(y) != x) f[x] = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">makeroot</span>(x);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">findroot</span>(y) == x &amp;&amp; f[y] == x &amp;&amp; !ch[x][<span class="hljs-number">0</span>]) &#123;<br>f[y] = ch[x][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">pushup</span>(x);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>    <span class="hljs-keyword">int</span> opt, x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;opt, &amp;x, &amp;y);<br>    <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">0</span>) <span class="hljs-built_in">split</span>(x, y), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[y]);<br>    <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">link</span>(x, y);<br>    <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) <span class="hljs-built_in">cut</span>(x, y);<br>    <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">splay</span>(x), v[x] = y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉还有好多不会啊<br />有时间继续更新，是时候该继续学数据结构了...</p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3403 跳楼机</title>
    <link href="/2020/09/02/P3403_%E8%B7%B3%E6%A5%BC%E6%9C%BA/"/>
    <url>/2020/09/02/P3403_%E8%B7%B3%E6%A5%BC%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>新科技 同余最短路 <a href="https://www.luogu.com.cn/problem/P3403">题目链接</a></p></blockquote><p>先考虑后两种走法能走到的楼层.<br />按照模数分类, 具体<span class="math inline">\(f[i]\)</span>表示最小的楼层使<span class="math inline">\(f[i]\bmod x=i\)</span>, <span id="more"></span></p><p>为什么要这样做呢？<br />因为能到达的楼层无非就是<span class="math inline">\(ax+by+cz\)</span><br />我们当<span class="math inline">\(x\text{,}y\)</span>固定时，方案数是<span class="math inline">\(\left\lfloor\frac{h-x-y}{z}\right\rfloor\)</span><br />我们考虑所有<span class="math inline">\(ax+by\)</span>，都可以算出对应的方案。<br />但是发现这样会算重复一些楼层。<br />可以发现当<span class="math inline">\(ax+by\equiv a&#39;x+b&#39;y \pmod z\)</span>会重复计算<br />显然这时候我们只需要保留最小的<span class="math inline">\(ax+by\)</span>就可以了<br />所以按照<span class="math inline">\(\bmod z\)</span>的每一个余数分类，保留最小的楼层即可。</p><p>最后答案<span class="math inline">\(\sum\limits-{i=0}^{x-1}\left\lfloor\frac{h-f[i]}{x}\right\rfloor +1\text{,}f[i]\leq h\)</span>.<br />加 1 是因为要算上只用后两个方法走到的楼层.<br />这样统计是不重不漏的.</p><p>那么怎么算<span class="math inline">\(f\)</span>呢？ 根据同余方程的性质, 可以有转移<br /><span class="math inline">\(f[(i+y)\bmod x]=f[i]+y\)</span><br /><span class="math inline">\(f[(i+z)\bmod x]=f[i]+z\)</span></p><p>因为<span class="math inline">\(f[i]=ay+bz\)</span><br />即<span class="math inline">\(ay+bz\equiv i\pmod x\)</span><br />以第一个转移为例，<span class="math inline">\(f[i]+y=ay+bz+y\)</span><br /><span class="math inline">\(ay+bz+y\)</span>在模<span class="math inline">\(x\)</span>的意义下和<span class="math inline">\(i+y\)</span>同余。<br />但是这样转移并不一定<span class="math inline">\(f[i]+y\)</span>就是最小的楼层。</p><p>这个方程可以用最短路来求解, 具体建图方法<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) <span class="hljs-built_in">add</span>(i, (i + y) % x, <span class="hljs-number">1ll</span> *  y), <span class="hljs-built_in">add</span>(i, (i + z) % x, <span class="hljs-number">1ll</span> *  z);<br>```  <br><br>注意图的部分数组要开两倍.  <br><br>```cpp<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> x, y, z, head[N], cnt;<br>ll dis[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v; ll w;<br>&#125; e[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, ll w)</span> </span>&#123;e[++cnt] = (E)&#123;head[u], v, w&#125;; head[u] = cnt;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">bool</span> vis[N] = &#123;&#125;;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>dis[s] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(s), vis[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> now = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>(), vis[now] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[now]; i; i = e[i].nxt) &#123;<br><span class="hljs-keyword">int</span> v = e[i].v; ll w = e[i].w;<br><span class="hljs-keyword">if</span> (dis[now] + w &lt; dis[v]) &#123;<br>dis[v] = dis[now] + w;<br><span class="hljs-keyword">if</span> (!vis[v]) q.<span class="hljs-built_in">push</span>(v), vis[v] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ll h = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %d %d %d&quot;</span>, &amp;h ,&amp;x, &amp;y, &amp;z);<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> || y == <span class="hljs-number">1</span> || z == <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, h); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) <span class="hljs-built_in">add</span>(i, (i + y) % x, <span class="hljs-number">1ll</span> *  y), <span class="hljs-built_in">add</span>(i, (i + z) % x, <span class="hljs-number">1ll</span> *  z);<br>    <span class="hljs-built_in">SPFA</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) <span class="hljs-keyword">if</span> ((ll)dis[i] &lt;= h) ans = ans + (h - (ll)(dis[i])) / (ll)(x) + <span class="hljs-number">1ll</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同余最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 529 「LibreOJ β Round</title>
    <link href="/2020/09/01/LOJ_529_%E3%80%8CLibreOJ_%CE%B2_Round_#5%E3%80%8D%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80/"/>
    <url>/2020/09/01/LOJ_529_%E3%80%8CLibreOJ_%CE%B2_Round_#5%E3%80%8D%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/529">题目链接</a></p></blockquote><h2 id="题解">题解</h2><p>简洁的做法是找出合法串的特点，直接判断。<br />目的是把串还原成 N 。 <span id="more"></span> 因为端点的 V 一定是由 NV 或者 VN 产生的，所以可以直接消掉。<br />同理对于连续的 V 也可以从端点开始消除成为 1 个 V。<br />而且连续的 N 一定也是不合法的，数学归纳法可以证明。</p><p>对于英文串，只要不单是 V 就一定合法。<br />中文串额外判断一下左端点是不是 N 。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span> (T--) &#123;<br><span class="hljs-keyword">bool</span> pd1 = <span class="hljs-number">0</span>, pd2 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;N&#x27;</span>) pd1 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;N&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>) pd2 = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!pd1 || pd2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0 0&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 %d\n&quot;</span>, s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>康托展开</title>
    <link href="/2020/09/01/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <url>/2020/09/01/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/167">题目链接</a></p></blockquote><h2 id="题目">题目</h2><p>求一个排列在<span class="math inline">\(1\)</span>~<span class="math inline">\(N\)</span>的全排列中的排名。</p><h2 id="解析">解析</h2><p>从第一个数开始考虑，比它小的排列第一个数一定比它小，设为<span class="math inline">\(k\)</span>个。<br />后面的数可以乱排，方案数是<span class="math inline">\(k\times (n-1)!\)</span>。<br />后面的数同理，不能再用前面出现的数。<br />每一次都要找比当前数小的数个数，用权值树状数组维护。<br />时间复杂度<span class="math inline">\(\mathcal{O}(n\log n)\)</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>, N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, a[N], tr[N], fac[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">for</span> (; x &lt;= n; x += x &amp; -x) tr[x] += v;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span> (; x; x -= x &amp; -x) res += tr[x]; <span class="hljs-keyword">return</span> res;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(y) - <span class="hljs-built_in">qry</span>(x - <span class="hljs-number">1</span>);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]), <span class="hljs-built_in">upd</span>(a[i], <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        res = (res + fac[n - i] * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">qry</span>(a[i] - <span class="hljs-number">1</span>) % MOD) % MOD;<br>        <span class="hljs-built_in">upd</span>(a[i], <span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>康托展开</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子序列问题</title>
    <link href="/2020/09/01/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/01/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>自己出了一道题，感觉挺有意思的。</p></blockquote><h1 id="题目">题目</h1><p>一个长度为<span class="math inline">\(n\)</span>的序列，将每个子序列的权值定义为<span class="math inline">\(\min(a-l,a-{l+1},...,a-r)\times \max(a-l,a-{l+1},...,a-r)\)</span>。 <span id="more"></span><br />对于所有长度不小于<span class="math inline">\(k\)</span>的连续子序列，要你求出一段权值严格次大的子序列。如果不存在这样的子序列，输出最大的权值。</p><h1 id="题解">题解</h1><p>因为总是会有一个数作为最小值，所以直接枚举每个数作为区间最小值。<br />当某个数<span class="math inline">\(a-i\)</span>做最小值时，用单调栈分别算出<span class="math inline">\(a-i\)</span>最多向左和向右延伸的最长长度。记为<span class="math inline">\(L-i\)</span>和<span class="math inline">\(R-i\)</span>。<br />如果<span class="math inline">\(R-i-L-i+1\geq k\)</span>，那么就可以把<span class="math inline">\(a-i\times max(a-l,a-{l+1},...,a-r)\)</span>记录下来，因为它有可能成为答案。把<span class="math inline">\(max(a-l,a-{l+1},...,a-r)\)</span>记为<span class="math inline">\(MAX\)</span>。<br />但是要求次大值。当<span class="math inline">\(a-i\)</span>作为最小值时，需要找到一个区间<span class="math inline">\([l-0,r-0]\)</span>使<span class="math inline">\(max(a[l-0] \sim a[r-0])\)</span>与<span class="math inline">\(MAX\)</span>不同。并且<span class="math inline">\(r-0-l-0\)</span>尽量大，那么就找到了这个次大值。具体方法是开桶记录每个元素的位置，查出与<span class="math inline">\(a-i\)</span>相邻的两个<span class="math inline">\(MAX\)</span>的位置，与<span class="math inline">\([L-i,R-i]\)</span>取一个交集就是<span class="math inline">\([l-0,r-0]\)</span>了。一样的方法把次大的权值记录下来。<br />处理完之后就能得到次小或者最大的权值了，注意细节就可以。<br />时间复杂度<span class="math inline">\(\mathcal{O}(nlogn)\)</span>，主要瓶颈是找区间最大值上。</p><h1 id="code">code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, k, a[N], l[N], r[N], q[N], f[N][<span class="hljs-number">21</span>], bit[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v[N];<br>ll max1, max2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<br>    bit[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) bit[i] = bit[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> logn2 = (<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">log</span>(n) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= logn2; j++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - bit[j] +  <span class="hljs-number">1</span>; i++) &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + bit[j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    <span class="hljs-keyword">int</span> head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) tail--;<br>        <span class="hljs-keyword">if</span>(tail &lt; head) l[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l[i] = q[tail] + <span class="hljs-number">1</span>;<br>        q[++tail] = i;<br>    &#125;<br>    tail = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) tail--;<br>        <span class="hljs-keyword">if</span>(tail &lt; head) r[i] = n;<br>        <span class="hljs-keyword">else</span> r[i] = q[tail] - <span class="hljs-number">1</span>;<br>        q[++tail] = i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> logn2=(<span class="hljs-keyword">int</span>) (<span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[l][logn2], f[r - bit[logn2] + <span class="hljs-number">1</span>][logn2]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x &gt; max1) &#123;<br>        max2 = max1;<br>        max1 = x;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; max1 &amp;&amp; x &gt; max2) &#123;<br>        max2 = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        a[i] = <span class="hljs-built_in">read</span>();<br>        v[a[i]].push-<span class="hljs-built_in">back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">pre</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(r[i] - l[i] + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> MAX = <span class="hljs-built_in">query</span>(l[i], r[i]);<br>        <span class="hljs-built_in">update</span>(MAX * <span class="hljs-number">1ll</span> * a[i]);<br>        <span class="hljs-keyword">if</span>(a[i] == MAX) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> y = lower-<span class="hljs-built_in">bound</span>(v[MAX].<span class="hljs-built_in">begin</span>(), v[MAX].<span class="hljs-built_in">end</span>(), i) - v[MAX].<span class="hljs-built_in">begin</span>(), l0, r0;<br>        <span class="hljs-keyword">if</span>(y == v[MAX].<span class="hljs-built_in">size</span>()) r0 = n;<br>        <span class="hljs-keyword">else</span> r0 = v[MAX][y] - <span class="hljs-number">1</span>;<br>        --y;<br>        <span class="hljs-keyword">if</span>(v[MAX][y] == i) --y;<br>        <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span>) l0 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l0 = v[MAX][y] + <span class="hljs-number">1</span>;<br>        l0 = <span class="hljs-built_in">max</span>(l0, l[i]); r0 = <span class="hljs-built_in">min</span>(r0, r[i]);<br>        <span class="hljs-keyword">if</span>(r0 - l0 + <span class="hljs-number">1</span> &lt; k || r0 &lt; i || l0 &gt; i) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">query</span>(l0, r0) * <span class="hljs-number">1ll</span> * a[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!max2) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, max1);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, max2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 10203「一本通 6.3 例 1」反素数 Antiprime</title>
    <link href="/2020/09/01/LOJ_10203%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A_6.3_%E4%BE%8B_1%E3%80%8D%E5%8F%8D%E7%B4%A0%E6%95%B0_Antiprime/"/>
    <url>/2020/09/01/LOJ_10203%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A_6.3_%E4%BE%8B_1%E3%80%8D%E5%8F%8D%E7%B4%A0%E6%95%B0_Antiprime/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/10203">题目链接</a></p></blockquote><p>##题解 把<span class="math inline">\(n\)</span>质因数分解一下，即<span class="math inline">\(n=\prod p-i^{k-i}\)</span><br />关于反素数的两个结论:<br />1. 如果两个数约数个数相同，那么更大的数不可能是反素数。<br />2. 我们枚举每个<span class="math inline">\(k-i\)</span>，<span class="math inline">\(k-i\)</span>一定是单调不增的。因为如果某个不满足条件的数是反素数，那么将<span class="math inline">\(k\)</span>调整为单调不增的形式，得到一个比它小的数且约数个数相同，与题设矛盾。所以<span class="math inline">\(k-i\)</span>一定是单调不增的。</p><p>有了以上结论，直接 dfs 枚举每个<span class="math inline">\(k-i\)</span>。<br />因为最多只需要枚举到第<span class="math inline">\(\log-{2}^{2e9}\)</span>个素数，且<span class="math inline">\(k\)</span>不大，所以时间复杂度是正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e9</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">60</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> P[M], vis[M], cnt;<br>ll tot, ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) P[++cnt] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; P[j] * i &lt;= n; j++) &#123;<br>vis[P[j] * i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % P[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> lst, ll num, ll v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &gt; tot || (num == tot &amp;&amp; v &lt; ans)) ans = v, tot = num;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (v * P[x] &lt;= n &amp;&amp; cnt &lt; lst) &#123;<br>    v *= P[x];<br>    cnt++;<br>    <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, cnt, num * (cnt + <span class="hljs-number">1</span>), v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(M - <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>唯一分解定理</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2279「SCOI2007」降雨量</title>
    <link href="/2020/08/31/LOJ_2279%E3%80%8CSCOI2007%E3%80%8D%E9%99%8D%E9%9B%A8%E9%87%8F/"/>
    <url>/2020/08/31/LOJ_2279%E3%80%8CSCOI2007%E3%80%8D%E9%99%8D%E9%9B%A8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早就听闻过 BZOJ 上这道题的神贴了，虽然 BZOJ 现在没了...</p></blockquote><p>显然就是线段树来维护一下区间最值，修改都不需要。<br />但是...<br /><span id="more"></span> 细节一车，对着下的两个样例检查才找到没考虑到的问题。<br />主要注意一下询问的<span class="math inline">\(x\)</span>,<span class="math inline">\(y\)</span>数据没有给出的情况就可以了。<br />思维难度不大，主要是细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50005</span>;<br><span class="hljs-keyword">int</span> n, Q;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br><span class="hljs-keyword">int</span> x, r;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> data &amp;a) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> x &lt; a.x;<br>&#125;<br>&#125; q[N];<br>map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br><span class="hljs-keyword">int</span> mi[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson (p &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson (p &lt;&lt; 1 | 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>    mi[p] = q[l].r;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">build</span>(lson, l, mid);<br>    <span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>    mi[p] = <span class="hljs-built_in">max</span>(mi[lson], mi[rson]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">-1000000007</span>;<br><span class="hljs-keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mi[p];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">qry</span>(lson, l, mid, L, R), <span class="hljs-built_in">qry</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//freopen(&quot;2.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;2.out&quot;, &quot;w&quot;, stdout);</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;q[i].x, &amp;q[i].r);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) m[q[i].x] = i;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= Q; i++) &#123;<br>    <span class="hljs-keyword">int</span> x, y;  <span class="hljs-comment">//x, y 是年份</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;y, &amp;x);<br>    <span class="hljs-keyword">if</span> (!m[y] &amp;&amp; !m[x]) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>    <span class="hljs-keyword">continue</span>;<br>    &#125;<br>        <span class="hljs-keyword">if</span> (!m[x]) &#123;<br>        <span class="hljs-keyword">int</span> px = upper-<span class="hljs-built_in">bound</span>(q + <span class="hljs-number">1</span>, q + n + <span class="hljs-number">1</span>, (data)&#123;x, <span class="hljs-number">0</span>&#125;) - q - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> py = m[y];<br>        <span class="hljs-keyword">if</span> (px - py &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (q[py].r &lt;= q[px].r &amp;&amp; px != py) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> z = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, py + <span class="hljs-number">1</span>, px);<br>            <span class="hljs-keyword">if</span> (z &gt;= q[py].r) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    <span class="hljs-keyword">bool</span> fl = (m[y] != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!fl) &#123;<br>        <span class="hljs-keyword">int</span> py = lower-<span class="hljs-built_in">bound</span>(q + <span class="hljs-number">1</span>, q + n + <span class="hljs-number">1</span>, (data)&#123;y, <span class="hljs-number">0</span>&#125;) - q;<br>        <span class="hljs-keyword">int</span> px = m[x];<br>        <span class="hljs-keyword">if</span> (px - py &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (q[py].r &gt;= q[px].r &amp;&amp; px != py) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> z = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, py, px - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (z &gt;= q[px].r) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> py = m[y], px = m[x];<br>        <span class="hljs-keyword">if</span> (q[py].r &lt; q[px].r) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">if</span> (px - py &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (x - y == px - py) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">int</span> z = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, py + <span class="hljs-number">1</span>, px - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (z &gt;= q[px].r) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x - y == px - py) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;maybe&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 3282 「JOISC 2020 Day4」治疗计划</title>
    <link href="/2020/08/31/LOJ_3282_%E3%80%8CJOISC_2020_Day4%E3%80%8D%E6%B2%BB%E7%96%97%E8%AE%A1%E5%88%92/"/>
    <url>/2020/08/31/LOJ_3282_%E3%80%8CJOISC_2020_Day4%E3%80%8D%E6%B2%BB%E7%96%97%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/3282">题目链接</a></p></blockquote><p>两个计划的治疗区间<span class="math inline">\([l-i,r-i]\)</span>, <span class="math inline">\([l-j,r-j]\)</span>可以合并，当且仅当<span class="math inline">\([r-i-l-j+1\geq \left |T-i-T-j\right |]\)</span><br />按照区间顺序，可以有<span class="math inline">\(\mathcal{O}(m^2)\)</span>的暴力 dp , 每次选出一个最小的去合并其他区间。<br /><span id="more"></span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> ll INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">int</span> n, m, t[N], r[N], l[N];<br>ll f[N], c[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">()</span> </span>&#123;<br>ll ans = INF; <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; f[i] &lt; ans) &#123;<br>pos = i;<br>ans = f[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %lld&quot;</span>, &amp;t[i], &amp;l[i], &amp;r[i], &amp;c[i]);<br>    <span class="hljs-keyword">if</span> (l[i] == <span class="hljs-number">1</span>) f[i] = c[i];<br>        <span class="hljs-keyword">else</span> f[i] = INF;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">find</span>(); pos; pos = <span class="hljs-built_in">find</span>()) &#123;<br>        vis[pos] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (r[pos] - l[i] + <span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">abs</span>(t[i] - t[pos])) f[i] = <span class="hljs-built_in">min</span>(f[i], f[pos] + (ll)c[i]);<br>        &#125;<br>    &#125;<br>    ll ans = INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-keyword">if</span> (r[i] == n) ans = <span class="hljs-built_in">min</span>(ans, f[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans == INF ? <span class="hljs-number">-1</span> : ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>可以看出这个 dp 可以用最短路来做。<br />把之前的式子绝对值去掉，<br /><span class="math inline">\(T-i\geq T-j\)</span>时,<span class="math inline">\(r-i-T-i+1\geq l-j-T-j\)</span><br /><span class="math inline">\(T-i&lt;T-j\)</span>时,<span class="math inline">\(r-i+T-i+1\geq l-j+T-j\)</span><br />按照时间顺序维护两颗线段树，每次用线段树找出边。<br />最短路的时候更新 dis 就可以了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br><span class="hljs-keyword">int</span> t, l, r;ll c;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> data &amp;x) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> t &lt; x.t;<br>&#125; <br>&#125; qaq[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-keyword">int</span> n, m;<br>ll dis[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment</span>-<span class="hljs-title">Tree</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson (p &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson (p &lt;&lt; 1 | 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br>    <span class="hljs-keyword">int</span> mi[N &lt;&lt; <span class="hljs-number">2</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>    mi[p] = qaq[l].l + sig * qaq[l].t;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">build</span>(lson, l, mid, sig);<br>    <span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r, sig);<br>    mi[p] = <span class="hljs-built_in">min</span>(mi[lson], mi[rson]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>        mi[p] = INF;<br>        <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos &lt;= mid) <span class="hljs-built_in">erase</span>(lson, l, mid, pos);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">erase</span>(rson, mid + <span class="hljs-number">1</span>, r, pos);<br>        mi[p] = <span class="hljs-built_in">min</span>(mi[lson], mi[rson]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> bound)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mi[p] &gt; bound) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>        v.push-<span class="hljs-built_in">back</span>(l);<br>        <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (L &lt;= mid)<span class="hljs-built_in">qry</span>(lson, l, mid, L, R, bound);<br>        <span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">qry</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R, bound);<br>    &#125;<br>&#125; T1, T2;<br><br>priority-queue&lt;pair&lt;ll, <span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-function">ll <span class="hljs-title">dij</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">if</span> (qaq[i].l == <span class="hljs-number">1</span>) &#123;<br>q.<span class="hljs-built_in">push</span>(&#123;-qaq[i].c, i&#125;);<br>            dis[i] = qaq[i].c;<br>            T1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, i);<br>            T2.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">top</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (qaq[u].r == n) <span class="hljs-keyword">return</span> dis[u];<br>v.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">1</span>) T1.<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, u - <span class="hljs-number">1</span>, qaq[u].r - qaq[u].t + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (u &lt; m) T2.<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, u + <span class="hljs-number">1</span>, m, qaq[u].r + qaq[u].t + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v) &#123;<br>dis[i] = dis[u] + qaq[i].c;<br>q.<span class="hljs-built_in">push</span>(&#123;-dis[i], i&#125;);<br>T1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, i);<br>T2.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %lld&quot;</span>, &amp;qaq[i].t, &amp;qaq[i].l, &amp;qaq[i].r, &amp;qaq[i].c);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(qaq + <span class="hljs-number">1</span>, qaq + m + <span class="hljs-number">1</span>);<br>    T1.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">-1</span>);<br>    T2.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dij</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 124 &amp;amp; 125 除数函数求和</title>
    <link href="/2020/08/31/LOJ_124_&amp;amp;_125_%E9%99%A4%E6%95%B0%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/08/31/LOJ_124_&amp;amp;_125_%E9%99%A4%E6%95%B0%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="除数函数求和1">除数函数求和1</h2><h3 id="题目">题目</h3><p><span class="math inline">\(\sigma-k(n)=\sum-{d\mid n}d^k\)</span><br />求<span class="math inline">\(\sum-{i=1}^{n}\sigma-k(i)\)</span>的值对<span class="math inline">\(1e9+7\)</span>取模的结果。<br /><span id="more"></span> ### 题解 直接枚举约数<br /><span class="math inline">\(\sum\limits-{d=1}^{n}d^k\sum\limits-{i=1}^{n}[d\mid i]\)</span><br /><span class="math inline">\(\sum\limits-{d=1}^{n}d^k\left\lfloor\frac{n}{d}\right\rfloor\)</span><br />欧拉筛预处理<span class="math inline">\(d^k\)</span>，数论分块即可。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span>  + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> P[N], n, k, cnt, mi[N], vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * a % MOD;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>mi[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, mi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) P[++cnt] = i, mi[i] = <span class="hljs-built_in">fpow</span>(i, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; P[j] * i &lt;= n; j++) &#123;<br>    vis[i * P[j]] = <span class="hljs-number">1</span>;<br>    mi[i * P[j]] = mi[i] * <span class="hljs-number">1ll</span> * mi[P[j]] % MOD;<br>    <span class="hljs-keyword">if</span> (i % P[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) mi[i] = ((ll)mi[i] + (ll)mi[i - <span class="hljs-number">1</span>]) % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j; i &lt;= n; i = j + <span class="hljs-number">1</span>) &#123;<br>    j = n / (n / i);<br>        res = ((ll)res + (n / i) * <span class="hljs-number">1ll</span> * (mi[j] - mi[i - <span class="hljs-number">1</span>]) % MOD + MOD) % MOD; <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除数函数求和2">除数函数求和2</h2><p>###题目 求<span class="math inline">\(\sum-{i=1}^{n}2\sigma-2(i)+3\sigma-1(i)+5\sigma-0(i)\)</span>对<span class="math inline">\(998244353\)</span>取模。<br />其中<span class="math inline">\(\sigma-k(n)=\sum-{d\mid n}d^k\)</span>。</p><p>###题解 先把式子展开，有前面的经验，将三个式子分开计算。<br /><span class="math inline">\(2\sum-{i=1}^{n}\sigma-2(i)+3\sum-{i=1}^{n}\sigma-1(i)+5\sum-{i=1}^{n}\sigma-0(i)\)</span><br /><span class="math inline">\(2\sum-{d=1}^{n}d^2\left\lfloor\frac{n}{d}\right\rfloor+3\sum-{i=1}^{n}d\left\lfloor\frac{n}{d}\right\rfloor+5\sum-{i=1}^{n}\left\lfloor\frac{n}{d}\right\rfloor\)</span><br />第三个显然数论分块。<br />前两个结合一下自然数幂之和的公式。<br /><span class="math inline">\(\sum\limits-{i=1}^{n}i=\frac{n(n+1)}{2}\)</span><br /><span class="math inline">\(\sum\limits-{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}\)</span></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>, i6 = <span class="hljs-number">166374059</span>, i2 = <span class="hljs-number">499122177</span>;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (((y + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * y % MOD) * i2 % MOD - ((x + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * x % MOD) * i2 % MOD) % MOD;  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">return</span> ((y * <span class="hljs-number">1ll</span> * (y + <span class="hljs-number">1</span>) % MOD * (<span class="hljs-number">2</span> * y + <span class="hljs-number">1</span>) % MOD) * i6 % MOD - (x * <span class="hljs-number">1ll</span> * (x + <span class="hljs-number">1</span>) % MOD * (<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>) % MOD) * i6 % MOD) % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">int</span> res0 = <span class="hljs-number">0</span>, res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j; i &lt;= n; i = j + <span class="hljs-number">1</span>) &#123;<br>    j = n / (n / i);<br>    res0 = ((ll)res0 + (j - i + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (n / i)) % MOD;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j; i &lt;= n; i = j + <span class="hljs-number">1</span>) &#123;<br>    j = n / (n / i);<br>    res1 = (res1 + <span class="hljs-built_in">qry1</span>(i - <span class="hljs-number">1</span>, j) * <span class="hljs-number">1ll</span> * (n / i) % MOD) % MOD;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j; i &lt;= n; i = j + <span class="hljs-number">1</span>) &#123;<br>    j = n / (n / i);<br>    res2 = (res2 + <span class="hljs-built_in">qry2</span>(i - <span class="hljs-number">1</span>, j) * <span class="hljs-number">1ll</span> * (n / i) % MOD) % MOD;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ((<span class="hljs-number">2</span> * <span class="hljs-number">1ll</span> * res2 % MOD + <span class="hljs-number">3</span> * <span class="hljs-number">1ll</span> * res1 % MOD + <span class="hljs-number">5</span> * <span class="hljs-number">1ll</span> * res0 % MOD) % MOD + MOD) % MOD);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 528「LibreOJ β Round</title>
    <link href="/2020/08/30/LOJ_528%E3%80%8CLibreOJ_%CE%B2_Round_#4%E3%80%8D%E6%B1%82%E5%92%8C/"/>
    <url>/2020/08/30/LOJ_528%E3%80%8CLibreOJ_%CE%B2_Round_#4%E3%80%8D%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>##题目 <span class="math display">\[\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{m}\mu ^2(\gcd (i,j))\bmod 998244353\]</span><br /><span id="more"></span> ##题解 以下默认<span class="math inline">\(n\leq m\)</span> <span class="math display">\[\begin{equation}\begin{aligned}&amp;\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{m}\mu ^2(\gcd (i,j))\\&amp;=\sum\limits-{d=1}^{n}\mu ^2(d)\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{m}[\gcd (i,j)=d]\\&amp;=\sum\limits-{d=1}^{n}\mu ^2(d)\sum\limits-{d\mid t} \mu (\frac{t}{d})\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor \\&amp;=\sum\limits-{t=1}^{n}\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor\sum\limits-{d\mid t}\mu ^2(d)\mu (\frac{t}{d})\end{aligned}\end{equation}\]</span></p><p>关于第二个等号,用的是莫比乌斯反演的一个结论。<br />如果<span class="math inline">\(f(d)=\sum\limits-{d\mid t}g(t)\)</span><br />那么<span class="math inline">\(g(d)=\sum\limits-{d\mid t}\mu (\frac{t}{d})f(t)\)</span></p><p>这里不妨把<span class="math inline">\(f(t)\)</span>看作<span class="math inline">\(\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{m}[t\mid \gcd (i,j)]\)</span><br />而<span class="math inline">\(g(d)=\sum\limits-{i=1}^{n}\sum\limits-{j=1}^{m}[d=\gcd (i,j)]\)</span><br />不难发现<span class="math inline">\(f(t)=\sum\limits-{t\mid d}g(d)\)</span><br />大家都知道<span class="math inline">\(f(t)=\left\lfloor\frac{n}{t}\right\rfloor\left\lfloor\frac{m}{t}\right\rfloor\)</span><br />所以第二个等号即得证。</p><p>交换一下求和符号，即得到了<span class="math display">\[\sum\limits-{t=1}^{n}\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor\sum\limits-{d\mid t}\mu ^2(d)\mu (\frac{t}{d})\]</span></p><p>发现前面可以分块，所以只用关心怎么求<span class="math inline">\(\sum\limits-{d\mid t}\mu ^2(d)\mu (\frac{t}{d})\)</span><br />令<span class="math inline">\(f(t)=\sum\limits-{d\mid t}\mu ^2(d)\mu (\frac{t}{d})\)</span><br /><span class="math inline">\(f\)</span>显然是积性函数，根据积性函数的性质，发现 1.<span class="math inline">\(f(p)=0\)</span><br />2.<span class="math inline">\(f(p^2)=-1\)</span><br />3.<span class="math inline">\(f(p^k)=0\)</span>,<span class="math inline">\(p\geq 3\)</span></p><p>其中 p 代表一个素数，只用带回定义式就可以得出。<br />再结合一下莫比乌斯函数的定义， 可以得到 <span class="math display">\[\begin{equation}    f(x)=   \begin{cases}   \mu (\sqrt{x})&amp;\mbox{if $\sqrt{x}\in \mathbb{N}$}\\   0\,&amp;\mbox{overwise}   \end{cases}\end{equation}\]</span></p><p>最后， <span class="math display">\[\begin{equation}\begin{aligned}&amp;\sum\limits-{t=1}^{n}\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor\sum\limits-{d\mid t}\mu ^2(d)\mu (\frac{t}{d})\\&amp;=\sum\limits-{t=1}^{n}\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor f(t)\\&amp;=\sum\limits-{t=1}^{n}\left\lfloor\frac{m}{t}\right\rfloor \left\lfloor\frac{n}{t}\right\rfloor \mu (\sqrt{t})[\sqrt{t} \in \mathbb{N}]\\\end{aligned}\end{equation}\]</span> 数论分块即可，时间复杂度<span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span></p><p>##代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<br>ll n, m;<br><span class="hljs-keyword">bool</span> p[maxn + <span class="hljs-number">5</span>];<br><span class="hljs-keyword">int</span> np[maxn + <span class="hljs-number">5</span>], ps;<br><span class="hljs-keyword">int</span> mu[maxn + <span class="hljs-number">5</span>];<br><span class="hljs-keyword">void</span> make-<span class="hljs-built_in">prime</span>(<span class="hljs-keyword">int</span> tn) &#123;<br>    p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= tn; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!p[i]) &#123;<br>            mu[i] = <span class="hljs-number">-1</span>;<br>            np[++ps] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-number">1ll</span> * i * np[j] &lt;= tn; j++) &#123;<br>            p[i * np[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i % np[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            mu[i * np[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tn; i++) mu[i] = (mu[i] + mu[i - <span class="hljs-number">1</span>] + mod) % mod;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll tn, ll tm)</span> </span>&#123;<br>    ll s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (tn &gt; tm)<br>        <span class="hljs-built_in">swap</span>(tn, tm);<br>    <span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r, sql, sqr; l &lt;= tn; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = <span class="hljs-built_in">min</span>(tn / (tn / l), tm / (tm / l));<br>        sql = (<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">sqrt</span>((l - <span class="hljs-number">1</span>) * <span class="hljs-number">1.0</span>));<br>        sqr = (<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">sqrt</span>(r * <span class="hljs-number">1.0</span>));<br>        s = (s + (tn / l) % mod * ((tm / l) % mod) % mod * (mu[sqr] - mu[sql] + mod) % mod) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);<br>    make-<span class="hljs-built_in">prime</span>((<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">max</span>(n, m) * <span class="hljs-number">1.0</span>)));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">solve</span>(n, m));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫比乌斯反演</tag>
      
      <tag>数论分块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫比乌斯反演常用结论</title>
    <link href="/2020/08/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%B8%B8%E7%94%A8%E7%BB%93%E8%AE%BA/"/>
    <url>/2020/08/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%B8%B8%E7%94%A8%E7%BB%93%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>内容主要来自<a href="https://oi-wiki.org/math/mobius/">oi-wiki</a><br /><span id="more"></span> ##前置知识 <span class="math display">\[\forall a,b,c\in\mathbb{Z},\left\lfloor\frac{a}{bc}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor\]</span><br />数论分块的过程大概如下：考虑含有 <span class="math inline">\(\left\lfloor\frac{n}{i}\right\rfloor\)</span> 的求和式子（ <span class="math inline">\(n\)</span> 为常数）</p><p>对于任意一个 <span class="math inline">\(i(i\leq n)\)</span> ，我们需要找到一个最大的 <span class="math inline">\(j(i\leq j\leq n)\)</span> ，使得 <span class="math inline">\(\left\lfloor\frac{n}{i}\right\rfloor = \left\lfloor\frac{n}{j}\right\rfloor\)</span> .</p><p>此时 <span class="math inline">\(j=\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor\)</span> .</p><p>显然 <span class="math inline">\(j\leq n\)</span> ，考虑证明 <span class="math inline">\(j\geq i\)</span> ：</p><p><span class="math display">\[\begin{aligned}&amp;\left\lfloor\frac{n}{i}\right\rfloor \leq \frac{n}{i}\\\implies&amp;\left\lfloor\frac{n}{ \left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor\geq \left\lfloor\frac{n}{ \frac{n}{i} }\right\rfloor= \left\lfloor i \right\rfloor=i \\\implies&amp;i\leq \left\lfloor\frac{n}{ \left\lfloor\frac{n}{i}\right\rfloor }\right\rfloor=j\\&amp;&amp;\square\end{aligned}\]</span></p><p>不妨设 <span class="math inline">\(k=\left\lfloor\frac{n}{i}\right\rfloor\)</span> ，考虑证明当 <span class="math inline">\(\left\lfloor\frac{n}{j}\right\rfloor=k\)</span> 时， <span class="math inline">\(j\)</span> 的最大值为 <span class="math inline">\(\left\lfloor\frac{n}{k}\right\rfloor\)</span> ：</p><p><span class="math display">\[\left\lfloor\frac{n}{j}\right\rfloor=k\iffk\leq\frac{n}{j}&lt;k+1\iff\frac{1}{k+1}&lt;\frac{j}{n}\leq\frac{1}{k}\iff\frac{n}{k+1}&lt;j\leq\frac{n}{k}\]</span></p><p>又因为 <span class="math inline">\(j\)</span> 为整数 所以 <span class="math inline">\(j-{max}=\left\lfloor\frac{n}{k}\right\rfloor\)</span></p><p>利用上述结论，我们每次以 <span class="math inline">\([i,j]\)</span> 为一块，分块求和即可</p><h2 id="积性函数">积性函数</h2><h3 id="定义">定义</h3><p>若函数 <span class="math inline">\(f(n)\)</span> 满足 <span class="math inline">\(f(1)=1\)</span> 且 <span class="math inline">\(\forall x,y \in \mathbb{N}-{+},\gcd(x,y)=1\)</span> 都有 <span class="math inline">\(f(xy)=f(x)f(y)\)</span> ，则 <span class="math inline">\(f(n)\)</span> 为积性函数。</p><p>若函数 <span class="math inline">\(f(n)\)</span> 满足 <span class="math inline">\(f(1)=1\)</span> 且 <span class="math inline">\(\forall x,y \in \mathbb{N}-{+}\)</span> 都有 <span class="math inline">\(f(xy)=f(x)f(y)\)</span> ，则 <span class="math inline">\(f(n)\)</span> 为完全积性函数。</p><h3 id="性质">性质</h3><p>若 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 均为积性函数，则以下函数也为积性函数：</p><p><span class="math display">\[\begin{aligned}h(x)&amp;=f(x^p)\\h(x)&amp;=f^p(x)\\h(x)&amp;=f(x)g(x)\\h(x)&amp;=\sum-{d\mid x}f(d)g(\frac{x}{d})\end{aligned}\]</span></p><p>设 <span class="math inline">\(x=\prod p-i^{k-i}\)</span></p><p>若 <span class="math inline">\(F(x)\)</span> 为积性函数，则有 <span class="math inline">\(F(x)=\prod F(p-i^{k-i})\)</span> 。</p><p>若 <span class="math inline">\(F(x)\)</span> 为完全积性函数，则有 <span class="math inline">\(F(X)=\prod F(p-i)^{k-i}\)</span> 。 ###常见数论函数 - 单位函数： <span class="math inline">\(\epsilon(n)=[n=1]\)</span> （完全积性） - 恒等函数： <span class="math inline">\(\operatorname{id}-k(n)=n^k\)</span> <span class="math inline">\(\operatorname{id}-{1}(n)\)</span> 通常简记作 <span class="math inline">\(\operatorname{id}(n)\)</span> 。（完全积性） - 常数函数： <span class="math inline">\(1(n)=1\)</span> （完全积性） - 除数函数： <span class="math inline">\(\sigma-{k}(n)=\sum-{d\mid n}d^{k}\)</span> <span class="math inline">\(\sigma-{0}(n)\)</span> 通常简记作 <span class="math inline">\(\operatorname{d}(n)\)</span> 或 <span class="math inline">\(\tau(n)\)</span> ， <span class="math inline">\(\sigma-{1}(n)\)</span> 通常简记作 <span class="math inline">\(\sigma(n)\)</span> 。 - 欧拉函数： <span class="math inline">\(\varphi(n)=\sum-{i=1}^n [\gcd(i,n)=1]\)</span> - 莫比乌斯函数： <span class="math inline">\(\mu(n) = \begin{cases}1 &amp; n=1 \\ 0 &amp; \exists d&gt;1:d^{2} \mid n \\ (-1)^{\omega(n)} &amp; otherwise\end{cases}\)</span> ，其中 <span class="math inline">\(\omega(n)\)</span> 表示 <span class="math inline">\(n\)</span> 的本质不同质因子个数，它也是一个积性函数。</p><h2 id="dirichlet-卷积">Dirichlet 卷积</h2><h3 id="定义-1">定义</h3><p>定义两个数论函数 <span class="math inline">\(f,g\)</span> 的 Dirichlet 卷积为</p><p><span class="math display">\[(f\ast g)(n)=\sum-{d\mid n}f(d)g(\frac{n}{d})\]</span></p><h3 id="性质-1">性质</h3><p>Dirichlet 卷积满足以下运算规律：</p><ul><li>交换律 <span class="math inline">\((f * g=g * f)\)</span> ；</li><li>结合律 <span class="math inline">\((f * g) * h=f * (g * h)\)</span> ；</li><li>分配律 <span class="math inline">\(f * (g+h)=f * g+f * h\)</span> ；</li><li><span class="math inline">\(f*\varepsilon=f\)</span> ，其中 <span class="math inline">\(\varepsilon\)</span> 为 Dirichlet 卷积的单位元（任何函数卷 <span class="math inline">\(\varepsilon\)</span> 都为其本身）</li></ul><h3 id="例子">例子</h3><p><span class="math display">\[\begin{aligned}\varepsilon=\mu \ast 1&amp;\iff\varepsilon(n)=\sum-{d\mid n}\mu(d)\\d=1 \ast 1&amp;\iff d(n)=\sum-{d\mid n}1\\\sigma=\operatorname{id} \ast 1&amp;\iff\sigma(n)=\sum-{d\mid n}d\\\varphi=\mu \ast \operatorname{id}&amp;\iff\varphi(n)=\sum-{d\mid n}d\cdot\mu(\frac{n}{d})\end{aligned}\]</span></p><h3 id="莫比乌斯函数">莫比乌斯函数</h3><p>莫比乌斯函数不但是积性函数，还有如下性质：</p><p><span class="math display">\[\sum-{d\mid n}\mu(d)=\begin{cases}1&amp;n=1\\0&amp;n\neq 1\\\end{cases}\]</span></p><p>即 <span class="math inline">\(\sum-{d\mid n}\mu(d)=\varepsilon(n)\)</span> ， <span class="math inline">\(\mu * 1 =\varepsilon\)</span></p><h2 id="莫比乌斯反演">莫比乌斯反演</h2><h3 id="公式">公式</h3><p>设 <span class="math inline">\(f(n),g(n)\)</span> 为两个数论函数。</p><p>如果有 <span class="math inline">\(f(n)=\sum-{d\mid n}g(d)\)</span> ，那么有 <span class="math inline">\(g(n)=\sum-{d\mid n}\mu(d)f(\frac{n}{d})\)</span> 。</p><p>如果有 <span class="math inline">\(f(n)=\sum-{n|d}g(d)\)</span> ，那么有 <span class="math inline">\(g(n)=\sum-{n|d}\mu(\frac{d}{n})f(d)\)</span> 。</p><h3 id="证明">证明</h3><p>方法一：对原式做数论变换。</p><p><span class="math display">\[\sum-{d\mid n}\mu(d)f(\frac{n}{d})=\sum-{d\mid n}\mu(d)\sum-{k\mid \frac{n}{d}}g(k)=\sum-{k\mid n}g(k)\sum-{d\mid \frac{n}{k}}\mu(d)=g(n)\]</span></p><p>用 <span class="math inline">\(\displaystyle\sum-{d\mid n}g(d)\)</span> 来替换 <span class="math inline">\(f(\dfrac{n}{d})\)</span> ，再变换求和顺序。最后一步变换的依据： <span class="math inline">\(\displaystyle\sum-{d\mid n}\mu(d)=[n=1]\)</span> ，因此在 <span class="math inline">\(\dfrac{n}{k}=1\)</span> 时第二个和式的值才为 <span class="math inline">\(1\)</span> 。此时 <span class="math inline">\(n=k\)</span> ，故原式等价于 <span class="math inline">\(\displaystyle\sum-{k\mid n}[n=k]\cdot g(k)=g(n)\)</span></p><p>方法二：运用卷积。</p><p>原问题为：已知 <span class="math inline">\(f=g\ast1\)</span> ，证明 <span class="math inline">\(g=f\ast\mu\)</span></p><p>易知如下转化： <span class="math inline">\(f\ast\mu=g*1*\mu\implies f\ast\mu=g\)</span> （其中 <span class="math inline">\(1\ast\mu=\varepsilon\)</span> ）。</p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6672 你的生命已如风中残烛</title>
    <link href="/2020/08/30/P6672_%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B/"/>
    <url>/2020/08/30/P6672_%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B/</url>
    
    <content type="html"><![CDATA[<p>我的生命已如风中残烛...</p><p>思维好题 问题等价于<span class="math inline">\(m\)</span>个数和为0, 求所有前缀和都不小于零的排列的个数.<br />将所有权值 <span class="math inline">\(-1\)</span> 就可以了.<br />可以在最后添加一个<span class="math inline">\(-1\)</span>, 这样就是求前<span class="math inline">\(m\)</span>个大于, 把排列连成环, 这样就有一个很好的性质, 每个圆排列只有一种断开的方法.<br />这个画个图比较好理解, 假设当前已经是合法的方案, 左右移动一下再断开都是不合法的.<br />圆排列的排列数是<span class="math inline">\(m!\)</span>, 因为<span class="math inline">\(-1\)</span>要钦定一个, 所以除以<span class="math inline">\(-1\)</span>的个数.<br />最后答案就是<span class="math inline">\(\frac{m!}{m+1-n}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">int</span> n, m, x;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), m += x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-keyword">if</span> (i != m - n + <span class="hljs-number">1</span>) res = res * <span class="hljs-number">1ll</span> * i % MOD;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P6327 区间加区间sin和</title>
    <link href="/2020/08/30/P6327_%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/"/>
    <url>/2020/08/30/P6327_%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>luogu: <a href="https://www.luogu.com.cn/problem/P6327">P6372 区间加区间sin和</a> 线段树上只维护<span class="math inline">\(sin\)</span>和是很难更新的，想到和角公式，维护<span class="math inline">\(cos\)</span>的和。 <span class="math display">\[sin(x+y)=sin(x)*cos(y)+cos(x)*sin(y)\]</span> <span class="math display">\[cos(x+y)=cos(x)*cos(y)-sin(x)*sin(y)\]</span> <span id="more"></span> 这道题卡常，所以要尽量减少<span class="math inline">\(sin\)</span>和<span class="math inline">\(cos\)</span>的运算。<br />注意一下懒标记用<span class="math inline">\(long long\)</span>存就可以了。<br />时间复杂度<span class="math inline">\(O((n+m)log n)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson (p &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson ((p &lt;&lt; 1) | 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tag[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-keyword">double</span> sinx, cosx, b[N], a[N], Sin[N &lt;&lt; <span class="hljs-number">2</span>], Cos[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>    w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>    ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>    Sin[p] = a[l];<br>        Cos[p] = b[l];<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">build</span>(l, mid, lson);<br>    <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, rson);<br>    Sin[p] = Sin[rson] + Sin[lson];<br>    Cos[p] = Cos[rson] + Cos[lson];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> v, <span class="hljs-keyword">double</span> sv, <span class="hljs-keyword">double</span> cv)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> Sumsin = Sin[p];<br>    Sin[p] = Sin[p] * cv + Cos[p] * sv;<br>    Cos[p] = Cos[p] * cv - Sumsin * sv;<br>    tag[p] += v;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tag[p] != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">add</span>(lson, tag[p], <span class="hljs-built_in">sin</span>(tag[p]), <span class="hljs-built_in">cos</span>(tag[p]));<br><span class="hljs-built_in">add</span>(rson, tag[p], <span class="hljs-built_in">sin</span>(tag[p]), <span class="hljs-built_in">cos</span>(tag[p]));<br>    tag[p] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt; R || r &lt; L) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(l &gt;= L &amp;&amp; R &gt;= r) &#123;<br>    <span class="hljs-built_in">add</span>(p, v, sinx, cosx);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-built_in">modify</span>(lson, l, mid, L, R, v);<br>    <span class="hljs-built_in">modify</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R, v);<br>    Sin[p] = Sin[lson] + Sin[rson];<br>    Cos[p] = Cos[lson] + Cos[rson];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; R || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">if</span>(l &gt;= L &amp;&amp; R &gt;= r) <span class="hljs-keyword">return</span>  Sin[p];<br><span class="hljs-built_in">pushdown</span>(p);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lson, l, mid, L, R) + <span class="hljs-built_in">query</span>(rson, mid + <span class="hljs-number">1</span>, r, L, R); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">read</span>();<br>        a[i] = <span class="hljs-built_in">sin</span>(x), b[i] = <span class="hljs-built_in">cos</span>(x);<br>&#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>);<br>    m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>    <span class="hljs-keyword">int</span> opt, l, r, v;<br>    opt = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>) &#123;<br>    l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>(); v = <span class="hljs-built_in">read</span>();<br>    sinx=<span class="hljs-built_in">sin</span>(v),cosx=<span class="hljs-built_in">cos</span>(v);<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(v));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>(); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf\n&quot;</span>,<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));<br>    &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>和角公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ 2143「SHOI2017」组合数问题</title>
    <link href="/2020/08/29/LOJ_2143%E3%80%8CSHOI2017%E3%80%8D%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/29/LOJ_2143%E3%80%8CSHOI2017%E3%80%8D%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://loj.ac/problem/2143">LOJ 2143</a></p><p>好像是循环矩阵一样的东西。<br />今天早上才做过一道用矩阵的[题目][https://www.luogu.com.cn/problem/P2886]</p><p>按照题目去算显然是会超时的， 可以按<span class="math inline">\(\bmod k\)</span>的余数分类。<br /><span id="more"></span> 设<span class="math inline">\(f[i][j]\)</span>表示从<span class="math inline">\(i\)</span>个数中选若干个数，余数为<span class="math inline">\(j\)</span>的方案数。<br />转移是<span class="math inline">\(f[i][j]=f[i][j]+f[x][j-1]*f[y][j-2]\)</span>,<span class="math inline">\(((j-1+j-2)\bmod k=j)\)</span>.<br />因为只和<span class="math inline">\(j\)</span>有关， 所以可以用矩阵快速幂优化。<br />注意<span class="math inline">\(k\)</span>可能等于1，初始化的时候注意一下。<br />时间复杂度<span class="math inline">\(\mathcal{O}(k^{2\log {nk}})\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n, k, r, p;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Martix</span> &#123;</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">55</span>];<br>Martix <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> Martix&amp; x) <span class="hljs-keyword">const</span> &#123;<br>Martix tmp;<br><span class="hljs-built_in">memset</span>(tmp.a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> tmp.a);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>                tmp.a[(i + j) % k] = (tmp.a[(i + j) % k] + a[i] * <span class="hljs-number">1ll</span> * x.a[j] % p) % p;<br>&#125;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125; ans;<br><span class="hljs-function">Martix <span class="hljs-title">fpow</span><span class="hljs-params">(Martix a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>&#123;<br>Martix ans;<br><span class="hljs-built_in">memset</span>(ans.a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> ans.a);<br>    ans.a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = a * ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;p, &amp;k, &amp;r);<br>    ans.a[<span class="hljs-number">1</span> % k]++, ans.a[<span class="hljs-number">0</span>]++;<br>    ans = <span class="hljs-built_in">fpow</span>(ans, n * <span class="hljs-number">1ll</span> * k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans.a[r]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵乘法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Old Driver Tree「珂朵莉树」</title>
    <link href="/2020/08/29/Old_Driver_Tree%E3%80%8C%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%E3%80%8D/"/>
    <url>/2020/08/29/Old_Driver_Tree%E3%80%8C%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感觉这东西也不算是数据结构... 模板题见<a href="https://codeforces.com/contest/896/problem/C">CF896C</a> 随机数据的复杂度证明见<a href="https://zhuanlan.zhihu.com/p/102786071">知乎专栏</a></p></blockquote><p><del>虽然构造数据只能拿来骗分</del>，有时候作为辅助工具是比较方便的。<br />只用讲基本的操作。<br /><span id="more"></span> 大概是把相同的元素合并成一个块以减少时间复杂度。</p><h2 id="块信息">块信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>-<span class="hljs-title">t</span> &#123;</span><br>    <span class="hljs-keyword">int</span> l, r;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> v;<br>    Node-<span class="hljs-built_in">t</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;il, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ir, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;iv) : <span class="hljs-built_in">l</span>(il), <span class="hljs-built_in">r</span>(ir), <span class="hljs-built_in">v</span>(iv) &#123;&#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node-t &amp;o) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> l &lt; o.l; &#125;<br>&#125;;<br>```  <br><span class="hljs-keyword">mutable</span> 的意思是“可变的”，让我们可以在后面的操作中修改 v 的值。在 C++ 中，<span class="hljs-keyword">mutable</span> 是为了突破 <span class="hljs-keyword">const</span> 的限制而设置的。被 <span class="hljs-keyword">mutable</span> 修饰的变量（<span class="hljs-keyword">mutable</span> 只能用于修饰类中的非静态数据成员），将永远处于可变的状态，即使在一个 <span class="hljs-keyword">const</span> 函数中。<br><br>#<span class="hljs-meta"># split函数</span><br>```cpp<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IT set<span class="hljs-meta-string">&lt;node&gt;</span>::iterator</span><br><span class="hljs-function">IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>    IT it = s.lower-<span class="hljs-built_in">bound</span>(<span class="hljs-built_in">node</span>(pos));<br>    <span class="hljs-keyword">if</span> (it-&gt;l == pos &amp;&amp; it != s.<span class="hljs-built_in">end</span>())<br>        <span class="hljs-keyword">return</span> it;<br>    --it;<br>    <span class="hljs-keyword">int</span> v = it-&gt;v, l = it-&gt;l, r = it-&gt;r;<br>    s.<span class="hljs-built_in">erase</span>(it);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l, pos - <span class="hljs-number">1</span>, v));<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(pos, r, v)).first;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 set 自带的 lower-bound 和 upper-bound 的时间复杂度为<span class="math inline">\(\mathcal{O}(log n)\)</span>。 但使用 algorithm 库中的 lower-bound 和 upper-bound 函数对 set 中的元素进行查询，时间复杂度为 <span class="math inline">\(\mathcal{O}(n)\)</span>。似乎是 set 不支持随机访问的原因。<br />s.insert(node(pos, r, v)).first 返回的是插入元素的地址。</p><h2 id="assign函数">assign函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    IT itr = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(l);<br>    s.<span class="hljs-built_in">erase</span>(itl, itr);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l, r, v));<br>&#125;<br></code></pre></td></tr></table></figure><p>作用是推平一段区间，也是<span class="math inline">\(ODT\)</span>时间复杂度的保证。<br />注意如果先 split 左端点再 split 右端点就会 RE，原因是 l 和 r 在一个 node 上时，split(r) 会 erase 这个 node 再重新插入，导致 split(l) 的迭代器失效。</p><p>没被卡的习题比较少... - <a href="https://loj.ac/problem/2037">「SHOI2015」脑洞治疗仪</a> - <a href="https://www.luogu.com.cn/problem/P2787">「Luogu 2787」理理思维</a> - <a href="https://www.luogu.com.cn/problem/P4979">「Luogu 4979」矿洞：坍塌</a></p><p>放一下正经的题<br />- <a href="https://loj.ac/problem/2055">LOJ 2005 「TJOI / HEOI2016」排序</a> - <a href="https://loj.ac/problem/2958">LOJ 2958 「COCI 2009.10」ALADIN</a></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>珂朵莉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>块状数组</title>
    <link href="/2020/08/29/%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2020/08/29/%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>鸽了好多天，今天终于开始写了233...</p></blockquote><h2 id="分块思想">分块思想</h2><p>实际上分块并不能算一种数据结构？<br />分块的基本思想是，将原来的数据经过适当的划分(分成一个个块的样子)。<br />每次修改和询问时，都把一个块内元素当作整体处理，而边角直接暴力。<br />莫队就是基于分块思想实现的。</p><span id="more"></span><p>分块的复杂度主要取决于块长，根据均值不等式，块长为<span class="math inline">\(\mathcal{O}(\sqrt n)\)</span>时最优。当然不能一概而论。详细分析可以阅读<span class="math inline">\(2017\)</span>年国家集训队论文中徐明宽的《非常规大小分块算法初探》。 所以分块的时间复杂度一般都是带根号的...</p><h2 id="分块入门">分块入门</h2><h3 id="基本操作">基本操作</h3><p>块大小： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">size = <span class="hljs-built_in">sqrt</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>```  <br>块个数:<br>```cpp<br>block = (n - <span class="hljs-number">1</span>) / size + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure> 预处理每个块的区间和每个元素所在块编号：<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= block; i++) &#123;<br>    L[i] = R[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    R[i] = i * blo;<br>&#125;<br>R[block] = n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= block; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = L[i]; j &lt;= R[i]; j++) bel[j] = i;<br>&#125;<br>```  <br>### 入门例题<br>先看看两道入门题...  <br>#### [LOJ <span class="hljs-number">6280</span> 入门分块<span class="hljs-number">4</span>](https:<span class="hljs-comment">//loj.ac/problem/6280)  </span><br>若$opt=<span class="hljs-number">0</span>$，表示将位于$[l,r]$的之间的数字都加$c$。<br>若$opt=<span class="hljs-number">1</span>$，表示询问位于$[l,r]$的所有数字的和$\<span class="hljs-built_in">bmod</span> (c+<span class="hljs-number">1</span>)$。  <br><br>这道题看起来是线段树的模板题，~~实际上就是~~。  <br>做法不难想到，分好块以后，给每个块记录一个$tag$和$sum$。  <br>$tag$表示这个块的所有元素都要加多少，相当于线段树里面的懒标记。 <br>每次操作，$[l,r]$中完整块都可以$\mathcal&#123;O&#125;(<span class="hljs-number">1</span>)$做，而边角的元素一个一个去加或者统计就可以了。  <br>因为只有$\mathcal&#123;O&#125;(\sqrt n)$个块，边角的元素个数也是$\mathcal&#123;O&#125;(\sqrt n)$。  <br>所以总的时间复杂度是$\mathcal&#123;O&#125;(\sqrt n)$。  <br><br>为了方便理解，放一下修改的代码。  <br>```cpp<br><span class="hljs-keyword">void</span> <span class="hljs-built_in">upd</span>(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v) &#123;<br>    <span class="hljs-keyword">if</span> (bel[l] == bel[r]) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++) a[i] += v, sum[bel[i]] += v;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= R[bel[l]]; i++) a[i] += v, sum[bel[i]] += v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L[bel[r]]; i &lt;= r; i++) a[i] += v, sum[bel[i]] += v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bel[l] + <span class="hljs-number">1</span>; i &lt; bel[r]; i++) tag[i] += v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="loj-6280-入门分块6"><a href="https://loj.ac/problem/6282">LOJ 6280 入门分块6</a></h4><p>给出一个长为<span class="math inline">\(n\)</span>的数列，以及<span class="math inline">\(n\)</span>个操作，操作涉及单点插入，单点询问，数据随机生成。<br />若<span class="math inline">\(opt=0\)</span>，表示在第<span class="math inline">\(l\)</span>个数字前插入数字 <span class="math inline">\(r\)</span>（ 忽略）。 若<span class="math inline">\(opt=1\)</span>，表示询问<span class="math inline">\(a-r\)</span>的值。 先说数据随机怎么做。<br />把块分好之后，每个块里面都可以存一个动态数组。<br />每次插入，只需要找到<span class="math inline">\(l\)</span>所在的块，在<span class="math inline">\(vector\)</span>里面直接插入新的数就可以了。时间复杂度<span class="math inline">\(\mathcal{O}(\sqrt n)\)</span>。<br />查询，也只需要找到位置输出就可以了。</p><p>构造数据？<br />可能会有<del>毒瘤</del>数据将所有的插入都差到一个块里面，那么上面的做法就会被卡飞...<br />那怎么办呢？<br />既然有一个块太大了，那把它变小就可以了...<br />重构所有块有两种时机:<br />1. 操作的时候发现某些块太大，就直接重构后操作。<br />2. 隔一段时间进行重构，比如<span class="math inline">\(\mathcal{O}(\sqrt n)\)</span>次，每次重构是<span class="math inline">\(\mathcal{O}(n)\)</span>的，总时间复杂度是<span class="math inline">\(\mathcal{O}(n\sqrt n)\)</span>。</p><p><a href="https://loj.ac/problem/6285">LOJ6285 入门分块9</a>也是道很好的的题。<del>值得做做</del></p><h2 id="一些例题">一些例题</h2><h3 id="p2801-教主的魔法"><a href="https://www.luogu.com.cn/problem/P2801">P2801 教主的魔法</a></h3><p>（1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。 （2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。</p><p>这次分块的时候需要把每个块的元素存下来。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">size = <span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    block[tot][++block[tot][<span class="hljs-number">0</span>]] = a[i];<br>    <span class="hljs-keyword">if</span> (block[tot][<span class="hljs-number">0</span>] == size)<br>        tot++;<br>&#125;<br></code></pre></td></tr></table></figure> 对每个块进行排序。<br />第二个操作可以对每个有序的块<span class="math inline">\(lower\-bound\)</span>一下就可以了。<br />怎么修改？<br />整块打上懒标记就可以了。<br />边角的每个元素，都去找到对应块中的元素，然后直接加就可以了。<br />时间复杂度显然是<span class="math inline">\(\mathcal{O}(n\sqrt n log n)\)</span>。</p><h3 id="p5048-ynoi2019模拟赛yuno-loves-sqrt-technology-iii"><a href="https://www.luogu.com.cn/problem/P5048">P5048 [Ynoi2019模拟赛]Yuno loves sqrt technology III</a></h3><p>给你一个长为 <span class="math inline">\(n\)</span>的序列 <span class="math inline">\(a\)</span>，<span class="math inline">\(m\)</span> 次询问，每次查询一个区间的众数的出现次数，强制在线。</p><p>发现值域比较小，先把所有元素放入按权值放入桶中，并且记录下在桶里面的下标。<br />之后考虑整块的怎么做。<br />可以暴力<span class="math inline">\(dp\)</span>，设<span class="math inline">\(f-{l,r}\)</span>表示第<span class="math inline">\(l\)</span>块到<span class="math inline">\(r\)</span>块的众数出现次数。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= block; i++) &#123;<br>    <span class="hljs-built_in">memset</span>(tot, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> tot);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = L[i]; j &lt;= R[i]; j++) bel[j] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i;j &lt;= block; j++) &#123;<br>        mx[i][j] = mx[i][j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = L[j]; k &lt;= R[j]; k++) mx[i][j] = <span class="hljs-built_in">max</span>(mx[i][j], ++tot[a[k]]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 之后每次查询，只用考虑边角元素的贡献。<br />记现在已经可能的答案是<span class="math inline">\(ans\)</span>，只用检验会不会有数出现次数是<span class="math inline">\(ans+1\)</span>。<br />对于左边的元素，假设它在桶中的位置是<span class="math inline">\(pos\)</span>，如果<span class="math inline">\(v[a][pos+ans]\leq r\)</span>，说明它是可以成为目前众数的，所以<span class="math inline">\(ans=ans+1\)</span>。 右边同理。<br />因为答案最多加<span class="math inline">\(\mathcal{O}(\sqrt n)\)</span>次，所以复杂度是<span class="math inline">\(\mathcal{O}(m\sqrt n)\)</span>。</p><h3 id="p4117-ynoi2018五彩斑斓的世界"><a href="https://www.luogu.com.cn/problem/P4117">P4117 [Ynoi2018]五彩斑斓的世界</a></h3><p>最后一道题了...</p><ol type="1"><li>把区间<span class="math inline">\([l,r]\)</span>中大于<span class="math inline">\(x\)</span>的数减去<span class="math inline">\(x\)</span>。</li><li>查询区间<span class="math inline">\([l,r]\)</span>中<span class="math inline">\(x\)</span>的出现次数。</li></ol><p>看了<a href="http://olddrivertree.blog.uoj.ac/blog/4715">出题人的题解</a>才会做...<br />分块，可以发现每块的最大值总是不增的。<br />1. 若 <span class="math inline">\(2x\geq k\)</span>，令大于 <span class="math inline">\(x\)</span> 的数减去 <span class="math inline">\(x\)</span> 之后，就没有比 <span class="math inline">\(x\)</span> 大的数了，则 <span class="math inline">\(k\)</span> 在操作后至少减少 <span class="math inline">\(k-x\)</span>。<br />2. 若 <span class="math inline">\(2x\lt k\)</span>，则我们令小于等于 <span class="math inline">\(x\)</span> 的数加上 <span class="math inline">\(x\)</span>，就没有比 <span class="math inline">\(x\)</span> 小的数了，然后。打全局减的标记，则 <span class="math inline">\(k\)</span> 在操作后至少减少 <span class="math inline">\(x\)</span>。</p><p>使用并查集把相同的值并起来。那么修改的时候，只需要把修改前值对应的并查集的根，连到修改后的值的并查集的根上即可。<br />同时我们需要记录每个数的出现次数，修改的时候直接加过去就好了。</p><p>我们每次用来连接的都是并查集的根，而一个根连到另一个根之后，这个值本身就消失了。而且我们在这里并不用这个并查集查询。因此这里的并查集并不会进行路径压缩，是 <span class="math inline">\(\mathcal{O}(1)\)</span> 的。<br />如果是查询全局某个数的出现位置，那么直接<span class="math inline">\(\mathcal{O}(1)\)</span>查询即可。 我们考虑查询所有位置的实际值。这里就需要用到并查集的找父亲的操作了。由于这里访问了并查集的所有位置，并进行了路径压缩，所以总复杂度是<span class="math inline">\(\mathcal{O}(n)\)</span>的。</p><p>所以对一个整块的修改查询都是<span class="math inline">\(\mathcal{O}(n\sqrt n)\)</span>的。 对于一个块的部分修改，我们先暴力把每个位置的实际值还原，然后对块进行重构即可。<span class="math inline">\(\mathcal{O}(\sqrt n)\)</span>。</p><p>如果所有数都开一个并查集的话，空间复杂度显然是不能接受的...<br />发现块与块之间的操作是独立的，所以可以把操作离线下来。<br />每个块都单独做完所有操作后统计答案。</p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>烷基计数</title>
    <link href="/2020/08/29/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0/"/>
    <url>/2020/08/29/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>其实很早就想学一下这类问题了,不过因为各种原因鸽到现在...<br />links:<br /><a href="https://loj.ac/problem/6185">普通版</a> <a href="https://loj.ac/problem/6269">加强版</a> <a href="https://loj.ac/problem/6538">加强版的加强版</a></p></blockquote><h2 id="普通版">普通版</h2><p>看大佬的博客学习了一下.<br />有一个很好懂的<span class="math inline">\(\mathcal{O}(n^3)\)</span>的<span class="math inline">\(dp\)</span>方法.<br /><span id="more"></span> 设<span class="math inline">\(f-i\)</span>表示大小为<span class="math inline">\(i\)</span>的无标号树的组成方式.<br />儿子的子树大小为<span class="math inline">\(i-1\)</span>,假设有三个儿子大小为<span class="math inline">\(a,b,c\)</span>,<span class="math inline">\(0\leq a\leq b\leq c\leq i-1\)</span>.<br />分类讨论一下转移就可以了.因为无标号,所以不能简单的乘法原理.<br />1. <span class="math inline">\(a=b=c\)</span>,<span class="math inline">\(f-i+=\binom{f-a+3-1}{3}\)</span><br />2. <span class="math inline">\(a=b\)</span>, <span class="math inline">\(f-i+=\binom{f-a+2-1}{2}\times f-c\)</span>,<span class="math inline">\(b=c\)</span>时也是同理.<br />3. <span class="math inline">\(a &lt; b &lt; c\)</span>, <span class="math inline">\(f-i+=f-a\times f-b \times f-c\)</span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, f[<span class="hljs-number">405</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = ans * <span class="hljs-number">1ll</span> * a % MOD;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">int</span> inv2 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, MOD - <span class="hljs-number">2</span>), inv6 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">6</span>, MOD - <span class="hljs-number">2</span>);<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> f, <span class="hljs-keyword">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> (f + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * f % MOD * inv2 % MOD;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (f + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (f + <span class="hljs-number">2</span>) % MOD * <span class="hljs-number">1ll</span> * f % MOD * inv6 % MOD;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n); f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt;= k; a++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = a; b &lt;= k; b++) &#123;<br>                <span class="hljs-keyword">int</span> c = k - a - b - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (c &lt; b || b &lt; a) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (a == b &amp;&amp; b == c) f[k] = (f[k] * <span class="hljs-number">1ll</span> + <span class="hljs-built_in">C</span>(f[a], <span class="hljs-number">3</span>)) % MOD;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == b) f[k] = (f[k] * <span class="hljs-number">1ll</span> + (<span class="hljs-built_in">C</span>(f[a], <span class="hljs-number">2</span>) % MOD * <span class="hljs-number">1ll</span> * f[c] % MOD)) % MOD;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == c) f[k] = (f[k] * <span class="hljs-number">1ll</span> + (<span class="hljs-built_in">C</span>(f[b], <span class="hljs-number">2</span>) % MOD * <span class="hljs-number">1ll</span> * f[a] % MOD)) % MOD;<br>                <span class="hljs-keyword">else</span> f[k] = (f[k] * <span class="hljs-number">1ll</span> + f[a] * <span class="hljs-number">1ll</span> * f[b] % MOD * f[c] % MOD) % MOD;<br>            &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="加强版">加强版</h2><p>因为<span class="math inline">\(n\leq 5000\)</span>,所以朴素的<span class="math inline">\(dp\)</span>是过不了的.<br />考虑一下怎么优化.<br />普通的<span class="math inline">\(dp\)</span>要去枚举所有子树的大小,那么有没有办法把大小一样的子树一起考虑,像树形<span class="math inline">\(dp\)</span>一样去计算贡献.<br />设<span class="math inline">\(f[s][i][j]\)</span>表示大小为<span class="math inline">\(i\)</span>的树,根节点度数为<span class="math inline">\(j\)</span>,儿子的子树大小不超过<span class="math inline">\(s\)</span>时的方案数.<br />考虑怎么转移, 假设大小为<span class="math inline">\(s\)</span>的子树有<span class="math inline">\(k\)</span>个.(<span class="math inline">\(k\times s&lt;i\)</span>且<span class="math inline">\(k\leq j\)</span>).<br />这<span class="math inline">\(k\)</span>个子树的形态的方案数是<span class="math inline">\(\binom{(\sum{f-{s-1,s,j}})+k-1}{k}\)</span>.<br />在乘上<span class="math inline">\(f-{s-1,i-s\times k,j-k}\)</span>就是答案了.<br />用背包的方式来<span class="math inline">\(dp\)</span>,可以省去第一维空间.</p><p><del>石锤我不会写背包</del></p><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5005</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>ll f[N][<span class="hljs-number">4</span>], n; <span class="hljs-comment">// 1 -&gt; 大小 2 -&gt; 度数</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">fpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = ans * a % MOD;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>ll inv2 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, MOD - <span class="hljs-number">2</span>), inv6 = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">6</span>, MOD - <span class="hljs-number">2</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> now % MOD;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> now * (now + <span class="hljs-number">1ll</span>) % MOD * inv2 % MOD;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> now * (now + <span class="hljs-number">1ll</span>) % MOD * (now + <span class="hljs-number">2ll</span>) % MOD * inv6 % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; ll now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">1</span>; s &lt;= n; s++) &#123; <span class="hljs-comment">// s -&gt; 子树大小限制</span><br>        now = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) now = (now + f[s][i]) % MOD;<br>        <span class="hljs-keyword">if</span> (n == s) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// cout &lt;&lt; now &lt;&lt; endl;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= j &amp;&amp; k * s &lt; i; k++) &#123;<br>                    f[i][j] = (f[i][j] + (f[i - s * k][j - k] * <span class="hljs-built_in">C</span>(now, k) % MOD)) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, now);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加强版的加强版">加强版的加强版</h3><p>...............<br />咕咕咕咕咕咕</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARC062F Painting Graphs with AtCoDeer</title>
    <link href="/2020/08/29/ARC062F_Painting_Graphs_with_AtCoDeer/"/>
    <url>/2020/08/29/ARC062F_Painting_Graphs_with_AtCoDeer/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>给定一张<span class="math inline">\(N\)</span>个点<span class="math inline">\(M\)</span>条边的无向图，每条边要染一个编号在<span class="math inline">\(1\)</span>到<span class="math inline">\(K\)</span>的颜色。<br />你可以对一张染色了的图进行若干次操作，每次操作形如，在图中选择一个简单环（即不经过相同点的环），并且将其颜色逆（顺）时针旋转一个单位。<br />两种染色方案被认为是本质相同的，当且仅当其中一种染色后的图经过若干次操作后可以变成另一种染色后的图。<br />问有多少本质不同的染色方案，输出对<span class="math inline">\(10^9+7\)</span>取模。 <img src="https://widsnoy.top/usr/uploads/2020/08/1491481430.png" alt="arc062f-1.png" /></p><span id="more"></span><h1 id="题解">题解</h1><p>首先考虑<span class="math inline">\(n\)</span>个点的简单环怎么做。<br />根据<span class="math inline">\(Burnside\)</span>引理，染色方案有<span class="math inline">\(\frac{1}{n}\sum\limits-{i=0}^{n-1}k^{(n,i)}\)</span>种。 那么可以将图的所有点双联通分量单独处理。<br /><span class="math inline">\(BCC\)</span>缩点后，边分为三种情况。1. 单边 2. 单环 3. 复合环。<br />单边就直接算就可以了。<br />单环之前考虑过了，其实复合环也很类似。<br /><img src="https://widsnoy.top/usr/uploads/2020/08/1048616197.png" alt="arc062f-2.png" /> 可以发现复合环是可以不改变其他边换掉其中两条边的。<br />所以不同的染色方案不同颜色的数量是不同的。<br />若每种颜色有<span class="math inline">\(p\)</span>个<span class="math inline">\(，p-1+p-2+...+p-k=m\)</span>的划分方法就是所有的染色方案。<br />用插板法就可解决，方案数是<span class="math inline">\(\binom{n+k-1}{k-1}\)</span>。<br />最后问题就解决了!时间复杂度是<span class="math inline">\(O(n+2* m)\)</span> 。</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">105</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> n, m, k, fac[N &lt;&lt; <span class="hljs-number">1</span>], ifac[N &lt;&lt; <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(; m; m &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span>(m &amp; <span class="hljs-number">1</span>) ans = ans * <span class="hljs-number">1ll</span> * a % MOD;<br>a = a * <span class="hljs-number">1ll</span> * a % MOD;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br><span class="hljs-keyword">int</span> nxt, v;<br>&#125;e[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> bccno[N], bcc-cnt,siz-e[N], siz-p[N], dfs-clock, low[N], pre[N], head[N], cnt, top;<br>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; stk[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;<br>e[++cnt] = (Edge)&#123;head[v], u&#125;, head[v] = cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    low[u] = pre[u] = ++dfs-clock;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;<br>    <span class="hljs-keyword">int</span> v = e[i].v;<br>    <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(!pre[v]) &#123;<br>    stk[++top] = make-<span class="hljs-built_in">pair</span>(u, v);<br>    <span class="hljs-built_in">dfs</span>(v, u);<br>    low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>    <span class="hljs-keyword">if</span>(low[v] &gt;= pre[u]) &#123;<br>    bcc-cnt++;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">523</span>) &#123;<br>                    <span class="hljs-keyword">int</span> x = stk[top].first, y = stk[top].second;<br>        top--;<br>        siz-e[bcc-cnt]++;<br>        <span class="hljs-keyword">if</span>(bccno[x] != bcc-cnt) &#123;bccno[x] = bcc-cnt; siz-p[bcc-cnt]++;&#125;<br>        <span class="hljs-keyword">if</span>(bccno[y] != bcc-cnt) &#123;bccno[y] = bcc-cnt; siz-p[bcc-cnt]++;&#125;<br>        <span class="hljs-keyword">if</span>(x == u &amp;&amp; y == v) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre[v] &lt; pre[u]) &#123;stk[++top] = make-<span class="hljs-built_in">pair</span>(u, v); low[u] = <span class="hljs-built_in">min</span>(low[u], pre[v]);&#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">return</span> fac[n] * <span class="hljs-number">1ll</span> * ifac[m] % MOD * ifac[n - m] % MOD;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m + k; ++i) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m + k; ++i) ifac[i] = (MOD - MOD / i) * <span class="hljs-number">1ll</span> * ifac[MOD % i] % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m + k; ++i) ifac[i] = ifac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * ifac[i] % MOD;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>    <span class="hljs-built_in">add</span>(u, v);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!pre[i]) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans1 = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>, ans3 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= bcc-cnt; i++) &#123;<br>    <span class="hljs-keyword">if</span>(siz-e[i] == <span class="hljs-number">1</span>) ans1 = ans1 * <span class="hljs-number">1ll</span> * k % MOD;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(siz-e[i] == siz-p[i]) &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; siz-e[i]; j++) &#123;<br>                sum += <span class="hljs-built_in">fpow</span>(k, <span class="hljs-built_in">gcd</span>(siz-p[i], j));<br>                <span class="hljs-keyword">if</span>(sum &gt;= MOD) sum -= MOD;<br>            &#125;<br>            ans2 = ans2 * <span class="hljs-number">1ll</span> * sum % MOD * <span class="hljs-built_in">fpow</span>(siz-e[i], MOD - <span class="hljs-number">2</span>) % MOD; <br>    &#125; <span class="hljs-keyword">else</span> ans3 = ans3 * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(siz-e[i] + k - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans1 * <span class="hljs-number">1ll</span> * ans2 % MOD * ans3 % MOD);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
      <tag>Burnside引理</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300IQ Summer 2020 Round 2</title>
    <link href="/2020/08/29/300IQ_Summer_2020_Round_2/"/>
    <url>/2020/08/29/300IQ_Summer_2020_Round_2/</url>
    
    <content type="html"><![CDATA[<h1 id="problem-a.-alternating-paths">Problem A. Alternating Paths</h1><p>还没改啊,先鸽着吧...<br /><span id="more"></span> # Problem B. Dispatch Money<br />假设区间<span class="math inline">\([l,r]\)</span>的逆序对数是<span class="math inline">\(f-{l,r}\)</span>.<br />显然<span class="math inline">\(f-{l,r}=f-{l+1,r}+f-{l,r-1}-f-{l+1,r-1}+[P-l&gt;P-r]\)</span>.<br />即<span class="math inline">\(f-{l,r} + f-{l+1,r-1} \geq f-{l+1,r}+f-{l,r-1}\)</span>,所以决策具有单调性.<br />那么可以用想到<a href="https://oi-wiki.org/misc/cdq-divide/">CDQ分治</a>来优化这个<span class="math inline">\(1D\)</span>的<span class="math inline">\(DP\)</span>方程.<br /><!--more--> 主要是快速算出区间的逆序对,感觉像莫队一样啊.<br />还是比较套路,不过这个<span class="math inline">\(\mathcal{O}(nlog^3n)\)</span>真的能过?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">300005</span>;<br><span class="hljs-keyword">int</span> n, x, p[N], t[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; b; ll f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">for</span>(; x &lt;= n; x += x &amp; -x) t[x] += v;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(; x; x -= x &amp; -x) res += t[x]; <span class="hljs-keyword">return</span> res;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(r) - <span class="hljs-built_in">query</span>(l - <span class="hljs-number">1</span>);&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123; <span class="hljs-comment">//求区间逆序对,类似于莫队?</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//printf(&quot;%d %d\n&quot;, L, R);</span><br>    <span class="hljs-keyword">static</span> ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l &gt; L) l--, res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, p[l]), <span class="hljs-built_in">update</span>(p[l], <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(r &lt; R) r++, res += <span class="hljs-built_in">query</span>(p[r], n), <span class="hljs-built_in">update</span>(p[r], <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(l &lt; L) <span class="hljs-built_in">update</span>(p[l], <span class="hljs-number">-1</span>), res -= <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, p[l]), l++;<br>    <span class="hljs-keyword">while</span>(r &gt; R) <span class="hljs-built_in">update</span>(p[r], <span class="hljs-number">-1</span>), res -= <span class="hljs-built_in">query</span>(p[r], n), r--;<br>    <span class="hljs-comment">//cout &lt;&lt; res &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CDQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tl, <span class="hljs-keyword">int</span> tr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123; <span class="hljs-comment">// 从[tl,tr] 转移到 [l,r]</span><br>    <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, pos = <span class="hljs-number">0</span>; ll res = <span class="hljs-number">1e17</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = tl; i &lt;= tr; i++) &#123;  <span class="hljs-comment">//枚举转移点</span><br>        ll v = <span class="hljs-built_in">inverse</span>(i + <span class="hljs-number">1</span>, mid) + f[i] + x;<br>        <span class="hljs-keyword">if</span>(v &lt; res) res = v, pos = i;<br>    &#125;<br>    f[mid] = <span class="hljs-built_in">min</span>(f[mid], res); <span class="hljs-built_in">CDQ</span>(tl, pos, l, mid - <span class="hljs-number">1</span>), <span class="hljs-built_in">CDQ</span>(pos, tr, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CDQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">CDQ</span>(l, mid); <span class="hljs-built_in">CDQ</span>(l, mid, mid + <span class="hljs-number">1</span>, r); <span class="hljs-built_in">CDQ</span>(mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;text.in&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p[i]), b.push-<span class="hljs-built_in">back</span>(p[i]);<br>    <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>    b.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()), b.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = lower-<span class="hljs-built_in">bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), p[i]) - b.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-built_in">CDQ</span>(<span class="hljs-number">0</span>, n);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```  <br><br># Problem C. Exerci<br>这个很容易想到$hash$来搞吧.  <br>最开始想到可能会把式子变形什么的,发现好像不太可行?  <br>然后又想到了两个乱搞的方法:  <br><span class="hljs-number">1.</span> 根据末尾的数字来判断,不过好像不太可行.<br><span class="hljs-number">2.</span> 用扩展欧几里得来解出一组特解,然后通解是可知并且有限的.如果可能的通解太多,就可以扔到一个序列里面,最后$\mathcal&#123;O&#125;(n^<span class="hljs-number">2</span>)$暴力考虑这些序列的元素有没有可能有解.否则直接用$hash$表来判断每对解是否合法.  <br><br>其实解法$<span class="hljs-number">2</span>$确实是可行的,但感觉不太对一直没有写...   <br>实际上解比较少,这种方法跑得还挺快?  <br><br>话说直接$\mathcal&#123;O&#125;(n^<span class="hljs-number">2</span>)$,$<span class="hljs-number">6</span>s$为什么可以跑$<span class="hljs-number">50000</span>$的数据啊?  <br>机房的同学还一直用魔法卡常,我直接写的$<span class="hljs-keyword">for</span>$循环反而很快过了$subtask1$?  <br>因为存$hash$表时要用点小技巧,还得开$int128$才行.  <br><br>```cpp<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int --int128</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200005</span>;<br><span class="hljs-keyword">int</span> n, k, x[N], y[N];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">print</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;d, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) &#123;x = <span class="hljs-number">1</span>, d = a, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b);<br>&#125;<br><br><span class="hljs-keyword">namespace</span> H &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">19260817</span>;<br>    <span class="hljs-keyword">int</span> hd[M] = &#123;&#125;, tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span>&#123;</span><span class="hljs-keyword">int</span> nxt, a, b;&#125;e[N];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> (a * <span class="hljs-number">1000000000</span> % M + b) % M;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> t = <span class="hljs-built_in">f</span>(a, b); e[++tot] = E&#123;hd[t], a, b&#125;;hd[t] = tot;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = hd[<span class="hljs-built_in">f</span>(a, b)]; i; i = e[i].nxt) <span class="hljs-keyword">if</span>(e[i].a == a &amp;&amp; e[i].b == b) <span class="hljs-keyword">return</span> i;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;text.in&quot;,&quot;r&quot;,stdin);</span><br>    n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        x[i] = <span class="hljs-built_in">read</span>(), y[i] = <span class="hljs-built_in">read</span>();<br>        H::<span class="hljs-built_in">ins</span>(x[i], y[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, d;<br>        <span class="hljs-built_in">exgcd</span>(x[i], y[i], d, a, b);<br>        <span class="hljs-keyword">if</span>(k % d != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        a *= k / d, b *= k / d;<br>        <span class="hljs-keyword">int</span> xx = x[i] / d, yy = y[i] / d;<br>        <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">int</span> kk = (-a) / yy + <span class="hljs-number">1</span>; a += yy * kk; b -= xx * kk;&#125;<br>        <span class="hljs-keyword">int</span> kk = a / yy; a -= kk * yy; b += xx * kk;<br>        <span class="hljs-keyword">int</span> root = b / xx;<br>        <span class="hljs-keyword">if</span>(root &gt; <span class="hljs-number">92</span>) &#123;v.push-<span class="hljs-built_in">back</span>(i); <span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">for</span>(root += <span class="hljs-number">1</span>; root &gt;= <span class="hljs-number">0</span>; root--) &#123;<br>            <span class="hljs-comment">//print(root);puts(&quot;&quot;);</span><br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//print(a), putchar(&#x27; &#x27;),print(b);puts(&quot;&quot;);</span><br>            <span class="hljs-keyword">int</span> p = H::<span class="hljs-built_in">qry</span>(a, b);<br>            <span class="hljs-keyword">if</span>(p != <span class="hljs-number">0</span>) &#123;(<span class="hljs-built_in">print</span>(i), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>), <span class="hljs-built_in">print</span>(p));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>            a += yy, b -= xx;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : v)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j : v) &#123;<br>            <span class="hljs-keyword">if</span>(x[i] * x[j] + y[i] * y[j] == k) &#123;<span class="hljs-built_in">print</span>(i),<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>),<span class="hljs-built_in">print</span>(j);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;114514&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDQ分治</tag>
      
      <tag>hash</tag>
      
      <tag>扩展欧几里得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300IQ Summer 2020 Round 1</title>
    <link href="/2020/08/29/300IQ_Summer_2020_Round_1/"/>
    <url>/2020/08/29/300IQ_Summer_2020_Round_1/</url>
    
    <content type="html"><![CDATA[<h1 id="problem-a.-good-subsegments">Problem A. Good Subsegments</h1><p><span class="math display">\[2^{a-l}+2^{a-{l+1}}+...+2^{a-r}=2^x\]</span> <span id="more"></span> 可以发现,<span class="math inline">\(x\leq max(a-l,a-{l+1}...a-r)+log-2^{r-l+1}\)</span>.<br />所以固定一个端点时,枚举<span class="math inline">\(x\)</span>的值去验证有没有等于<span class="math inline">\(2^x\)</span>的区间是可行的.<br />但是<span class="math inline">\(2^x\)</span>可能很大,高精度很麻烦也会<span class="math inline">\(TLE\)</span>,那怎么办呢?<br /><!--more--> 可以选一个大质数,然后把<span class="math inline">\(2^{a-l}+2^{a-{l+1}}+...+2^{a-r}=2^x\)</span>分别模上它也是相等的. 可以分治来做比较简单,每次找到当前区间的最大的<span class="math inline">\(a-i\)</span>,然后枚举<span class="math inline">\(i\)</span>左边的区间或者右边的区间(取决于区间长度).<br />端点固定后,就枚举<span class="math inline">\(x\)</span>,然后去哈希表验证一下有没有这样的另一个端点,如果存在这样的区间,那么就是合法的.<br />注意一下细节: 1. 在哈希表中要插入<span class="math inline">\((key=0,val=0)\)</span>,因为区间<span class="math inline">\([1,r]\)</span>可能是合法的,而对应区间的值是<span class="math inline">\(sum-r-sum-0\)</span>.<br />2. 要选一个尽量大的质数,不然出错的概率很大.哈希表也要选择一个尽量大的,<del>比如<span class="math inline">\(114514\)</span></del>.<br />3. 另外要用快速乘,因为模数是大于<span class="math inline">\(2^{31}-1\)</span>的.龟速乘可能会超时吧.<br />时间复杂度<span class="math inline">\(\mathcal{O}(nlog^2n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI pair<span class="hljs-meta-string">&lt;ll, int&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200005</span>;<br><span class="hljs-keyword">const</span> ll P = <span class="hljs-number">4398042316712111199</span>;<br><span class="hljs-keyword">int</span> n, a[N], lg[N];<br>ll sum[N], h[N], ans;<br>PI mx[N][<span class="hljs-number">20</span>];<br><br><span class="hljs-keyword">namespace</span> H &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">19260817</span>;<br>    <span class="hljs-keyword">int</span> hd[M] = &#123;&#125;, tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span>&#123;</span><span class="hljs-keyword">int</span> nxt, o; ll v;&#125;e[N];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(ll h, <span class="hljs-keyword">int</span> o)</span> </span>&#123;<span class="hljs-keyword">int</span> t = ((h % M + M) % M + M) % M, mx = <span class="hljs-built_in">max</span>(t, mx); e[++tot] = E&#123;hd[t], o, h&#125;; hd[t] = tot;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(ll h)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = hd[((h % M + M) % M + M) % M]; i; i = e[i].nxt) <span class="hljs-keyword">if</span>(e[i].v == h) <span class="hljs-keyword">return</span> e[i].o; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll c = a * b - (ll)((<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>)a * b / P + <span class="hljs-number">0.5</span>) * P;<br>    <span class="hljs-keyword">return</span> c &lt; <span class="hljs-number">0</span> ? c + P : c;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">fpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = <span class="hljs-built_in">mul</span>(a, a)) <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) ans = <span class="hljs-built_in">mul</span>(ans, a);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        ans += <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> len = lg[r - l + <span class="hljs-number">1</span>], m = <span class="hljs-built_in">max</span>(mx[l][len], mx[r - (<span class="hljs-number">1</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]).second;<br>    <span class="hljs-keyword">if</span>(r + l &gt;= m + m) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= m; i++) &#123;<br>            ll t = h[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">20</span>; j++) &#123;<br>                ll q = t + sum[i - <span class="hljs-number">1</span>]; <span class="hljs-keyword">if</span>(q &gt;= P) q -= P;<br>                <span class="hljs-keyword">int</span> p = H::<span class="hljs-built_in">query</span>(q);<br>                <span class="hljs-keyword">if</span>(p &gt;= m &amp;&amp; p &lt;= r) ans++; t *= <span class="hljs-number">2</span>; <span class="hljs-keyword">if</span>(t &gt;= P) t -= P;<br>            &#125; <br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt;= r; i++) &#123;<br>            ll t = h[m];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">20</span>; j++) &#123;<br>                ll q = sum[i] - t; <span class="hljs-keyword">if</span>(q &lt; <span class="hljs-number">0</span>) q += P;<br>                <span class="hljs-keyword">int</span> p = H::<span class="hljs-built_in">query</span>(q) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(p &lt;= m &amp;&amp; p &gt;= l) ans++; t *= <span class="hljs-number">2</span>; <span class="hljs-keyword">if</span>(t &gt;= P) t -= P;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">solve</span>(l, m - <span class="hljs-number">1</span>); <span class="hljs-built_in">solve</span>(m + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);H::<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = <span class="hljs-built_in">fpow</span>(<span class="hljs-number">2</span>, a[i]);<br>        sum[i] = (sum[i - <span class="hljs-number">1</span>] + h[i]) % P;<br>        H::<span class="hljs-built_in">insert</span>(sum[i], i);<br>        mx[i][<span class="hljs-number">0</span>] = make-<span class="hljs-built_in">pair</span>(a[i], i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">19</span>; j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) mx[i][j] = <span class="hljs-built_in">max</span>(mx[i][j - <span class="hljs-number">1</span>], mx[i + (<span class="hljs-number">1</span> &lt;&lt; j - <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="problem-b.-easy-sum">Problem B. Easy Sum</h1><p>还没改这道题啊,暂时鸽了.QωQ.</p><h1 id="problem-c.-funny-cost">Problem C. Funny Cost</h1><p>据说是最简单的一道...<br />题目不太好懂啊,翻译一下就是,给你<span class="math inline">\(N\)</span>个元素的序列. <img src="/image/07311.png" alt="Funny Cost" /><br />这个序列每个排列的代价是<span class="math inline">\(n+1\)</span>顶点的完美匹配边权和(顶点<span class="math inline">\(u,v\)</span>之间的边权是<span class="math inline">\(max-{i=u}^{v-1}a-i\)</span>),问你最大代价.</p><p>可以<del>暴搜</del>发现这样匹配是最优的.<br /><img src="/image/07312.png" alt="匹配方式" /> 怎么计算每个元素的贡献是多少呢?<br /><span class="math inline">\(n\)</span>是顶点数,考虑每个长度为<span class="math inline">\(\frac{n}{2}\)</span>的区间.<br />假设现在选出了最大值是第<span class="math inline">\(i\)</span>个,那么另外<span class="math inline">\(\frac{n}{2}-1\)</span>个顶点要选比它小的值,方案有<span class="math inline">\(\tbinom{i-1}{\frac{n}{2}-1}\)</span>种.<br />而这个顶点在数组中有<span class="math inline">\(\frac{n}{2}\)</span>种放法,区间里的顶点可以任意排列,答案乘上<span class="math inline">\(\frac{n}{2}!\)</span>.<br />而区间外的顶点也是,有<span class="math inline">\((\frac{n}{2}-1)!\)</span>种排列方法.<br />最后再乘上权值.<br />答案是<span class="math inline">\(\sum\limits-{i=\frac{n}{2}}^{n}a-i\times \tbinom{i-1}{\frac{n}{2}-1}\times \frac{n}{2}\times \frac{n}{2}! \times (\frac{n}{2}-1)!\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>, P = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">int</span> n, a[N], fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> fac[n] * <span class="hljs-number">1ll</span> * ifac[m] % P * ifac[n - m] % P;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::sync-with-<span class="hljs-built_in">stdio</span>(<span class="hljs-literal">false</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % P;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) ifac[i] = (P - P / i) * <span class="hljs-number">1ll</span> * ifac[P % i] % P;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) ifac[i] = ifac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * ifac[i] % P;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> m = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt;= n; i++) &#123;<br>        ans = (ans + <span class="hljs-number">1ll</span> * a[i] * <span class="hljs-built_in">C</span>(i - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>) % P * m % P * fac[m] % P * fac[m - <span class="hljs-number">1</span>]) % P;<br>    &#125; <br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2020 礼物</title>
    <link href="/2020/08/29/LOJ2020_%E7%A4%BC%E7%89%A9/"/>
    <url>/2020/08/29/LOJ2020_%E7%A4%BC%E7%89%A9/</url>
    
    <content type="html"><![CDATA[<p>写完一次就 AC 了是我没想到的...<br /><img src="https://widsnoy.top/usr/uploads/2020/08/696336677.jpg" alt="cjcjcj.jpg" /></p><p>可以假设增加了<span class="math inline">\(c\)</span>亮度.<br />即求<span class="math inline">\(\sum\limits-{i=1}^{n}(x-i-y-i+c)^2\)</span>的最小值.<br />把式子展开, <span class="math inline">\(\sum\limits-{i=1}^{n}x-i^2+\sum\limits-{i=1}^{n}{y-i}^2+nc^2+2c( \sum\limits-{i=1}^{n}(x-i-y-i))-2 \sum\limits-{i=1}^{n}x-iy-i\)</span><br /><span id="more"></span> 可以发现前面两项是固定的.<br />因为c比较小, <span class="math inline">\(|c|\leq m\)</span>, 中间两项可以直接枚举<span class="math inline">\(c\)</span>.<br />所以只需要求出<span class="math inline">\(\sum\limits-{i=1}^{n}x-iy-i\)</span>的最大值.<br />因为可以旋转, 等价于<span class="math inline">\(\sum\limits-{i=1}^{n}x-{n-i+1}y-i\)</span>.<br />可以看出这就是卷积的形式.<br />断环成链, 即求<span class="math inline">\(\sum\limits-{i=1}^{n}x-{n-i+1+k}y-i\)</span>, <span class="math inline">\(0 \leq k\leq n-1\)</span>.<br />所以把<span class="math inline">\(x\)</span>翻转后,复制成两份做 fft.<br />第<span class="math inline">\(n+1\)</span>到<span class="math inline">\(2n\)</span>的系数就对应了旋转后的<span class="math inline">\(\sum\limits-{i=1}^{n}x-iy-i\)</span>.<br />取一个最大值就做完了.<br />注意数组要开大一些, 因为还要把<span class="math inline">\(x\)</span>复制一份.<br /><span class="math inline">\(c\)</span>要在<span class="math inline">\(-m\)</span>, <span class="math inline">\(m\)</span>之间枚举, 因为展开后的式子可能是<span class="math inline">\(x-i-y-i\)</span>, 也可能是<span class="math inline">\(y-i-x-i\)</span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> complex&lt;<span class="hljs-keyword">double</span>&gt; cp; <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-keyword">int</span> n, m, len = <span class="hljs-number">1</span>, l, rev[N], x[N], y[N];<br>cp a[N * <span class="hljs-number">2</span>], b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(cp *a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> inv)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (rev[i] &lt; i) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-function">cp <span class="hljs-title">wn</span><span class="hljs-params">(cos(pi / k), inv * sin(pi / k))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += k * <span class="hljs-number">2</span>) &#123;<br><span class="hljs-function">cp <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++, w *= wn) &#123;<br>cp x = a[i + j], y = a[i + j + k] * w;<br>a[i + j] = x + y, a[i + j + k] = x - y;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (inv &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) a[i] /= n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ll res = <span class="hljs-number">0</span>, dis = <span class="hljs-number">0</span>, mx = <span class="hljs-number">-998244353</span>, ans = <span class="hljs-number">998244353</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x[i]), res = res + x[i] * <span class="hljs-number">1ll</span> * x[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;y[i]), res = res + y[i] * <span class="hljs-number">1ll</span> * y[i], dis += x[i] - y[i];<br>    <span class="hljs-keyword">while</span> (len &lt;= n * <span class="hljs-number">2</span>) len &lt;&lt;= <span class="hljs-number">1</span>, l++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((<span class="hljs-number">1</span> &amp; i) &lt;&lt; (l - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i].<span class="hljs-built_in">real</span>((<span class="hljs-keyword">double</span>)(x[n - i + <span class="hljs-number">1</span>])), b[i].<span class="hljs-built_in">real</span>((<span class="hljs-keyword">double</span>)(y[i]));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i + n].<span class="hljs-built_in">real</span>(a[i].<span class="hljs-built_in">real</span>());<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) a[i] *= b[i];<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) mx = <span class="hljs-built_in">max</span>(mx, (ll)(a[i].<span class="hljs-built_in">real</span>() + <span class="hljs-number">0.5</span>));<br>    mx *= <span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = -m; c &lt;= m; c++)  ans = <span class="hljs-built_in">min</span>(ans, n * <span class="hljs-number">1ll</span> * c * c + <span class="hljs-number">2</span> * c * <span class="hljs-number">1ll</span> * dis);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res + mx + ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>FFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ535「LibreOJ Round</title>
    <link href="/2020/08/29/LOJ535%E3%80%8CLibreOJ_Round_#6%E3%80%8D%E8%8A%B1%E7%81%AB/"/>
    <url>/2020/08/29/LOJ535%E3%80%8CLibreOJ_Round_#6%E3%80%8D%E8%8A%B1%E7%81%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接:<a href="https://loj.ac/problem/535">https://loj.ac/problem/535</a></p></blockquote><p>虽然写几个不同的方法写了三个小时,做这道题收获还是挺大/cy.<br />## 题目 <span class="math inline">\(n\)</span>个烟火排成一排，从左到右高度分别为<span class="math inline">\(h-1,h-2,...,h-n\)</span> ，这些高度两两不同。<br />每次 Yoko 可以选择两个相邻的烟火交换，这样的交换可以进行任意多次。 <span id="more"></span> 每次 Yoko 还可以选择两个不相邻的烟火交换，但这样的交换至多进行一次。<br />你的任务是帮助 Yoko 用最少次数的交换，使这些烟火从左到右的高度递增。</p><h2 id="题解">题解</h2><h3 id="分">0分</h3><p>这个就各显神通了. ### 17分 好像也没什么好说的,直接暴搜就可以了.<br />### 41分 其实对于交换不相邻的烟火,先后顺序是无所谓的.<br />因为即使最开始不交换,也可以按照交换了的情况去操作,最后再交换.这样次数也是一样的.<br />那么就不妨最开始就进行交换不相邻元素的操作.<br />之后剩下的都只能交换相邻的,交换次数就是逆序对的个数.<br />因为所有元素排好序也等价于没有逆序对,每一次交换就会减少一个逆序对,所以逆序对个数也就是剩下的交换次数了.<br /><a href="https://loj.ac/submission/896987">code</a><br />实际上也不用每次都去重新算逆序对,可以考虑交换元素之后的变化,这样做能多过一个子任务,不过太麻烦了.<br />### 67分 可以想到数形结合,这也是后面做法的基础.<br />在以序号为横轴,权值为纵轴的平面直角坐标系上,每个点的逆序对就是它左上方的元素.<br />第一步交换两个不相邻的点减少的逆序对数等于左上方的点和右下方的点构成的矩形中包含的点的个数.(不包括这两个点本身).<br />随便画个图模拟一下就很好理解.<br />一个直观的想法就是二维前缀和.就可以<span class="math inline">\(/mathcal{O}(1)\)</span>算出来交换两个点后还需要的交换次数.<br /><a href="https://loj.ac/submission/897049">code</a><br />### 100分<br />有了前面的基础这个应该不难理解.<br />直观的想法是用线段数加扫描线的方法去数点.<del>但是这个太难写了先鸽了</del><br /><span class="math inline">\(67\)</span>分的做法主要慢在算矩形中的点上.<br />选的两个点决策是满足单调性的,而且分别在两个从<span class="math inline">\(1\)</span>开始和到<span class="math inline">\(n\)</span>结束的上升子序列上面.<br />然后分治就行了.<br />可以用树状数组来快速算出某个矩形中的点数,好像都是基本操作?<br /><a href="https://loj.ac/submission/897150">code</a><br />有时间写一下另一个做法...</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>CDQ分治</tag>
      
      <tag>扫描线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2952 赛道修建</title>
    <link href="/2020/08/29/LOJ2952_%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/"/>
    <url>/2020/08/29/LOJ2952_%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/2952">link</a><br />看完题目很容易想到二分答案,只用考虑怎么检验答案合法.<br />因为是一颗树的形态,所以在树上<span class="math inline">\(dfs\)</span>时候修建赛道就行了. <span id="more"></span><br />对当前节点<span class="math inline">\(u\)</span>分类讨论一下:<br />1. 儿子所代表的子树尽量内部修建赛道,因为这样一定不会更劣.<br />2. 把不能内部修建的最大的路径值返回给<span class="math inline">\(u\)</span>,看看它能不能和其他的不能单独修建的路径组合在一起.<br />这样得到的答案一定是当前最优的,且不会有边被重复使用.<br />因为不想写平衡树,直接用了<span class="math inline">\(multiset\)</span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, mid, cnt, tot, head[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span> &#123;</span><br>    <span class="hljs-keyword">int</span> nxt, v, w;<br>&#125;e[N &lt;&lt; <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[++tot] = E&#123;head[a], b, c&#125;; head[a] = tot;<br>    e[++tot] = E&#123;head[b], a, c&#125;; head[b] = tot;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IT multiset<span class="hljs-meta-string">&lt;int&gt;</span>::iterator</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    multiset&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].v, w = e[i].w;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">dfs</span>(v, u) + w;<br>        <span class="hljs-keyword">if</span> (d &gt;= mid) cnt++;<br>        <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">insert</span>(d);<br>    &#125;<br>    <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        IT it = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">int</span> x = *it;<br>        s.<span class="hljs-built_in">erase</span>(it);<br>        IT t = s.lower-<span class="hljs-built_in">bound</span>(mid - x);<br>        <span class="hljs-keyword">if</span> (t == s.<span class="hljs-built_in">end</span>()) mx = x;<br>        <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">erase</span>(t), cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;track.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;track.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u, v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>        <span class="hljs-built_in">add</span>(u, v, w);<br>        l = <span class="hljs-built_in">min</span>(l, w); r += w;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (cnt &gt;= m) l = mid + <span class="hljs-number">1</span>, ans = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2200 力</title>
    <link href="/2020/08/29/LOJ2200_%E5%8A%9B/"/>
    <url>/2020/08/29/LOJ2200_%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>如果把原式化为卷积形式，就可以用<span class="math inline">\(FFT\)</span>优化。　　 <span id="more"></span> <span class="math inline">\(E-j=\frac{F-j}{q-j}=\sum\limits-{i=1}^{j-1}\frac{q-i}{(i-j)^2}-\sum\limits-{i=j+1}^{n}\frac{q-i}{(i-j)^2}\)</span><br /><span class="math inline">\(E-j=\frac{F-j}{q-j}=\sum\limits-{i=0}^{j}\frac{q-i}{(i-j)^2}-\sum\limits-{i=j}^{n}\frac{q-i}{(i-j)^2}\)</span> 令<span class="math inline">\(f(i)=q-i,g(i)=\frac{1}{i^2}\)</span><br />则原式, <span class="math inline">\(E-j=\sum\limits-{i=0}^{j}f(i)g(i-j)-\sum\limits-{i=0}^{n-j}f(i+j)g(i)\)</span>　　 左边已经是卷积形式了，考虑右边。　　 把右边拆开，<span class="math inline">\(f(j)g(0)+f(j+1)g(1)+...+f(j+(n-j))g(n-j)\)</span>.<br />做一下翻转<span class="math inline">\(f(j)=f&#39;(n-j)\)</span>.<br /><span class="math inline">\(\sum\limits-{i=j}^{n}f(i)g(i-j)=\sum\limits-{i=0}^{n-j}f&#39;(n-(j+i))g(i)\)</span><br />然后右边也是卷积形式了。　　 设<span class="math inline">\(A(x)=\sum\limits-{i=0}^{n}f(i)\)</span>,<span class="math inline">\(B(x)=\sum\limits-{i=0}^{n}f&#39;(i)\)</span>,<span class="math inline">\(C(x)=\sum\limits-{i=0}^{n}g(i)\)</span>.<br /><span class="math inline">\(E-j\)</span>等于<span class="math inline">\(A(x)\cdot C(x)\)</span>的第<span class="math inline">\(j\)</span>项系数和<span class="math inline">\(B(x)\cdot C(x)\)</span>的第<span class="math inline">\(n-j\)</span>项系数之差。　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> complex&lt;<span class="hljs-keyword">double</span>&gt; cp;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">8e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-keyword">int</span> n, l, len, rev[N];<br>cp a[N], b[N], c[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(cp *a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> inv)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (i &lt; rev[i]) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-function">cp <span class="hljs-title">wn</span><span class="hljs-params">(cos(pi / k), inv * sin(pi / k))</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += k * <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-function">cp <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++, w *= wn) &#123;<br>                cp x = a[i + j], y = w * a[i + j + k];<br>                a[i + j] = x + y, a[i + j + k] = x - y;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inv &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) a[i] /= n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;a[i]);<br>        b[n - i] = a[i];<br>        c[i] = <span class="hljs-number">1.0</span> / i / i;<br>    &#125;<br>    len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (len &lt;= n * <span class="hljs-number">2</span>) len &lt;&lt;= <span class="hljs-number">1</span>, l++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (l - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(c, len, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        a[i] = a[i] * c[i];<br>        b[i] = b[i] * c[i];<br>    &#125;<br>    <span class="hljs-built_in">fft</span>(a, len, <span class="hljs-number">-1</span>); <span class="hljs-built_in">fft</span>(b, len, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, a[i].<span class="hljs-built_in">real</span>() - b[n - i].<span class="hljs-built_in">real</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FFT</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ6216 雪花挂饰</title>
    <link href="/2020/08/29/LOJ6216_%E9%9B%AA%E8%8A%B1%E6%8C%82%E9%A5%B0/"/>
    <url>/2020/08/29/LOJ6216_%E9%9B%AA%E8%8A%B1%E6%8C%82%E9%A5%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6216">题目链接</a></p><p>从<span class="math inline">\(n\)</span>片雪花里面选<span class="math inline">\(i\)</span>个的方案数是<span class="math inline">\(\tbinom{n}{i}\)</span>个.<br />根据<a href="https://zh.wikipedia.org/zh/%E5%87%B1%E8%90%8A%E5%AE%9A%E7%90%86">Cayley定理</a>,<span class="math inline">\(i\)</span>个有标号的点形成无根树的方案数是<span class="math inline">\(i^{i-2}\)</span>.<br /><span id="more"></span> 所以选择<span class="math inline">\(i\)</span>片雪花时的方案数是<span class="math inline">\(\tbinom{n}{i}i^{i-2}\)</span>.<br />对于一个区间答案是<span class="math inline">\(\sum\limits-{i=l}^{r}\tbinom{n}{i}i^{i-2}\)</span>.<br />因为询问较多可以用前缀和优化.<br /><span class="math inline">\(ans-{l,r}=(sum[r]-sum[l-1)\ mod\ P=(sum[r]\ mod\ P+sum[l-r]\ mod\ P)\ mod\ P\)</span>.<br />时间复杂度<span class="math inline">\(\mathcal{O}(nlogn)\)</span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//CCCCCCCCCCCCCCCOrz</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> MOD, n, T, sum[N], fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> fac[n] * <span class="hljs-number">1ll</span> * ifac[m] % MOD * ifac[n - m] % MOD;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * <span class="hljs-number">1ll</span> * a % MOD) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = ans * <span class="hljs-number">1ll</span> * a % MOD;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;T, &amp;MOD);<br>    fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * i % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) ifac[i] = (MOD - MOD / i) * <span class="hljs-number">1ll</span> * ifac[MOD % i] % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) ifac[i] = ifac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> * ifac[i] % MOD;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) sum[i] = (sum[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1ll</span> + <span class="hljs-built_in">fpow</span>(i, i - <span class="hljs-number">2</span>) * <span class="hljs-number">1ll</span> * <span class="hljs-built_in">C</span>(n, i)) % MOD;<br>    <span class="hljs-keyword">while</span>(T--) &#123;<br>        <span class="hljs-keyword">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (sum[r] - sum[l - <span class="hljs-number">1</span>] + MOD) % MOD);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ10202 樱花</title>
    <link href="/2020/08/29/LOJ10202_%E6%A8%B1%E8%8A%B1/"/>
    <url>/2020/08/29/LOJ10202_%E6%A8%B1%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>求不定方程<br /><span class="math display">\[\frac{1}{x}+\frac{1}{y}=\frac{1}{n!}\]</span><br />的正整数解<span class="math inline">\((x,y)\)</span>的个数。<br /><span id="more"></span></p><h1 id="题解">题解</h1><p>因为正整数<span class="math inline">\(x,y\)</span>，所以<span class="math inline">\(x,y&gt;n!\)</span>。<br />设<span class="math inline">\(x=n!+a\)</span>，<span class="math inline">\(y=n!+b\)</span>。<span class="math inline">\(a,b&gt;0\)</span>。<br />可以把式子化为<span class="math inline">\(a\times b=(n!)^2\)</span>。<br />只要将<span class="math inline">\((n!)^2\)</span>分解一下，约数个数是<span class="math inline">\(\prod-{i=1}^{k} q-i+1\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, P = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> a, b, n, fac, cnt[N], prime[N], vis[N], tot;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pri</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!vis[i]) prime[++tot] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;<br>        vis[prime[j] * i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; prime[i] * prime[i] &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">while</span>(x % prime[i] == <span class="hljs-number">0</span>) &#123;<br>        x /= prime[i];<br>        cnt[prime[i]]++;<br>        &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(x != <span class="hljs-number">1</span>) cnt[x] += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n; <span class="hljs-built_in">pri</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">calc</span>(i);<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = ans * <span class="hljs-number">1ll</span> * (cnt[i] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) % P;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ2958「COCI 2009.10」ALADIN</title>
    <link href="/2020/08/29/LOJ2958%E3%80%8CCOCI_2009.10%E3%80%8DALADIN/"/>
    <url>/2020/08/29/LOJ2958%E3%80%8CCOCI_2009.10%E3%80%8DALADIN/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/2958">类欧几里得算法例题</a></p></blockquote><p>上午学了类欧,来做道例题练习一下.</p><h2 id="题目">题目</h2><p>懒得说了,链接在上面...</p><h2 id="题解">题解</h2><p>根据题意,每次做<span class="math inline">\(1\)</span>操作的时候都是区间覆盖,所以原来的值和新的值没有关系.<br /><span id="more"></span> 假设现在覆盖了区间<span class="math inline">\(l,r\)</span>,怎么快速求出区间和呢?<br />设<span class="math inline">\(n=l-r+1\)</span>,<br />即求<br /><span class="math inline">\(\ \ \ \ \sum\limits-{i=0}^ni\cdot A\bmod B\)</span><br /><span class="math inline">\(=\sum\limits-{i=0}^{n}i\cdot A-\left\lfloor\frac{i\cdot A}{B}\right\rfloor \cdot B\)</span><br /><span class="math inline">\(=A\cdot\sum\limits-{i=0}^ni-B\cdot\sum\limits-{i=0}^n\left\lfloor\frac{i\cdot A}{B}\right\rfloor\)</span></p><p>观察发现,左边就是一个等差数列,考虑右边怎么做.<br />也就是这个式子 $ f(a,b,c,n)=-{i=0}^n <span class="math inline">\(, 只不过是\)</span>b=0$的情况.<br />$      f(a,b,c,n)=-{i=0}^n  $<br /><span class="math inline">\(=\sum\limits-{i=0}^n\left\lfloor \frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}\right\rfloor\)</span><br /><span class="math inline">\(=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+ \sum\limits-{i=0}^n\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c} \right\rfloor\)</span> <span class="math inline">\(=\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor +(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)\)</span></p><p>现在只用考虑<span class="math inline">\(a&lt;c,b&lt;c\)</span>的情况.<br />把式子变化一下, 因为想消去<span class="math inline">\(i\)</span>,所以增加一个变量, <span class="math inline">\(f(a,b,c,n)=\sum\limits-{i=0}^{n} \sum\limits-{j=0}^{\left\lfloor\frac{ai+b}{c} \right\rfloor -1} 1\)</span><br />交换求和符号.<br /><span class="math inline">\(\sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1} \sum\limits-{i=0}^n\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\)</span></p><p>因为<span class="math inline">\(j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\Leftrightarrow j+1\leq \left\lfloor \frac{ai+b}{c} \right\rfloor\Leftrightarrow j+1\leq \frac{ai+b}{c}\Leftrightarrow cj+c\leq ai+b\Leftrightarrow \left\lfloor\frac{cj+c-b-1}{a}\right\rfloor&lt;i\)</span></p><p>所以<br /><span class="math inline">\(\ \ \sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1} \sum\limits-{i=0}^n\left[\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor&lt;i\right]\)</span><br /><span class="math inline">\(=\sum\limits-{j=0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1}n-\left\lfloor\frac{cj+c-b-1}{a}\right\rfloor\)</span><br /><span class="math inline">\(=\left\lfloor \frac{an+b}{c} \right\rfloor\times n-f(c,c-b-1,a,\left\lfloor \frac{an+b}{c} \right\rfloor-1)\)</span><br />发现<span class="math inline">\(a,c\)</span>也恰好是交换的,是可以像欧几里得算法那样递归处理.</p><p>区间和能求出来了,但是询问的区间不一定就是修改的区间啊!<br />假设现在要查询<span class="math inline">\(l,r\)</span>的和,我们只用知道其中的子区间是哪次覆盖产生的就可以了.<br />我们记录子区间的是第几次覆盖产生的,就可以知道这段子区间的值.<br />具体就是把覆盖的那次的整个区间的值用上面方法算出来,减去除开这段子区间的就可以了.<br />每次计算的时间复杂度都是<span class="math inline">\(\mathcal{O}(logn)\)</span>的.<br />问题来了,怎么知道到底有哪些子区间呢?<br />我的想法是用珂朵莉树来模拟每次的<span class="math inline">\(1\)</span>操作,最后每个块就恰好就是所谓的子区间了.<br />每个块只需要记录一下左右端点和所对应的操作编号就行了.<br />当然也可以用线段树来做,其他题解说得很清楚了.</p><h2 id="代码">代码</h2><p>话说是不是写得很丑啊...</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//CCCCCCCCCCCCCCCCCCCCCCCCOrz</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int --int128</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Q = <span class="hljs-number">50005</span>;<br><span class="hljs-comment">//ODT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> l, r;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R = <span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span> ID = <span class="hljs-number">-1</span>) : <span class="hljs-built_in">l</span>(L), <span class="hljs-built_in">r</span>(R), <span class="hljs-built_in">id</span>(ID) &#123;&#125;  <br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;x) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> l &lt; x.l;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br>    <span class="hljs-keyword">int</span> op, l, r, a, b;<br>&#125;a[Q];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IT set<span class="hljs-meta-string">&lt;node&gt;</span>::iterator</span><br>set&lt;node&gt; s;<br><br><span class="hljs-function">IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>    IT it = s.lower-<span class="hljs-built_in">bound</span>(<span class="hljs-built_in">node</span>(pos));<br>    <span class="hljs-keyword">if</span>(it -&gt; l == pos &amp;&amp; it != s.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> it;<br>    --it;<br>    <span class="hljs-keyword">int</span> v = it-&gt;id, l = it-&gt;l, r = it-&gt;r;<br>    s.<span class="hljs-built_in">erase</span>(it); s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l, pos - <span class="hljs-number">1</span>, v));<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(pos, r, v)).first;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    IT itr = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(l);<br>    s.<span class="hljs-built_in">erase</span>(itl, itr);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l, r, id));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        w = w * <span class="hljs-number">10</span> + ch - <span class="hljs-number">48</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> w * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">print</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + <span class="hljs-number">1</span>, n2 = n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, d;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;<br>        d = bc * n1;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a &gt;= c || b &gt;= c) &#123;<br>        d = n * n1 / <span class="hljs-number">2</span> * ac + bc * n1;<br>        <span class="hljs-keyword">int</span> e = <span class="hljs-built_in">calc</span>(n, a % c, b % c, c);<br>        d += e;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-keyword">int</span> e = <span class="hljs-built_in">calc</span>(m - <span class="hljs-number">1</span>, c, c - b - <span class="hljs-number">1</span>, a);<br>    d = n * m - e;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (n + <span class="hljs-number">1</span>) * n / <span class="hljs-number">2</span> * a - b * <span class="hljs-built_in">calc</span>(n - <span class="hljs-number">1</span>, a, a, b);<br>&#125;<br><span class="hljs-function">IT <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>    IT it = s.lower-<span class="hljs-built_in">bound</span>(<span class="hljs-built_in">node</span>(pos));<br>    <span class="hljs-keyword">if</span>(it -&gt; l == pos &amp;&amp; it != s.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> it;<br>    --it;<br>    <span class="hljs-keyword">return</span> it;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> L = a[id].l;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">val</span>(r - L + <span class="hljs-number">1</span>, a[id].a, a[id].b) - <span class="hljs-built_in">val</span>(l - L, a[id].a, a[id].b);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    IT itl = <span class="hljs-built_in">find</span>(l), itr = <span class="hljs-built_in">find</span>(r);<br>    <span class="hljs-keyword">if</span> (itl == itr) &#123;<br>        ans = <span class="hljs-built_in">sum</span>(l, r, itl-&gt;id);<br>        <span class="hljs-built_in">print</span>(ans);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ans += <span class="hljs-built_in">sum</span>(l, itl-&gt;r, itl-&gt;id);<br>    ans += <span class="hljs-built_in">sum</span>(itr-&gt;l, r, itr-&gt;id);<br>    itl++;<br>    <span class="hljs-keyword">if</span> (itl == itr) &#123;<br>        <span class="hljs-built_in">print</span>(ans); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    itr--;<br>    <span class="hljs-keyword">for</span> (IT it = itl; ; ++it) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;id != <span class="hljs-number">0</span>) ans += <span class="hljs-built_in">sum</span>(it-&gt;l, it-&gt;r, it-&gt;id);<br>        <span class="hljs-keyword">if</span> (it == itr) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(ans);<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-built_in">main</span>() &#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">read</span>(), q = <span class="hljs-built_in">read</span>();<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">0</span>));<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>        a[i].op = <span class="hljs-built_in">read</span>(), a[i].l = <span class="hljs-built_in">read</span>(), a[i].r = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (a[i].op == <span class="hljs-number">1</span>) a[i].a = <span class="hljs-built_in">read</span>(), a[i].b = <span class="hljs-built_in">read</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i].op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">assign</span>(a[i].l, a[i].r, i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">solve</span>(a[i].l, a[i].r);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>类欧几里得</tag>
      
      <tag>珂朵莉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
